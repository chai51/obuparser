import { BitReader } from "./BitReader";

// 3. Symbols and abbreviated terms
const REFS_PER_FRAME = 7;
const TOTAL_REFS_PER_FRAME = 8;
const BLOCK_SIZE_GROUPS = 4;
const BLOCK_SIZES = 22;
const BLOCK_INVALID = 22;
const MAX_SB_SIZE = 128;
const MI_SIZE = 4;
const MI_SIZE_LOG2 = 2;
const MAX_TILE_WIDTH = 4096;
const MAX_TILE_AREA = 4096 * 2304;
const MAX_TILE_ROWS = 64;
const MAX_TILE_COLS = 64;
const INTRABC_DELAY_PIXELS = 256;
const INTRABC_DELAY_SB64 = 4;
const NUM_REF_FRAMES = 8;
const IS_INTER_CONTEXTS = 4;
const REF_CONTEXTS = 3;
const MAX_SEGMENTS = 8;
const SEGMENT_ID_CONTEXTS = 3;
const SEG_LVL_ALT_Q = 0;
const SEG_LVL_ALT_LF_Y_V = 1;
const SEG_LVL_REF_FRAME = 5;
const SEG_LVL_SKIP = 6;
const SEG_LVL_GLOBALMV = 7;
const SEG_LVL_MAX = 8;
const PLANE_TYPES = 2;
const TX_SIZE_CONTEXTS = 3;
const INTERP_FILTERS = 3;
const INTERP_FILTER_CONTEXTS = 16;
const SKIP_MODE_CONTEXTS = 3;
const SKIP_CONTEXTS = 3;
const PARTITION_CONTEXTS = 4;
const TX_SIZES = 5;
const TX_SIZES_ALL = 19;
const TX_MODES = 3;
const DCT_DCT = 0;
const ADST_DCT = 1;
const DCT_ADST = 2;
const ADST_ADST = 3;
const FLIPADST_DCT = 4;
const DCT_FLIPADST = 5;
const FLIPADST_FLIPADST = 6;
const ADST_FLIPADST = 7;
const FLIPADST_ADST = 8;
const IDTX = 9;
const V_DCT = 10;
const H_DCT = 11;
const V_ADST = 12;
const H_ADST = 13;
const V_FLIPADST = 14;
const H_FLIPADST = 15;
const TX_TYPES = 16;
const MB_MODE_COUNT = 17;
const INTRA_MODES = 13;
const UV_INTRA_MODES_CFL_NOT_ALLOWED = 13;
const UV_INTRA_MODES_CFL_ALLOWED = 14;
const COMPOUND_MODES = 8;
const COMPOUND_MODE_CONTEXTS = 8;
const COMP_NEWMV_CTXS = 5;
const NEW_MV_CONTEXTS = 6;
const ZERO_MV_CONTEXTS = 2;
const REF_MV_CONTEXTS = 6;
const DRL_MODE_CONTEXTS = 3;
const MV_CONTEXTS = 2;
const MV_INTRABC_CONTEXT = 1;
const MV_JOINTS = 4;
const MV_CLASSES = 11;
const CLASS0_SIZE = 2;
const MV_OFFSET_BITS = 10;
const MAX_LOOP_FILTER = 63;
const REF_SCALE_SHIFT = 14;
const SUBPEL_BITS = 4;
const SUBPEL_MASK = 15;
const SCALE_SUBPEL_BITS = 10;
const MV_BORDER = 128;
const PALETTE_COLOR_CONTEXTS = 5;
const PALETTE_MAX_COLOR_CONTEXT_HASH = 8;
const PALETTE_BLOCK_SIZE_CONTEXTS = 7;
const PALETTE_Y_MODE_CONTEXTS = 3;
const PALETTE_UV_MODE_CONTEXTS = 2;
const PALETTE_SIZES = 7;
const PALETTE_COLORS = 8;
const PALETTE_NUM_NEIGHBORS = 3;
const DELTA_Q_SMALL = 3;
const DELTA_LF_SMALL = 3;
const QM_TOTAL_SIZE = 3344;
const MAX_ANGLE_DELTA = 3;
const DIRECTIONAL_MODES = 8;
const ANGLE_STEP = 3;
const TX_SET_TYPES_INTRA = 3;
const TX_SET_TYPES_INTER = 4;
const WARPEDMODEL_PREC_BITS = 16;
const IDENTITY = 0;
const TRANSLATION = 1;
const ROTZOOM = 2;
const AFFINE = 3;
const GM_ABS_TRANS_BITS = 12;
const GM_ABS_TRANS_ONLY_BITS = 9;
const GM_ABS_ALPHA_BITS = 12;
const DIV_LUT_PREC_BITS = 14;
const DIV_LUT_BITS = 8;
const DIV_LUT_NUM = 257;
const MOTION_MODES = 3;
const SIMPLE = 0;
const OBMC = 1;
const LOCALWARP = 2;
const LEAST_SQUARES_SAMPLES_MAX = 8;
const LS_MV_MAX = 256;
const WARPEDMODEL_TRANS_CLAMP = 1;
const WARPEDMODEL_NONDIAGAFFINE_CLAMP = 1;
const WARPEDPIXEL_PREC_SHIFTS = 1;
const WARPEDDIFF_PREC_BITS = 10;
const GM_ALPHA_PREC_BITS = 15;
const GM_TRANS_PREC_BITS = 6;
const GM_TRANS_ONLY_PREC_BITS = 3;
const INTERINTRA_MODES = 4;
const MASK_MASTER_SIZE = 64;
const SEGMENT_ID_PREDICTED_CONTEXTS = 3;
const FWD_REFS = 4;
const BWD_REFS = 3;
const SINGLE_REFS = 7;
const UNIDIR_COMP_REFS = 4;
const COMPOUND_TYPES = 2;
const CFL_JOINT_SIGNS = 8;
const CFL_ALPHABET_SIZE = 16;
const COMP_INTER_CONTEXTS = 5;
const COMP_REF_TYPE_CONTEXTS = 5;
const CFL_ALPHA_CONTEXTS = 6;
const INTRA_MODE_CONTEXTS = 5;
const COMP_GROUP_IDX_CONTEXTS = 6;
const COMPOUND_IDX_CONTEXTS = 6;
const INTRA_EDGE_KERNELS = 3;
const INTRA_EDGE_TAPS = 5;
const FRAME_LF_COUNT = 4;
const MAX_VARTX_DEPTH = 2;
const TXFM_PARTITION_CONTEXTS = 21;
const REF_CAT_LEVEL = 640;
const MAX_REF_MV_STACK_SIZE = 8;
const MFMV_STACK_SIZE = 3;
const MAX_TX_DEPTH = 2;
const WEDGE_TYPES = 16;
const FILTER_BITS = 7;
const WIENER_COEFFS = 3;
const SGRPROJ_PARAMS_BITS = 4;
const SGRPROJ_PRJ_SUBEXP_K = 4;
const SGRPROJ_PRJ_BITS = 7;
const SGRPROJ_RST_BITS = 4;
const SGRPROJ_MTABLE_BITS = 20;
const SGRPROJ_RECIP_BITS = 12;
const SGRPROJ_SGR_BITS = 8;
const EC_PROB_SHIFT = 6;
const EC_MIN_PROB = 4;
const SELECT_SCREEN_CONTENT_TOOLS = 2;
const SELECT_INTEGER_MV = 2;
const RESTORATION_TILESIZE_MAX = 256;
const MAX_FRAME_DISTANCE = 31;
const MAX_OFFSET_WIDTH = 8;
const MAX_OFFSET_HEIGHT = 0;
const WARP_PARAM_REDUCE_BITS = 6;
const NUM_BASE_LEVELS = 2;
const COEFF_BASE_RANGE = 12;
const BR_CDF_SIZE = 4;
const SIG_COEF_CONTEXTS_EOB = 4;
const SIG_COEF_CONTEXTS_2D = 26;
const SIG_COEF_CONTEXTS = 42;
const SIG_REF_DIFF_OFFSET_NUM = 5;
const SUPERRES_NUM = 8;
const SUPERRES_DENOM_MIN = 9;
const SUPERRES_DENOM_BITS = 3;
const SUPERRES_FILTER_BITS = 6;
const SUPERRES_FILTER_SHIFTS = 1;
const SUPERRES_FILTER_TAPS = 8;
const SUPERRES_FILTER_OFFSET = 3;
const SUPERRES_SCALE_BITS = 14;
const SUPERRES_SCALE_MASK = (1 << 14) - 1;
const SUPERRES_EXTRA_BITS = 8;
const TXB_SKIP_CONTEXTS = 13;
const EOB_COEF_CONTEXTS = 9;
const DC_SIGN_CONTEXTS = 3;
const LEVEL_CONTEXTS = 21;
const TX_CLASS_2D = 0;
const TX_CLASS_HORIZ = 1;
const TX_CLASS_VERT = 2;
const REFMVS_LIMIT = (1 << 12) - 1;
const INTRA_FILTER_SCALE_BITS = 4;
const INTRA_FILTER_MODES = 5;
const COEFF_CDF_Q_CTXS = 4;
const PRIMARY_REF_NONE = 7;
const BUFFER_POOL_MAX_SIZE = 10;

// 4.7. Mathematical functions
function Round2(x: number, n: number) {
  if (n == 0)
    return x;
  return (x + (1 << (n - 1))) >> n;
}

function CeilLog2(x: number) {
  if (x < 2)
    return 0;
  let i = 1;
  let p = 2;
  while (p < x) {
    i++;
    p = p << 1;
  }
  return i;
}

// 6.2.2. OBU header semantics
export const OBU_SEQUENCE_HEADER = 1;
export const OBU_TEMPORAL_DELIMITER = 2;
export const OBU_FRAME_HEADER = 3;
export const OBU_TILE_GROUP = 4;
export const OBU_METADATA = 5;
export const OBU_FRAME = 6;
export const OBU_REDUNDANT_FRAME_HEADER = 7;
export const OBU_TILE_LIST = 8;
export const OBU_PADDING = 9;

// 6.4.2. Color config semantics
const CP_BT_709 = 1;
const CP_UNSPECIFIED = 2;
const CP_BT_470_M = 4;
const CP_BT_470_B_G = 5;
const CP_BT_601 = 6;
const CP_SMPTE_240 = 7;
const CP_GENERIC_FILM = 8;
const CP_BT_2020 = 9;
const CP_XYZ = 10;
const CP_SMPTE_431 = 11;
const CP_SMPTE_432 = 12;
const CP_EBU_3213 = 22;

const TC_RESERVED_0 = 0;
const TC_BT_709 = 1;
const TC_UNSPECIFIED = 2;
const TC_RESERVED_3 = 3;
const TC_BT_470_M = 4;
const TC_BT_470_B_G = 5;
const TC_BT_601 = 6;
const TC_SMPTE_240 = 7;
const TC_LINEAR = 8;
const TC_LOG_100 = 9;
const TC_LOG_100_SQRT10 = 10;
const TC_IEC_61966 = 11;
const TC_BT_1361 = 12;
const TC_SRGB = 13;
const TC_BT_2020_10_BIT = 14;
const TC_BT_2020_12_BIT = 15;
const TC_SMPTE_2084 = 16;
const TC_SMPTE_428 = 17;
const TC_HLG = 18;

const MC_IDENTITY = 0;
const MC_BT_709 = 1;
const MC_UNSPECIFIED = 2;
const MC_RESERVED_3 = 3;
const MC_FCC = 4;
const MC_BT_470_B_G = 5;
const MC_BT_601 = 6;
const MC_SMPTE_240 = 7;
const MC_SMPTE_YCGCO = 8;
const MC_BT_2020_NCL = 9;
const MC_BT_2020_CL = 10;
const MC_SMPTE_2085 = 11;
const MC_CHROMAT_NCL = 12;
const MC_CHROMAT_CL = 13;
const MC_ICTCP = 14;

const CSP_UNKNOWN = 0;
const CSP_VERTICAL = 1;
const CSP_COLOCATED = 2;
const CSP_RESERVED = 3;


// 6.7.1. General metadata OBU semantics
const METADATA_TYPE_HDR_CLL = 1;
const METADATA_TYPE_HDR_MDCV = 2;
const METADATA_TYPE_SCALABILITY = 3;
const METADATA_TYPE_ITUT_T35 = 4;
const METADATA_TYPE_TIMECODE = 5;

// 6.8.2. Uncompressed header semantics
const KEY_FRAME = 0;
const INTER_FRAME = 1;
const INTRA_ONLY_FRAME = 2;
const SWITCH_FRAME = 3;

// 6.8.9. Interpolation filter semantics
const EIGHTTAP = 0;
const EIGHTTAP_SMOOTH = 1;
const EIGHTTAP_SHARP = 2;
const BILINEAR = 3;
const SWITCHABLE = 4;

// 6.8.21. TX mode semantics
const ONLY_4X4 = 0;         // 逆变换将只使用4x4变换
const TX_MODE_LARGEST = 1;  // 逆变换将使用适合块内的最大变换大小
const TX_MODE_SELECT = 2;   // 为每个块显式指定转换大小的选择

// 6.10.4. Decode partition semantics
const PARTITION_NONE = 0;
const PARTITION_HORZ = 1;
const PARTITION_VERT = 2;
const PARTITION_SPLIT = 3;
const PARTITION_HORZ_A = 4;
const PARTITION_HORZ_B = 5;
const PARTITION_VERT_A = 6;
const PARTITION_VERT_B = 7;
const PARTITION_HORZ_4 = 8;
const PARTITION_VERT_4 = 9;

const BLOCK_4X4 = 0;
const BLOCK_4X8 = 1;
const BLOCK_8X4 = 2;
const BLOCK_8X8 = 3;
const BLOCK_8X16 = 4;
const BLOCK_16X8 = 5;
const BLOCK_16X16 = 6;
const BLOCK_16X32 = 7;
const BLOCK_32X16 = 8;
const BLOCK_32X32 = 9;
const BLOCK_32X64 = 10;
const BLOCK_64X32 = 11;
const BLOCK_64X64 = 12;
const BLOCK_64X128 = 13;
const BLOCK_128X64 = 14;
const BLOCK_128X128 = 15;
const BLOCK_4X16 = 16;
const BLOCK_16X4 = 17;
const BLOCK_8X32 = 18;
const BLOCK_32X8 = 19;
const BLOCK_16X64 = 20;
const BLOCK_64X16 = 21;

// 6.10.6. Intra frame mode info semantics
const DC_PRED = 0;
const V_PRED = 1;
const H_PRED = 2;
const D45_PRED = 3;
const D135_PRED = 4;
const D113_PRED = 5
const D157_PRED = 6;
const D203_PRED = 7;
const D67_PRED = 8;
const SMOOTH_PRED = 9;
const SMOOTH_V_PRED = 10;
const SMOOTH_H_PRED = 11;
const PAETH_PRED = 12;
const UV_CFL_PRED = 13;

// 6.10.15. Loop restoration params semantics
const RESTORE_NONE = 0;
const RESTORE_SWITCHABLE = 3;
const RESTORE_WIENER = 1;
const RESTORE_SGRPROJ = 2;

// 6.10.16. TX size semantics
const TX_4X4 = 0;
const TX_8X8 = 1;
const TX_16X16 = 2;
const TX_32X32 = 3;
const TX_64X64 = 4;
const TX_4X8 = 5;
const TX_8X4 = 6;
const TX_8X16 = 7;
const TX_16X8 = 8;
const TX_16X32 = 9;
const TX_32X16 = 10;
const TX_32X64 = 11;
const TX_64X32 = 12;
const TX_4X16 = 13;
const TX_16X4 = 14;
const TX_8X32 = 15;
const TX_32X8 = 16;
const TX_16X64 = 17;
const TX_64X16 = 18;

// 6.10.19. Transform type semantics
/** +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |  is_inter | set | Name of transform set |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  | Don’t care|  0  |     TX_SET_DCTONLY    |
 *  |     0     |  1  |     TX_SET_INTRA_1    |
 *  |     0     |  2  |     TX_SET_INTRA_2    |
 *  |     1     |  1  |     TX_SET_INTER_1    |
 *  |     1     |  2  |     TX_SET_INTER_2    |
 *  |     1     |  3  |     TX_SET_INTER_3    |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 */
const TX_SET_DCTONLY = 0;
const TX_SET_INTRA_1 = 1;
const TX_SET_INTRA_2 = 2;
const TX_SET_INTER_1 = 1;
const TX_SET_INTER_2 = 2;
const TX_SET_INTER_3 = 3;

// 6.10.22. Inter block mode info semantics
const NEARESTMV = 14;
const NEARMV = 15;
const GLOBALMV = 16;
const NEWMV = 17;
const NEAREST_NEARESTMV = 18;
const NEAR_NEARMV = 19;
const NEAREST_NEWMV = 20;
const NEW_NEARESTMV = 21;
const NEAR_NEWMV = 22;
const NEW_NEARMV = 23;
const GLOBAL_GLOBALMV = 24;
const NEW_NEWMV = 25;

// 6.10.24. Ref frames semantics
const SINGLE_REFERENCE = 0;
const COMPOUND_REFERENCE = 1;

const UNIDIR_COMP_REFERENCE = 0;  // Both reference frames from the same group
const BIDIR_COMP_REFERENCE = 1;   // One from Group 1 and one from Group 2

const NONE = -1;
const INTRA_FRAME = 0;
const LAST_FRAME = 1;
const LAST2_FRAME = 2;
const LAST3_FRAME = 3;
const GOLDEN_FRAME = 4;
const BWDREF_FRAME = 5;
const ALTREF2_FRAME = 6;
const ALTREF_FRAME = 7;

// 6.10.27. Read inter intra semantics
const II_DC_PRED = 0;
const II_V_PRED = 1;
const II_H_PRED = 2;
const II_SMOOTH_PRED = 3;

// 6.10.28. Read compound type semantics
const COMPOUND_WEDGE = 0;
const COMPOUND_DIFFWTD = 1;
const COMPOUND_AVERAGE = 2;
const COMPOUND_INTRA = 3;
const COMPOUND_DISTANCE = 4;

// 6.10.29. MV semantics
/** +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  | mv_joint | Name of mv_joint | Changes row | Changes col |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |    0     |  MV_JOINT_ZERO   |     No      |     No      |
 *  |    1     |  MV_JOINT_HNZVZ  |     No      |     Yes     |
 *  |    2     |  MV_JOINT_HZVNZ  |     Yes     |     No      |
 *  |    3     |  MV_JOINT_HNZVNZ |     Yes     |     Yes     |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 */
const MV_JOINT_ZERO = 0;
const MV_JOINT_HNZVZ = 1;
const MV_JOINT_HZVNZ = 2;
const MV_JOINT_HNZVNZ = 3;

// 6.10.30. MV component semantics
const MV_CLASS_0 = 0;
const MV_CLASS_1 = 1;
const MV_CLASS_2 = 2;
const MV_CLASS_3 = 3;
const MV_CLASS_4 = 4;
const MV_CLASS_5 = 5;
const MV_CLASS_6 = 6;
const MV_CLASS_7 = 7;
const MV_CLASS_8 = 8;
const MV_CLASS_9 = 9;
const MV_CLASS_10 = 10;

// 6.10.36. Read CFL alphas semantics
const CFL_SIGN_ZERO = 0;
const CFL_SIGN_NEG = 1;
const CFL_SIGN_POS = 2;

// 9.2. Scan tables
const Default_Scan_4x4 = [
  0, 1, 4, 8,
  5, 2, 3, 6,
  9, 12, 13, 10,
  7, 11, 14, 15];
const Mcol_Scan_4x4 = [
  0, 4, 8, 12,
  1, 5, 9, 13,
  2, 6, 10, 14,
  3, 7, 11, 15];
const Mrow_Scan_4x4 = [
  0, 1, 2, 3,
  4, 5, 6, 7,
  8, 9, 10, 11,
  12, 13, 14, 15];
const Default_Scan_4x8 = [
  0, 1, 4, 2, 5, 8, 3, 6, 9, 12, 7, 10, 13, 16, 11, 14,
  17, 20, 15, 18, 21, 24, 19, 22, 25, 28, 23, 26, 29, 27, 30, 31];
const Mcol_Scan_4x8 = [
  0, 4, 8, 12, 16, 20, 24, 28, 1, 5, 9, 13, 17, 21, 25, 29,
  2, 6, 10, 14, 18, 22, 26, 30, 3, 7, 11, 15, 19, 23, 27, 31];
const Mrow_Scan_4x8 = [
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
  16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31];
const Default_Scan_8x4 = [
  0, 8, 1, 16, 9, 2, 24, 17, 10, 3, 25, 18, 11, 4, 26, 19,
  12, 5, 27, 20, 13, 6, 28, 21, 14, 7, 29, 22, 15, 30, 23, 31];
const Mcol_Scan_8x4 = [
  0, 8, 16, 24, 1, 9, 17, 25, 2, 10, 18, 26, 3, 11, 19, 27,
  4, 12, 20, 28, 5, 13, 21, 29, 6, 14, 22, 30, 7, 15, 23, 31];
const Mrow_Scan_8x4 = [
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
  16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31];
const Default_Scan_8x8 = [
  0, 1, 8, 16, 9, 2, 3, 10,
  17, 24, 32, 25, 18, 11, 4, 5,
  12, 19, 26, 33, 40, 48, 41, 34,
  27, 20, 13, 6, 7, 14, 21, 28,
  35, 42, 49, 56, 57, 50, 43, 36,
  29, 22, 15, 23, 30, 37, 44, 51,
  58, 59, 52, 45, 38, 31, 39, 46,
  53, 60, 61, 54, 47, 55, 62, 63];
const Mcol_Scan_8x8 = [
  0, 8, 16, 24, 32, 40, 48, 56,
  1, 9, 17, 25, 33, 41, 49, 57,
  2, 10, 18, 26, 34, 42, 50, 58,
  3, 11, 19, 27, 35, 43, 51, 59,
  4, 12, 20, 28, 36, 44, 52, 60,
  5, 13, 21, 29, 37, 45, 53, 61,
  6, 14, 22, 30, 38, 46, 54, 62,
  7, 15, 23, 31, 39, 47, 55, 63];
const Mrow_Scan_8x8 = [
  0, 1, 2, 3, 4, 5, 6, 7,
  8, 9, 10, 11, 12, 13, 14, 15,
  16, 17, 18, 19, 20, 21, 22, 23,
  24, 25, 26, 27, 28, 29, 30, 31,
  32, 33, 34, 35, 36, 37, 38, 39,
  40, 41, 42, 43, 44, 45, 46, 47,
  48, 49, 50, 51, 52, 53, 54, 55,
  56, 57, 58, 59, 60, 61, 62, 63];
const Default_Scan_8x16 = [
  0, 1, 8, 2, 9, 16, 3, 10, 17, 24, 4, 11, 18, 25, 32,
  5, 12, 19, 26, 33, 40, 6, 13, 20, 27, 34, 41, 48, 7, 14,
  21, 28, 35, 42, 49, 56, 15, 22, 29, 36, 43, 50, 57, 64, 23,
  30, 37, 44, 51, 58, 65, 72, 31, 38, 45, 52, 59, 66, 73, 80,
  39, 46, 53, 60, 67, 74, 81, 88, 47, 54, 61, 68, 75, 82, 89,
  96, 55, 62, 69, 76, 83, 90, 97, 104, 63, 70, 77, 84, 91, 98,
  105, 112, 71, 78, 85, 92, 99, 106, 113, 120, 79, 86, 93, 100, 107,
  114, 121, 87, 94, 101, 108, 115, 122, 95, 102, 109, 116, 123, 103, 110,
  117, 124, 111, 118, 125, 119, 126, 127];
const Mcol_Scan_8x16 = [
  0, 8, 16, 24, 32, 40, 48, 56, 64, 72, 80, 88, 96, 104, 112, 120,
  1, 9, 17, 25, 33, 41, 49, 57, 65, 73, 81, 89, 97, 105, 113, 121,
  2, 10, 18, 26, 34, 42, 50, 58, 66, 74, 82, 90, 98, 106, 114, 122,
  3, 11, 19, 27, 35, 43, 51, 59, 67, 75, 83, 91, 99, 107, 115, 123,
  4, 12, 20, 28, 36, 44, 52, 60, 68, 76, 84, 92, 100, 108, 116, 124,
  5, 13, 21, 29, 37, 45, 53, 61, 69, 77, 85, 93, 101, 109, 117, 125,
  6, 14, 22, 30, 38, 46, 54, 62, 70, 78, 86, 94, 102, 110, 118, 126,
  7, 15, 23, 31, 39, 47, 55, 63, 71, 79, 87, 95, 103, 111, 119, 127];
const Mrow_Scan_8x16 = [
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,
  15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29,
  30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44,
  45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,
  60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74,
  75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89,
  90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104,
  105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,
  120, 121, 122, 123, 124, 125, 126, 127];
const Default_Scan_16x8 = [
  0, 16, 1, 32, 17, 2, 48, 33, 18, 3, 64, 49, 34, 19, 4, 80,
  65, 50, 35, 20, 5, 96, 81, 66, 51, 36, 21, 6, 112, 97, 82, 67,
  52, 37, 22, 7, 113, 98, 83, 68, 53, 38, 23, 8, 114, 99, 84, 69,
  54, 39, 24, 9, 115, 100, 85, 70, 55, 40, 25, 10, 116, 101, 86, 71,
  56, 41, 26, 11, 117, 102, 87, 72, 57, 42, 27, 12, 118, 103, 88, 73,
  58, 43, 28, 13, 119, 104, 89, 74, 59, 44, 29, 14, 120, 105, 90, 75,
  60, 45, 30, 15, 121, 106, 91, 76, 61, 46, 31, 122, 107, 92, 77, 62,
  47, 123, 108, 93, 78, 63, 124, 109, 94, 79, 125, 110, 95, 126, 111, 127];
const Mcol_Scan_16x8 = [
  0, 16, 32, 48, 64, 80, 96, 112, 1, 17, 33, 49, 65, 81, 97, 113,
  2, 18, 34, 50, 66, 82, 98, 114, 3, 19, 35, 51, 67, 83, 99, 115,
  4, 20, 36, 52, 68, 84, 100, 116, 5, 21, 37, 53, 69, 85, 101, 117,
  6, 22, 38, 54, 70, 86, 102, 118, 7, 23, 39, 55, 71, 87, 103, 119,
  8, 24, 40, 56, 72, 88, 104, 120, 9, 25, 41, 57, 73, 89, 105, 121,
  10, 26, 42, 58, 74, 90, 106, 122, 11, 27, 43, 59, 75, 91, 107, 123,
  12, 28, 44, 60, 76, 92, 108, 124, 13, 29, 45, 61, 77, 93, 109, 125,
  14, 30, 46, 62, 78, 94, 110, 126, 15, 31, 47, 63, 79, 95, 111, 127];
const Mrow_Scan_16x8 = [
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,
  15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29,
  30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44,
  45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,
  60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74,
  75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89,
  90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104,
  105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,
  120, 121, 122, 123, 124, 125, 126, 127];
const Default_Scan_16x16 = [
  0, 1, 16, 32, 17, 2, 3, 18, 33, 48, 64, 49, 34, 19, 4, 5,
  20, 35, 50, 65, 80, 96, 81, 66, 51, 36, 21, 6, 7, 22, 37, 52,
  67, 82, 97, 112, 128, 113, 98, 83, 68, 53, 38, 23, 8, 9, 24, 39,
  54, 69, 84, 99, 114, 129, 144, 160, 145, 130, 115, 100, 85, 70, 55, 40,
  25, 10, 11, 26, 41, 56, 71, 86, 101, 116, 131, 146, 161, 176, 192, 177,
  162, 147, 132, 117, 102, 87, 72, 57, 42, 27, 12, 13, 28, 43, 58, 73,
  88, 103, 118, 133, 148, 163, 178, 193, 208, 224, 209, 194, 179, 164, 149, 134,
  119, 104, 89, 74, 59, 44, 29, 14, 15, 30, 45, 60, 75, 90, 105, 120,
  135, 150, 165, 180, 195, 210, 225, 240, 241, 226, 211, 196, 181, 166, 151, 136,
  121, 106, 91, 76, 61, 46, 31, 47, 62, 77, 92, 107, 122, 137, 152, 167,
  182, 197, 212, 227, 242, 243, 228, 213, 198, 183, 168, 153, 138, 123, 108, 93,
  78, 63, 79, 94, 109, 124, 139, 154, 169, 184, 199, 214, 229, 244, 245, 230,
  215, 200, 185, 170, 155, 140, 125, 110, 95, 111, 126, 141, 156, 171, 186, 201,
  216, 231, 246, 247, 232, 217, 202, 187, 172, 157, 142, 127, 143, 158, 173, 188,
  203, 218, 233, 248, 249, 234, 219, 204, 189, 174, 159, 175, 190, 205, 220, 235,
  250, 251, 236, 221, 206, 191, 207, 222, 237, 252, 253, 238, 223, 239, 254, 255];
const Mcol_Scan_16x16 = [
  0, 16, 32, 48, 64, 80, 96, 112, 128, 144, 160, 176, 192, 208, 224, 240,
  1, 17, 33, 49, 65, 81, 97, 113, 129, 145, 161, 177, 193, 209, 225, 241,
  2, 18, 34, 50, 66, 82, 98, 114, 130, 146, 162, 178, 194, 210, 226, 242,
  3, 19, 35, 51, 67, 83, 99, 115, 131, 147, 163, 179, 195, 211, 227, 243,
  4, 20, 36, 52, 68, 84, 100, 116, 132, 148, 164, 180, 196, 212, 228, 244,
  5, 21, 37, 53, 69, 85, 101, 117, 133, 149, 165, 181, 197, 213, 229, 245,
  6, 22, 38, 54, 70, 86, 102, 118, 134, 150, 166, 182, 198, 214, 230, 246,
  7, 23, 39, 55, 71, 87, 103, 119, 135, 151, 167, 183, 199, 215, 231, 247,
  8, 24, 40, 56, 72, 88, 104, 120, 136, 152, 168, 184, 200, 216, 232, 248,
  9, 25, 41, 57, 73, 89, 105, 121, 137, 153, 169, 185, 201, 217, 233, 249,
  10, 26, 42, 58, 74, 90, 106, 122, 138, 154, 170, 186, 202, 218, 234, 250,
  11, 27, 43, 59, 75, 91, 107, 123, 139, 155, 171, 187, 203, 219, 235, 251,
  12, 28, 44, 60, 76, 92, 108, 124, 140, 156, 172, 188, 204, 220, 236, 252,
  13, 29, 45, 61, 77, 93, 109, 125, 141, 157, 173, 189, 205, 221, 237, 253,
  14, 30, 46, 62, 78, 94, 110, 126, 142, 158, 174, 190, 206, 222, 238, 254,
  15, 31, 47, 63, 79, 95, 111, 127, 143, 159, 175, 191, 207, 223, 239, 255];
const Mrow_Scan_16x16 = [
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,
  15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29,
  30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44,
  45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,
  60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74,
  75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89,
  90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104,
  105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,
  120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134,
  135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149,
  150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164,
  165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179,
  180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194,
  195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209,
  210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224,
  225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239,
  240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254,
  255];
const Default_Scan_16x32 = [
  0, 1, 16, 2, 17, 32, 3, 18, 33, 48, 4, 19, 34, 49, 64,
  5, 20, 35, 50, 65, 80, 6, 21, 36, 51, 66, 81, 96, 7, 22,
  37, 52, 67, 82, 97, 112, 8, 23, 38, 53, 68, 83, 98, 113, 128,
  9, 24, 39, 54, 69, 84, 99, 114, 129, 144, 10, 25, 40, 55, 70,
  85, 100, 115, 130, 145, 160, 11, 26, 41, 56, 71, 86, 101, 116, 131,
  146, 161, 176, 12, 27, 42, 57, 72, 87, 102, 117, 132, 147, 162, 177,
  192, 13, 28, 43, 58, 73, 88, 103, 118, 133, 148, 163, 178, 193, 208,
  14, 29, 44, 59, 74, 89, 104, 119, 134, 149, 164, 179, 194, 209, 224,
  15, 30, 45, 60, 75, 90, 105, 120, 135, 150, 165, 180, 195, 210, 225,
  240, 31, 46, 61, 76, 91, 106, 121, 136, 151, 166, 181, 196, 211, 226,
  241, 256, 47, 62, 77, 92, 107, 122, 137, 152, 167, 182, 197, 212, 227,
  242, 257, 272, 63, 78, 93, 108, 123, 138, 153, 168, 183, 198, 213, 228,
  243, 258, 273, 288, 79, 94, 109, 124, 139, 154, 169, 184, 199, 214, 229,
  244, 259, 274, 289, 304, 95, 110, 125, 140, 155, 170, 185, 200, 215, 230,
  245, 260, 275, 290, 305, 320, 111, 126, 141, 156, 171, 186, 201, 216, 231,
  246, 261, 276, 291, 306, 321, 336, 127, 142, 157, 172, 187, 202, 217, 232,
  247, 262, 277, 292, 307, 322, 337, 352, 143, 158, 173, 188, 203, 218, 233,
  248, 263, 278, 293, 308, 323, 338, 353, 368, 159, 174, 189, 204, 219, 234,
  249, 264, 279, 294, 309, 324, 339, 354, 369, 384, 175, 190, 205, 220, 235,
  250, 265, 280, 295, 310, 325, 340, 355, 370, 385, 400, 191, 206, 221, 236,
  251, 266, 281, 296, 311, 326, 341, 356, 371, 386, 401, 416, 207, 222, 237,
  252, 267, 282, 297, 312, 327, 342, 357, 372, 387, 402, 417, 432, 223, 238,
  253, 268, 283, 298, 313, 328, 343, 358, 373, 388, 403, 418, 433, 448, 239,
  254, 269, 284, 299, 314, 329, 344, 359, 374, 389, 404, 419, 434, 449, 464,
  255, 270, 285, 300, 315, 330, 345, 360, 375, 390, 405, 420, 435, 450, 465,
  480, 271, 286, 301, 316, 331, 346, 361, 376, 391, 406, 421, 436, 451, 466,
  481, 496, 287, 302, 317, 332, 347, 362, 377, 392, 407, 422, 437, 452, 467,
  482, 497, 303, 318, 333, 348, 363, 378, 393, 408, 423, 438, 453, 468, 483,
  498, 319, 334, 349, 364, 379, 394, 409, 424, 439, 454, 469, 484, 499, 335,
  350, 365, 380, 395, 410, 425, 440, 455, 470, 485, 500, 351, 366, 381, 396,
  411, 426, 441, 456, 471, 486, 501, 367, 382, 397, 412, 427, 442, 457, 472,
  487, 502, 383, 398, 413, 428, 443, 458, 473, 488, 503, 399, 414, 429, 444,
  459, 474, 489, 504, 415, 430, 445, 460, 475, 490, 505, 431, 446, 461, 476,
  491, 506, 447, 462, 477, 492, 507, 463, 478, 493, 508, 479, 494, 509, 495,
  510, 511];
const Default_Scan_32x16 = [
  0, 32, 1, 64, 33, 2, 96, 65, 34, 3, 128, 97, 66, 35, 4,
  160, 129, 98, 67, 36, 5, 192, 161, 130, 99, 68, 37, 6, 224, 193,
  162, 131, 100, 69, 38, 7, 256, 225, 194, 163, 132, 101, 70, 39, 8,
  288, 257, 226, 195, 164, 133, 102, 71, 40, 9, 320, 289, 258, 227, 196,
  165, 134, 103, 72, 41, 10, 352, 321, 290, 259, 228, 197, 166, 135, 104,
  73, 42, 11, 384, 353, 322, 291, 260, 229, 198, 167, 136, 105, 74, 43,
  12, 416, 385, 354, 323, 292, 261, 230, 199, 168, 137, 106, 75, 44, 13,
  448, 417, 386, 355, 324, 293, 262, 231, 200, 169, 138, 107, 76, 45, 14,
  480, 449, 418, 387, 356, 325, 294, 263, 232, 201, 170, 139, 108, 77, 46,
  15, 481, 450, 419, 388, 357, 326, 295, 264, 233, 202, 171, 140, 109, 78,
  47, 16, 482, 451, 420, 389, 358, 327, 296, 265, 234, 203, 172, 141, 110,
  79, 48, 17, 483, 452, 421, 390, 359, 328, 297, 266, 235, 204, 173, 142,
  111, 80, 49, 18, 484, 453, 422, 391, 360, 329, 298, 267, 236, 205, 174,
  143, 112, 81, 50, 19, 485, 454, 423, 392, 361, 330, 299, 268, 237, 206,
  175, 144, 113, 82, 51, 20, 486, 455, 424, 393, 362, 331, 300, 269, 238,
  207, 176, 145, 114, 83, 52, 21, 487, 456, 425, 394, 363, 332, 301, 270,
  239, 208, 177, 146, 115, 84, 53, 22, 488, 457, 426, 395, 364, 333, 302,
  271, 240, 209, 178, 147, 116, 85, 54, 23, 489, 458, 427, 396, 365, 334,
  303, 272, 241, 210, 179, 148, 117, 86, 55, 24, 490, 459, 428, 397, 366,
  335, 304, 273, 242, 211, 180, 149, 118, 87, 56, 25, 491, 460, 429, 398,
  367, 336, 305, 274, 243, 212, 181, 150, 119, 88, 57, 26, 492, 461, 430,
  399, 368, 337, 306, 275, 244, 213, 182, 151, 120, 89, 58, 27, 493, 462,
  431, 400, 369, 338, 307, 276, 245, 214, 183, 152, 121, 90, 59, 28, 494,
  463, 432, 401, 370, 339, 308, 277, 246, 215, 184, 153, 122, 91, 60, 29,
  495, 464, 433, 402, 371, 340, 309, 278, 247, 216, 185, 154, 123, 92, 61,
  30, 496, 465, 434, 403, 372, 341, 310, 279, 248, 217, 186, 155, 124, 93,
  62, 31, 497, 466, 435, 404, 373, 342, 311, 280, 249, 218, 187, 156, 125,
  94, 63, 498, 467, 436, 405, 374, 343, 312, 281, 250, 219, 188, 157, 126,
  95, 499, 468, 437, 406, 375, 344, 313, 282, 251, 220, 189, 158, 127, 500,
  469, 438, 407, 376, 345, 314, 283, 252, 221, 190, 159, 501, 470, 439, 408,
  377, 346, 315, 284, 253, 222, 191, 502, 471, 440, 409, 378, 347, 316, 285,
  254, 223, 503, 472, 441, 410, 379, 348, 317, 286, 255, 504, 473, 442, 411,
  380, 349, 318, 287, 505, 474, 443, 412, 381, 350, 319, 506, 475, 444, 413,
  382, 351, 507, 476, 445, 414, 383, 508, 477, 446, 415, 509, 478, 447, 510,
  479, 511];
const Default_Scan_32x32 = [
  0, 1, 32, 64, 33, 2, 3, 34, 65, 96, 128, 97, 66,
  35, 4, 5, 36, 67, 98, 129, 160, 192, 161, 130, 99, 68,
  37, 6, 7, 38, 69, 100, 131, 162, 193, 224, 256, 225, 194,
  163, 132, 101, 70, 39, 8, 9, 40, 71, 102, 133, 164, 195,
  226, 257, 288, 320, 289, 258, 227, 196, 165, 134, 103, 72, 41,
  10, 11, 42, 73, 104, 135, 166, 197, 228, 259, 290, 321, 352,
  384, 353, 322, 291, 260, 229, 198, 167, 136, 105, 74, 43, 12,
  13, 44, 75, 106, 137, 168, 199, 230, 261, 292, 323, 354, 385,
  416, 448, 417, 386, 355, 324, 293, 262, 231, 200, 169, 138, 107,
  76, 45, 14, 15, 46, 77, 108, 139, 170, 201, 232, 263, 294,
  325, 356, 387, 418, 449, 480, 512, 481, 450, 419, 388, 357, 326,
  295, 264, 233, 202, 171, 140, 109, 78, 47, 16, 17, 48, 79,
  110, 141, 172, 203, 234, 265, 296, 327, 358, 389, 420, 451, 482,
  513, 544, 576, 545, 514, 483, 452, 421, 390, 359, 328, 297, 266,
  235, 204, 173, 142, 111, 80, 49, 18, 19, 50, 81, 112, 143,
  174, 205, 236, 267, 298, 329, 360, 391, 422, 453, 484, 515, 546,
  577, 608, 640, 609, 578, 547, 516, 485, 454, 423, 392, 361, 330,
  299, 268, 237, 206, 175, 144, 113, 82, 51, 20, 21, 52, 83,
  114, 145, 176, 207, 238, 269, 300, 331, 362, 393, 424, 455, 486,
  517, 548, 579, 610, 641, 672, 704, 673, 642, 611, 580, 549, 518,
  487, 456, 425, 394, 363, 332, 301, 270, 239, 208, 177, 146, 115,
  84, 53, 22, 23, 54, 85, 116, 147, 178, 209, 240, 271, 302,
  333, 364, 395, 426, 457, 488, 519, 550, 581, 612, 643, 674, 705,
  736, 768, 737, 706, 675, 644, 613, 582, 551, 520, 489, 458, 427,
  396, 365, 334, 303, 272, 241, 210, 179, 148, 117, 86, 55, 24,
  25, 56, 87, 118, 149, 180, 211, 242, 273, 304, 335, 366, 397,
  428, 459, 490, 521, 552, 583, 614, 645, 676, 707, 738, 769, 800,
  832, 801, 770, 739, 708, 677, 646, 615, 584, 553, 522, 491, 460,
  429, 398, 367, 336, 305, 274, 243, 212, 181, 150, 119, 88, 57,
  26, 27, 58, 89, 120, 151, 182, 213, 244, 275, 306, 337, 368,
  399, 430, 461, 492, 523, 554, 585, 616, 647, 678, 709, 740, 771,
  802, 833, 864, 896, 865, 834, 803, 772, 741, 710, 679, 648, 617,
  586, 555, 524, 493, 462, 431, 400, 369, 338, 307, 276, 245, 214,
  183, 152, 121, 90, 59, 28, 29, 60, 91, 122, 153, 184, 215,
  246, 277, 308, 339, 370, 401, 432, 463, 494, 525, 556, 587, 618,
  649, 680, 711, 742, 773, 804, 835, 866, 897, 928, 960, 929, 898,
  867, 836, 805, 774, 743, 712, 681, 650, 619, 588, 557, 526, 495,
  464, 433, 402, 371, 340, 309, 278, 247, 216, 185, 154, 123, 92,
  61, 30, 31, 62, 93, 124, 155, 186, 217, 248, 279, 310, 341,
  372, 403, 434, 465, 496, 527, 558, 589, 620, 651, 682, 713, 744,
  775, 806, 837, 868, 899, 930, 961, 992, 993, 962, 931, 900, 869,
  838, 807, 776, 745, 714, 683, 652, 621, 590, 559, 528, 497, 466,
  435, 404, 373, 342, 311, 280, 249, 218, 187, 156, 125, 94, 63,
  95, 126, 157, 188, 219, 250, 281, 312, 343, 374, 405, 436, 467,
  498, 529, 560, 591, 622, 653, 684, 715, 746, 777, 808, 839, 870,
  901, 932, 963, 994, 995, 964, 933, 902, 871, 840, 809, 778, 747,
  716, 685, 654, 623, 592, 561, 530, 499, 468, 437, 406, 375, 344,
  313, 282, 251, 220, 189, 158, 127, 159, 190, 221, 252, 283, 314,
  345, 376, 407, 438, 469, 500, 531, 562, 593, 624, 655, 686, 717,
  748, 779, 810, 841, 872, 903, 934, 965, 996, 997, 966, 935, 904,
  873, 842, 811, 780, 749, 718, 687, 656, 625, 594, 563, 532, 501,
  470, 439, 408, 377, 346, 315, 284, 253, 222, 191, 223, 254, 285,
  316, 347, 378, 409, 440, 471, 502, 533, 564, 595, 626, 657, 688,
  719, 750, 781, 812, 843, 874, 905, 936, 967, 998, 999, 968, 937,
  906, 875, 844, 813, 782, 751, 720, 689, 658, 627, 596, 565, 534,
  503, 472, 441, 410, 379, 348, 317, 286, 255, 287, 318, 349, 380,
  411, 442, 473, 504, 535, 566, 597, 628, 659, 690, 721, 752, 783,
  814, 845, 876, 907, 938, 969, 1000, 1001, 970, 939, 908, 877, 846,
  815, 784, 753, 722, 691, 660, 629, 598, 567, 536, 505, 474, 443,
  412, 381, 350, 319, 351, 382, 413, 444, 475, 506, 537, 568, 599,
  630, 661, 692, 723, 754, 785, 816, 847, 878, 909, 940, 971, 1002,
  1003, 972, 941, 910, 879, 848, 817, 786, 755, 724, 693, 662, 631,
  600, 569, 538, 507, 476, 445, 414, 383, 415, 446, 477, 508, 539,
  570, 601, 632, 663, 694, 725, 756, 787, 818, 849, 880, 911, 942,
  973, 1004, 1005, 974, 943, 912, 881, 850, 819, 788, 757, 726, 695,
  664, 633, 602, 571, 540, 509, 478, 447, 479, 510, 541, 572, 603,
  634, 665, 696, 727, 758, 789, 820, 851, 882, 913, 944, 975, 1006,
  1007, 976, 945, 914, 883, 852, 821, 790, 759, 728, 697, 666, 635,
  604, 573, 542, 511, 543, 574, 605, 636, 667, 698, 729, 760, 791,
  822, 853, 884, 915, 946, 977, 1008, 1009, 978, 947, 916, 885, 854,
  823, 792, 761, 730, 699, 668, 637, 606, 575, 607, 638, 669, 700,
  731, 762, 793, 824, 855, 886, 917, 948, 979, 1010, 1011, 980, 949,
  918, 887, 856, 825, 794, 763, 732, 701, 670, 639, 671, 702, 733,
  764, 795, 826, 857, 888, 919, 950, 981, 1012, 1013, 982, 951, 920,
  889, 858, 827, 796, 765, 734, 703, 735, 766, 797, 828, 859, 890,
  921, 952, 983, 1014, 1015, 984, 953, 922, 891, 860, 829, 798, 767,
  799, 830, 861, 892, 923, 954, 985, 1016, 1017, 986, 955, 924, 893,
  862, 831, 863, 894, 925, 956, 987, 1018, 1019, 988, 957, 926, 895,
  927, 958, 989, 1020, 1021, 990, 959, 991, 1022, 1023];
const Default_Scan_4x16 = [
  0, 1, 4, 2, 5, 8, 3, 6, 9, 12, 7, 10, 13, 16, 11, 14,
  17, 20, 15, 18, 21, 24, 19, 22, 25, 28, 23, 26, 29, 32, 27, 30,
  33, 36, 31, 34, 37, 40, 35, 38, 41, 44, 39, 42, 45, 48, 43, 46,
  49, 52, 47, 50, 53, 56, 51, 54, 57, 60, 55, 58, 61, 59, 62, 63];
const Mcol_Scan_4x16 = [
  0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60,
  1, 5, 9, 13, 17, 21, 25, 29, 33, 37, 41, 45, 49, 53, 57, 61,
  2, 6, 10, 14, 18, 22, 26, 30, 34, 38, 42, 46, 50, 54, 58, 62,
  3, 7, 11, 15, 19, 23, 27, 31, 35, 39, 43, 47, 51, 55, 59, 63];
const Mrow_Scan_4x16 = [
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
  16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
  32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
  48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63];
const Default_Scan_16x4 = [
  0, 16, 1, 32, 17, 2, 48, 33, 18, 3, 49, 34, 19, 4, 50, 35,
  20, 5, 51, 36, 21, 6, 52, 37, 22, 7, 53, 38, 23, 8, 54, 39,
  24, 9, 55, 40, 25, 10, 56, 41, 26, 11, 57, 42, 27, 12, 58, 43,
  28, 13, 59, 44, 29, 14, 60, 45, 30, 15, 61, 46, 31, 62, 47, 63];
const Mcol_Scan_16x4 = [
  0, 16, 32, 48, 1, 17, 33, 49, 2, 18, 34, 50, 3, 19, 35, 51,
  4, 20, 36, 52, 5, 21, 37, 53, 6, 22, 38, 54, 7, 23, 39, 55,
  8, 24, 40, 56, 9, 25, 41, 57, 10, 26, 42, 58, 11, 27, 43, 59,
  12, 28, 44, 60, 13, 29, 45, 61, 14, 30, 46, 62, 15, 31, 47, 63];
const Mrow_Scan_16x4 = [
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
  16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
  32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
  48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63];
const Default_Scan_8x32 = [
  0, 1, 8, 2, 9, 16, 3, 10, 17, 24, 4, 11, 18, 25, 32,
  5, 12, 19, 26, 33, 40, 6, 13, 20, 27, 34, 41, 48, 7, 14,
  21, 28, 35, 42, 49, 56, 15, 22, 29, 36, 43, 50, 57, 64, 23,
  30, 37, 44, 51, 58, 65, 72, 31, 38, 45, 52, 59, 66, 73, 80,
  39, 46, 53, 60, 67, 74, 81, 88, 47, 54, 61, 68, 75, 82, 89,
  96, 55, 62, 69, 76, 83, 90, 97, 104, 63, 70, 77, 84, 91, 98,
  105, 112, 71, 78, 85, 92, 99, 106, 113, 120, 79, 86, 93, 100, 107,
  114, 121, 128, 87, 94, 101, 108, 115, 122, 129, 136, 95, 102, 109, 116,
  123, 130, 137, 144, 103, 110, 117, 124, 131, 138, 145, 152, 111, 118, 125,
  132, 139, 146, 153, 160, 119, 126, 133, 140, 147, 154, 161, 168, 127, 134,
  141, 148, 155, 162, 169, 176, 135, 142, 149, 156, 163, 170, 177, 184, 143,
  150, 157, 164, 171, 178, 185, 192, 151, 158, 165, 172, 179, 186, 193, 200,
  159, 166, 173, 180, 187, 194, 201, 208, 167, 174, 181, 188, 195, 202, 209,
  216, 175, 182, 189, 196, 203, 210, 217, 224, 183, 190, 197, 204, 211, 218,
  225, 232, 191, 198, 205, 212, 219, 226, 233, 240, 199, 206, 213, 220, 227,
  234, 241, 248, 207, 214, 221, 228, 235, 242, 249, 215, 222, 229, 236, 243,
  250, 223, 230, 237, 244, 251, 231, 238, 245, 252, 239, 246, 253, 247, 254,
  255];
const Default_Scan_32x8 = [
  0, 32, 1, 64, 33, 2, 96, 65, 34, 3, 128, 97, 66, 35, 4,
  160, 129, 98, 67, 36, 5, 192, 161, 130, 99, 68, 37, 6, 224, 193,
  162, 131, 100, 69, 38, 7, 225, 194, 163, 132, 101, 70, 39, 8, 226,
  195, 164, 133, 102, 71, 40, 9, 227, 196, 165, 134, 103, 72, 41, 10,
  228, 197, 166, 135, 104, 73, 42, 11, 229, 198, 167, 136, 105, 74, 43,
  12, 230, 199, 168, 137, 106, 75, 44, 13, 231, 200, 169, 138, 107, 76,
  45, 14, 232, 201, 170, 139, 108, 77, 46, 15, 233, 202, 171, 140, 109,
  78, 47, 16, 234, 203, 172, 141, 110, 79, 48, 17, 235, 204, 173, 142,
  111, 80, 49, 18, 236, 205, 174, 143, 112, 81, 50, 19, 237, 206, 175,
  144, 113, 82, 51, 20, 238, 207, 176, 145, 114, 83, 52, 21, 239, 208,
  177, 146, 115, 84, 53, 22, 240, 209, 178, 147, 116, 85, 54, 23, 241,
  210, 179, 148, 117, 86, 55, 24, 242, 211, 180, 149, 118, 87, 56, 25,
  243, 212, 181, 150, 119, 88, 57, 26, 244, 213, 182, 151, 120, 89, 58,
  27, 245, 214, 183, 152, 121, 90, 59, 28, 246, 215, 184, 153, 122, 91,
  60, 29, 247, 216, 185, 154, 123, 92, 61, 30, 248, 217, 186, 155, 124,
  93, 62, 31, 249, 218, 187, 156, 125, 94, 63, 250, 219, 188, 157, 126,
  95, 251, 220, 189, 158, 127, 252, 221, 190, 159, 253, 222, 191, 254, 223,
  255];


// 9.3. Conversion tables
const Mi_Width_Log2 = [
  0, 0, 1, 1, 1, 2, 2, 2, 3, 3, 3,
  4, 4, 4, 5, 5, 0, 2, 1, 3, 2, 4];
const Mi_Height_Log2 = [
  0, 1, 0, 1, 2, 1, 2, 3, 2, 3, 4,
  3, 4, 5, 4, 5, 2, 0, 3, 1, 4, 2];
const Num_4x4_Blocks_Wide = [
  1, 1, 2, 2, 2, 4, 4, 4, 8, 8, 8,
  16, 16, 16, 32, 32, 1, 4, 2, 8, 4, 16];
const Num_4x4_Blocks_High = [
  1, 2, 1, 2, 4, 2, 4, 8, 4, 8, 16,
  8, 16, 32, 16, 32, 4, 1, 8, 2, 16, 4];
const Block_Width = Num_4x4_Blocks_Wide.map((n) => 4 * n);
const Block_Height = Num_4x4_Blocks_High.map((n) => 4 * n);
const Size_Group = [
  0, 0, 0, 1, 1, 1, 2, 2, 2, 3, 3,
  3, 3, 3, 3, 3, 0, 0, 1, 1, 2, 2];
const Max_Tx_Size_Rect = [
  TX_4X4, TX_4X8, TX_8X4, TX_8X8,
  TX_8X16, TX_16X8, TX_16X16, TX_16X32,
  TX_32X16, TX_32X32, TX_32X64, TX_64X32,
  TX_64X64, TX_64X64, TX_64X64, TX_64X64,
  TX_4X16, TX_16X4, TX_8X32, TX_32X8,
  TX_16X64, TX_64X16];
const Partition_Subsize = [
  [
    BLOCK_4X4,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_8X8,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_16X16,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_32X32,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_64X64,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_128X128,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_INVALID,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_INVALID
  ], [
    BLOCK_INVALID,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_8X4,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_16X8,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_32X16,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_64X32,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_128X64,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_INVALID,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_INVALID
  ], [
    BLOCK_INVALID,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_4X8,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_8X16,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_16X32,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_32X64,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_64X128,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_INVALID,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_INVALID
  ], [
    BLOCK_INVALID,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_4X4,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_8X8,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_16X16,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_32X32,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_64X64,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_INVALID,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_INVALID
  ], [
    BLOCK_INVALID,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_8X4,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_16X8,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_32X16,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_64X32,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_128X64,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_INVALID,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_INVALID
  ], [
    BLOCK_INVALID,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_8X4,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_16X8,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_32X16,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_64X32,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_128X64,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_INVALID,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_INVALID
  ], [
    BLOCK_INVALID,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_4X8,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_8X16,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_16X32,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_32X64,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_64X128,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_INVALID,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_INVALID
  ], [
    BLOCK_INVALID,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_4X8,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_8X16,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_16X32,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_32X64,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_64X128,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_INVALID,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_INVALID
  ], [
    BLOCK_INVALID,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_INVALID,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_16X4,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_32X8,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_64X16,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_INVALID,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_INVALID,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_INVALID
  ], [
    BLOCK_INVALID,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_INVALID,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_4X16,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_8X32,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_16X64,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_INVALID,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_INVALID,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_INVALID
  ]
];
const Split_Tx_Size = [
  TX_4X4,
  TX_4X4,
  TX_8X8,
  TX_16X16,
  TX_32X32,
  TX_4X4,
  TX_4X4,
  TX_8X8,
  TX_8X8,
  TX_16X16,
  TX_16X16,
  TX_32X32,
  TX_32X32,
  TX_8X4,
  TX_8X16,
  TX_16X8,
  TX_16X32,
  TX_32X16
];
const Mode_To_Txfm = [
  DCT_DCT, // DC_PRED
  ADST_DCT, // V_PRED
  DCT_ADST, // H_PRED
  DCT_DCT, // D45_PRED
  ADST_ADST, // D135_PRED
  ADST_DCT, // D113_PRED
  DCT_ADST, // D157_PRED
  DCT_ADST, // D203_PRED
  ADST_DCT, // D67_PRED
  ADST_ADST, // SMOOTH_PRED
  ADST_DCT, // SMOOTH_V_PRED
  DCT_ADST, // SMOOTH_H_PRED
  ADST_ADST, // PAETH_PRED
  DCT_DCT, // UV_CFL_PRED
];
const Palette_Color_Context =
  [-1, -1, 0, -1, -1, 4, 3, 2, 1];
const Palette_Color_Hash_Multipliers = [1, 2, 2];
const Sm_Weights_Tx_4x4 = [255, 149, 85, 64];
const Sm_Weights_Tx_8x8 = [255, 197, 146, 105, 73, 50, 37, 32];
const Sm_Weights_Tx_16x16 = [255, 225, 196, 170, 145, 123, 102, 84, 68, 54, 43, 33, 26, 20, 17, 16];
const Sm_Weights_Tx_32x32 = [255, 240, 225, 210, 196, 182, 169, 157, 145, 133, 122, 111, 101, 92, 83, 74, 66, 59, 52, 45, 39, 34, 29, 25, 21, 17, 14, 12, 10, 9, 8, 8];
const Sm_Weights_Tx_64x64 = [255, 248, 240, 233, 225, 218, 210, 203, 196, 189, 182, 176, 169, 163, 156,
  150, 144, 138, 133, 127, 121, 116, 111, 106, 101, 96, 91, 86, 82, 77, 73, 69,
  65, 61, 57, 54, 50, 47, 44, 41, 38, 35, 32, 29, 27, 25, 22, 20, 18, 16, 15,
  13, 12, 10, 9, 8, 7, 6, 6, 5, 5, 4, 4, 4];
const Mode_To_Angle = [0, 90, 180, 45, 135, 113, 157, 203, 67, 0, 0, 0, 0];
const Dr_Intra_Derivative = [
  0, 0, 0, 1023, 0, 0, 547, 0, 0, 372, 0, 0, 0, 0,
  273, 0, 0, 215, 0, 0, 178, 0, 0, 151, 0, 0, 132, 0, 0,
  116, 0, 0, 102, 0, 0, 0, 90, 0, 0, 80, 0, 0, 71, 0, 0,
  64, 0, 0, 57, 0, 0, 51, 0, 0, 45, 0, 0, 0, 40, 0, 0,
  35, 0, 0, 31, 0, 0, 27, 0, 0, 23, 0, 0, 19, 0, 0,
  15, 0, 0, 0, 0, 11, 0, 0, 7, 0, 0, 3, 0, 0];
const Intra_Filter_Taps = [
  [
    [-6, 10, 0, 0, 0, 12, 0],
    [-5, 2, 10, 0, 0, 9, 0],
    [-3, 1, 1, 10, 0, 7, 0],
    [-3, 1, 1, 2, 10, 5, 0],
    [-4, 6, 0, 0, 0, 2, 12],
    [-3, 2, 6, 0, 0, 2, 9],
    [-3, 2, 2, 6, 0, 2, 7],
    [-3, 1, 2, 2, 6, 3, 5],
  ],
  [
    [-10, 16, 0, 0, 0, 10, 0],
    [-6, 0, 16, 0, 0, 6, 0],
    [-4, 0, 0, 16, 0, 4, 0],
    [-2, 0, 0, 0, 16, 2, 0],
    [-10, 16, 0, 0, 0, 0, 10],
    [-6, 0, 16, 0, 0, 0, 6],
    [-4, 0, 0, 16, 0, 0, 4],
    [-2, 0, 0, 0, 16, 0, 2],
  ],
  [
    [-8, 8, 0, 0, 0, 16, 0],
    [-8, 0, 8, 0, 0, 16, 0],
    [-8, 0, 0, 8, 0, 16, 0],
    [-8, 0, 0, 0, 8, 16, 0],
    [-4, 4, 0, 0, 0, 0, 16],
    [-4, 0, 4, 0, 0, 0, 16],
    [-4, 0, 0, 4, 0, 0, 16],
    [-4, 0, 0, 0, 4, 0, 16],
  ],
  [
    [-2, 8, 0, 0, 0, 10, 0],
    [-1, 3, 8, 0, 0, 6, 0],
    [-1, 2, 3, 8, 0, 4, 0],
    [0, 1, 2, 3, 8, 2, 0],
    [-1, 4, 0, 0, 0, 3, 10],
    [-1, 3, 4, 0, 0, 4, 6],
    [-1, 2, 3, 4, 0, 4, 4],
    [-1, 2, 2, 3, 4, 3, 3],
  ],
  [
    [-12, 14, 0, 0, 0, 14, 0],
    [-10, 0, 14, 0, 0, 12, 0],
    [-9, 0, 0, 14, 0, 11, 0],
    [-8, 0, 0, 0, 14, 10, 0],
    [-10, 12, 0, 0, 0, 0, 14],
    [-9, 1, 12, 0, 0, 0, 12],
    [-8, 0, 0, 12, 0, 1, 11],
    [-7, 0, 0, 1, 12, 1, 9],
  ]
];
const Tx_Size_Sqr = [
  TX_4X4,
  TX_8X8,
  TX_16X16,
  TX_32X32,
  TX_64X64,
  TX_4X4,
  TX_4X4,
  TX_8X8,
  TX_8X8,
  TX_16X16,
  TX_16X16,
  TX_32X32,
  TX_32X32,
  TX_4X4,
  TX_4X4,
  TX_8X8,
  TX_8X8,
  TX_16X16,
  TX_16X16
];
const Tx_Size_Sqr_Up = [
  TX_4X4,
  TX_8X8,
  TX_16X16,
  TX_32X32,
  TX_64X64,
  TX_8X8,
  TX_8X8,
  TX_16X16,
  TX_16X16,
  TX_32X32,
  TX_32X32,
  TX_64X64,
  TX_64X64,
  TX_16X16,
  TX_16X16,
  TX_32X32,
  TX_32X32,
  TX_64X64,
  TX_64X64
];
const Tx_Width = [
  4, 8, 16, 32, 64, 4, 8, 8, 16, 16, 32, 32, 64, 4, 16, 8, 32, 16, 64];
const Tx_Height = [
  4, 8, 16, 32, 64, 8, 4, 16, 8, 32, 16, 64, 32, 16, 4, 32, 8, 64, 16];
const Tx_Width_Log2 = [
  2, 3, 4, 5, 6, 2, 3, 3, 4, 4, 5, 5, 6, 2, 4, 3, 5, 4, 6];
const Tx_Height_Log2 = [
  2, 3, 4, 5, 6, 3, 2, 4, 3, 5, 4, 6, 5, 4, 2, 5, 3, 6, 4];
const Wedge_Bits = [
  0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 0,
  0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0];
const Sig_Ref_Diff_Offset = [
  [
    [0, 1], [1, 0], [1, 1], [0, 2], [2, 0]
  ],
  [
    [0, 1], [1, 0], [0, 2], [0, 3], [0, 4]
  ],
  [
    [0, 1], [1, 0], [2, 0], [3, 0], [4, 0]
  ]
];
const Adjusted_Tx_Size = [
  TX_4X4,
  TX_8X8,
  TX_16X16,
  TX_32X32,
  TX_32X32,
  TX_4X8,
  TX_8X4,
  TX_8X16,
  TX_16X8,
  TX_16X32,
  TX_32X16,
  TX_32X32,
  TX_32X32,
  TX_4X16,
  TX_16X4,
  TX_8X32,
  TX_32X8,
  TX_16X32,
  TX_32X16
];
const Gaussian_Sequence = [
  56, 568, -180, 172, 124, -84, 172, -64, -900, 24, 820,
  224, 1248, 996, 272, -8, -916, -388, -732, -104, -188, 800,
  112, -652, -320, -376, 140, -252, 492, -168, 44, -788, 588,
  -584, 500, -228, 12, 680, 272, -476, 972, -100, 652, 368,
  432, -196, -720, -192, 1000, -332, 652, -136, -552, -604, -4,
  192, -220, -136, 1000, -52, 372, -96, -624, 124, -24, 396,
  540, -12, -104, 640, 464, 244, -208, -84, 368, -528, -740,
  248, -968, -848, 608, 376, -60, -292, -40, -156, 252, -292,
  248, 224, -280, 400, -244, 244, -60, 76, -80, 212, 532,
  340, 128, -36, 824, -352, -60, -264, -96, -612, 416, -704,
  220, -204, 640, -160, 1220, -408, 900, 336, 20, -336, -96,
  -792, 304, 48, -28, -1232, -1172, -448, 104, -292, -520, 244,
  60, -948, 0, -708, 268, 108, 356, -548, 488, -344, -136,
  488, -196, -224, 656, -236, -1128, 60, 4, 140, 276, -676,
  -376, 168, -108, 464, 8, 564, 64, 240, 308, -300, -400,
  -456, -136, 56, 120, -408, -116, 436, 504, -232, 328, 844,
  -164, -84, 784, -168, 232, -224, 348, -376, 128, 568, 96,
  -1244, -288, 276, 848, 832, -360, 656, 464, -384, -332, -356,
  728, -388, 160, -192, 468, 296, 224, 140, -776, -100, 280,
  4, 196, 44, -36, -648, 932, 16, 1428, 28, 528, 808,
  772, 20, 268, 88, -332, -284, 124, -384, -448, 208, -228,
  -1044, -328, 660, 380, -148, -300, 588, 240, 540, 28, 136,
  -88, -436, 256, 296, -1000, 1400, 0, -48, 1056, -136, 264,
  -528, -1108, 632, -484, -592, -344, 796, 124, -668, -768, 388,
  1296, -232, -188, -200, -288, -4, 308, 100, -168, 256, -500,
  204, -508, 648, -136, 372, -272, -120, -1004, -552, -548, -384,
  548, -296, 428, -108, -8, -912, -324, -224, -88, -112, -220,
  -100, 996, -796, 548, 360, -216, 180, 428, -200, -212, 148,
  96, 148, 284, 216, -412, -320, 120, -300, -384, -604, -572,
  -332, -8, -180, -176, 696, 116, -88, 628, 76, 44, -516,
  240, -208, -40, 100, -592, 344, -308, -452, -228, 20, 916,
  -1752, -136, -340, -804, 140, 40, 512, 340, 248, 184, -492,
  896, -156, 932, -628, 328, -688, -448, -616, -752, -100, 560,
  -1020, 180, -800, -64, 76, 576, 1068, 396, 660, 552, -108,
  -28, 320, -628, 312, -92, -92, -472, 268, 16, 560, 516,
  -672, -52, 492, -100, 260, 384, 284, 292, 304, -148, 88,
  -152, 1012, 1064, -228, 164, -376, -684, 592, -392, 156, 196,
  -524, -64, -884, 160, -176, 636, 648, 404, -396, -436, 864,
  424, -728, 988, -604, 904, -592, 296, -224, 536, -176, -920,
  436, -48, 1176, -884, 416, -776, -824, -884, 524, -548, -564,
  -68, -164, -96, 692, 364, -692, -1012, -68, 260, -480, 876,
  -1116, 452, -332, -352, 892, -1088, 1220, -676, 12, -292, 244,
  496, 372, -32, 280, 200, 112, -440, -96, 24, -644, -184,
  56, -432, 224, -980, 272, -260, 144, -436, 420, 356, 364,
  -528, 76, 172, -744, -368, 404, -752, -416, 684, -688, 72,
  540, 416, 92, 444, 480, -72, -1416, 164, -1172, -68, 24,
  424, 264, 1040, 128, -912, -524, -356, 64, 876, -12, 4,
  -88, 532, 272, -524, 320, 276, -508, 940, 24, -400, -120,
  756, 60, 236, -412, 100, 376, -484, 400, -100, -740, -108,
  -260, 328, -268, 224, -200, -416, 184, -604, -564, -20, 296,
  60, 892, -888, 60, 164, 68, -760, 216, -296, 904, -336,
  -28, 404, -356, -568, -208, -1480, -512, 296, 328, -360, -164,
  -1560, -776, 1156, -428, 164, -504, -112, 120, -216, -148, -264,
  308, 32, 64, -72, 72, 116, 176, -64, -272, 460, -536,
  -784, -280, 348, 108, -752, -132, 524, -540, -776, 116, -296,
  -1196, -288, -560, 1040, -472, 116, -848, -1116, 116, 636, 696,
  284, -176, 1016, 204, -864, -648, -248, 356, 972, -584, -204,
  264, 880, 528, -24, -184, 116, 448, -144, 828, 524, 212,
  -212, 52, 12, 200, 268, -488, -404, -880, 824, -672, -40,
  908, -248, 500, 716, -576, 492, -576, 16, 720, -108, 384,
  124, 344, 280, 576, -500, 252, 104, -308, 196, -188, -8,
  1268, 296, 1032, -1196, 436, 316, 372, -432, -200, -660, 704,
  -224, 596, -132, 268, 32, -452, 884, 104, -1008, 424, -1348,
  -280, 4, -1168, 368, 476, 696, 300, -8, 24, 180, -592,
  -196, 388, 304, 500, 724, -160, 244, -84, 272, -256, -420,
  320, 208, -144, -156, 156, 364, 452, 28, 540, 316, 220,
  -644, -248, 464, 72, 360, 32, -388, 496, -680, -48, 208,
  -116, -408, 60, -604, -392, 548, -840, 784, -460, 656, -544,
  -388, -264, 908, -800, -628, -612, -568, 572, -220, 164, 288,
  -16, -308, 308, -112, -636, -760, 280, -668, 432, 364, 240,
  -196, 604, 340, 384, 196, 592, -44, -500, 432, -580, -132,
  636, -76, 392, 4, -412, 540, 508, 328, -356, -36, 16,
  -220, -64, -248, -60, 24, -192, 368, 1040, 92, -24, -1044,
  -32, 40, 104, 148, 192, -136, -520, 56, -816, -224, 732,
  392, 356, 212, -80, -424, -1008, -324, 588, -1496, 576, 460,
  -816, -848, 56, -580, -92, -1372, -112, -496, 200, 364, 52,
  -140, 48, -48, -60, 84, 72, 40, 132, -356, -268, -104,
  -284, -404, 732, -520, 164, -304, -540, 120, 328, -76, -460,
  756, 388, 588, 236, -436, -72, -176, -404, -316, -148, 716,
  -604, 404, -72, -88, -888, -68, 944, 88, -220, -344, 960,
  472, 460, -232, 704, 120, 832, -228, 692, -508, 132, -476,
  844, -748, -364, -44, 1116, -1104, -1056, 76, 428, 552, -692,
  60, 356, 96, -384, -188, -612, -576, 736, 508, 892, 352,
  -1132, 504, -24, -352, 324, 332, -600, -312, 292, 508, -144,
  -8, 484, 48, 284, -260, -240, 256, -100, -292, -204, -44,
  472, -204, 908, -188, -1000, -256, 92, 1164, -392, 564, 356,
  652, -28, -884, 256, 484, -192, 760, -176, 376, -524, -452,
  -436, 860, -736, 212, 124, 504, -476, 468, 76, -472, 552,
  -692, -944, -620, 740, -240, 400, 132, 20, 192, -196, 264,
  -668, -1012, -60, 296, -316, -828, 76, -156, 284, -768, -448,
  -832, 148, 248, 652, 616, 1236, 288, -328, -400, -124, 588,
  220, 520, -696, 1032, 768, -740, -92, -272, 296, 448, -464,
  412, -200, 392, 440, -200, 264, -152, -260, 320, 1032, 216,
  320, -8, -64, 156, -1016, 1084, 1172, 536, 484, -432, 132,
  372, -52, -256, 84, 116, -352, 48, 116, 304, -384, 412,
  924, -300, 528, 628, 180, 648, 44, -980, -220, 1320, 48,
  332, 748, 524, -268, -720, 540, -276, 564, -344, -208, -196,
  436, 896, 88, -392, 132, 80, -964, -288, 568, 56, -48,
  -456, 888, 8, 552, -156, -292, 948, 288, 128, -716, -292,
  1192, -152, 876, 352, -600, -260, -812, -468, -28, -120, -32,
  -44, 1284, 496, 192, 464, 312, -76, -516, -380, -456, -1012,
  -48, 308, -156, 36, 492, -156, -808, 188, 1652, 68, -120,
  -116, 316, 160, -140, 352, 808, -416, 592, 316, -480, 56,
  528, -204, -568, 372, -232, 752, -344, 744, -4, 324, -416,
  -600, 768, 268, -248, -88, -132, -420, -432, 80, -288, 404,
  -316, -1216, -588, 520, -108, 92, -320, 368, -480, -216, -92,
  1688, -300, 180, 1020, -176, 820, -68, -228, -260, 436, -904,
  20, 40, -508, 440, -736, 312, 332, 204, 760, -372, 728,
  96, -20, -632, -520, -560, 336, 1076, -64, -532, 776, 584,
  192, 396, -728, -520, 276, -188, 80, -52, -612, -252, -48,
  648, 212, -688, 228, -52, -260, 428, -412, -272, -404, 180,
  816, -796, 48, 152, 484, -88, -216, 988, 696, 188, -528,
  648, -116, -180, 316, 476, 12, -564, 96, 476, -252, -364,
  -376, -392, 556, -256, -576, 260, -352, 120, -16, -136, -260,
  -492, 72, 556, 660, 580, 616, 772, 436, 424, -32, -324,
  -1268, 416, -324, -80, 920, 160, 228, 724, 32, -516, 64,
  384, 68, -128, 136, 240, 248, -204, -68, 252, -932, -120,
  -480, -628, -84, 192, 852, -404, -288, -132, 204, 100, 168,
  -68, -196, -868, 460, 1080, 380, -80, 244, 0, 484, -888,
  64, 184, 352, 600, 460, 164, 604, -196, 320, -64, 588,
  -184, 228, 12, 372, 48, -848, -344, 224, 208, -200, 484,
  128, -20, 272, -468, -840, 384, 256, -720, -520, -464, -580,
  112, -120, 644, -356, -208, -608, -528, 704, 560, -424, 392,
  828, 40, 84, 200, -152, 0, -144, 584, 280, -120, 80,
  -556, -972, -196, -472, 724, 80, 168, -32, 88, 160, -688,
  0, 160, 356, 372, -776, 740, -128, 676, -248, -480, 4,
  -364, 96, 544, 232, -1032, 956, 236, 356, 20, -40, 300,
  24, -676, -596, 132, 1120, -104, 532, -1096, 568, 648, 444,
  508, 380, 188, -376, -604, 1488, 424, 24, 756, -220, -192,
  716, 120, 920, 688, 168, 44, -460, 568, 284, 1144, 1160,
  600, 424, 888, 656, -356, -320, 220, 316, -176, -724, -188,
  -816, -628, -348, -228, -380, 1012, -452, -660, 736, 928, 404,
  -696, -72, -268, -892, 128, 184, -344, -780, 360, 336, 400,
  344, 428, 548, -112, 136, -228, -216, -820, -516, 340, 92,
  -136, 116, -300, 376, -244, 100, -316, -520, -284, -12, 824,
  164, -548, -180, -128, 116, -924, -828, 268, -368, -580, 620,
  192, 160, 0, -1676, 1068, 424, -56, -360, 468, -156, 720,
  288, -528, 556, -364, 548, -148, 504, 316, 152, -648, -620,
  -684, -24, -376, -384, -108, -920, -1032, 768, 180, -264, -508,
  -1268, -260, -60, 300, -240, 988, 724, -376, -576, -212, -736,
  556, 192, 1092, -620, -880, 376, -56, -4, -216, -32, 836,
  268, 396, 1332, 864, -600, 100, 56, -412, -92, 356, 180,
  884, -468, -436, 292, -388, -804, -704, -840, 368, -348, 140,
  -724, 1536, 940, 372, 112, -372, 436, -480, 1136, 296, -32,
  -228, 132, -48, -220, 868, -1016, -60, -1044, -464, 328, 916,
  244, 12, -736, -296, 360, 468, -376, -108, -92, 788, 368,
  -56, 544, 400, -672, -420, 728, 16, 320, 44, -284, -380,
  -796, 488, 132, 204, -596, -372, 88, -152, -908, -636, -572,
  -624, -116, -692, -200, -56, 276, -88, 484, -324, 948, 864,
  1000, -456, -184, -276, 292, -296, 156, 676, 320, 160, 908,
  -84, -1236, -288, -116, 260, -372, -644, 732, -756, -96, 84,
  344, -520, 348, -688, 240, -84, 216, -1044, -136, -676, -396,
  -1500, 960, -40, 176, 168, 1516, 420, -504, -344, -364, -360,
  1216, -940, -380, -212, 252, -660, -708, 484, -444, -152, 928,
  -120, 1112, 476, -260, 560, -148, -344, 108, -196, 228, -288,
  504, 560, -328, -88, 288, -1008, 460, -228, 468, -836, -196,
  76, 388, 232, 412, -1168, -716, -644, 756, -172, -356, -504,
  116, 432, 528, 48, 476, -168, -608, 448, 160, -532, -272,
  28, -676, -12, 828, 980, 456, 520, 104, -104, 256, -344,
  -4, -28, -368, -52, -524, -572, -556, -200, 768, 1124, -208,
  -512, 176, 232, 248, -148, -888, 604, -600, -304, 804, -156,
  -212, 488, -192, -804, -256, 368, -360, -916, -328, 228, -240,
  -448, -472, 856, -556, -364, 572, -12, -156, -368, -340, 432,
  252, -752, -152, 288, 268, -580, -848, -592, 108, -76, 244,
  312, -716, 592, -80, 436, 360, 4, -248, 160, 516, 584,
  732, 44, -468, -280, -292, -156, -588, 28, 308, 912, 24,
  124, 156, 180, -252, 944, -924, -772, -520, -428, -624, 300,
  -212, -1144, 32, -724, 800, -1128, -212, -1288, -848, 180, -416,
  440, 192, -576, -792, -76, -1080, 80, -532, -352, -132, 380,
  -820, 148, 1112, 128, 164, 456, 700, -924, 144, -668, -384,
  648, -832, 508, 552, -52, -100, -656, 208, -568, 748, -88,
  680, 232, 300, 192, -408, -1012, -152, -252, -268, 272, -876,
  -664, -648, -332, -136, 16, 12, 1152, -28, 332, -536, 320,
  -672, -460, -316, 532, -260, 228, -40, 1052, -816, 180, 88,
  -496, -556, -672, -368, 428, 92, 356, 404, -408, 252, 196,
  -176, -556, 792, 268, 32, 372, 40, 96, -332, 328, 120,
  372, -900, -40, 472, -264, -592, 952, 128, 656, 112, 664,
  -232, 420, 4, -344, -464, 556, 244, -416, -32, 252, 0,
  -412, 188, -696, 508, -476, 324, -1096, 656, -312, 560, 264,
  -136, 304, 160, -64, -580, 248, 336, -720, 560, -348, -288,
  -276, -196, -500, 852, -544, -236, -1128, -992, -776, 116, 56,
  52, 860, 884, 212, -12, 168, 1020, 512, -552, 924, -148,
  716, 188, 164, -340, -520, -184, 880, -152, -680, -208, -1156,
  -300, -528, -472, 364, 100, -744, -1056, -32, 540, 280, 144,
  -676, -32, -232, -280, -224, 96, 568, -76, 172, 148, 148,
  104, 32, -296, -32, 788, -80, 32, -16, 280, 288, 944,
  428, -484];

// 9.4 Default CDF tables
const Default_Intra_Frame_Y_Mode_Cdf = [
  [
    [15588, 17027, 19338, 20218, 20682, 21110, 21825, 23244,
      24189, 28165, 29093, 30466, 32768, 0],
    [12016, 18066, 19516, 20303, 20719, 21444, 21888, 23032,
      24434, 28658, 30172, 31409, 32768, 0],
    [10052, 10771, 22296, 22788, 23055, 23239, 24133, 25620,
      26160, 29336, 29929, 31567, 32768, 0],
    [14091, 15406, 16442, 18808, 19136, 19546, 19998, 22096,
      24746, 29585, 30958, 32462, 32768, 0],
    [12122, 13265, 15603, 16501, 18609, 20033, 22391, 25583,
      26437, 30261, 31073, 32475, 32768, 0]
  ],
  [
    [10023, 19585, 20848, 21440, 21832, 22760, 23089, 24023,
      25381, 29014, 30482, 31436, 32768, 0],
    [5983, 24099, 24560, 24886, 25066, 25795, 25913, 26423,
      27610, 29905, 31276, 31794, 32768, 0],
    [7444, 12781, 20177, 20728, 21077, 21607, 22170, 23405,
      24469, 27915, 29090, 30492, 32768, 0],
    [8537, 14689, 15432, 17087, 17408, 18172, 18408, 19825,
      24649, 29153, 31096, 32210, 32768, 0],
    [7543, 14231, 15496, 16195, 17905, 20717, 21984, 24516,
      26001, 29675, 30981, 31994, 32768, 0]
  ],
  [
    [12613, 13591, 21383, 22004, 22312, 22577, 23401, 25055,
      25729, 29538, 30305, 32077, 32768, 0],
    [9687, 13470, 18506, 19230, 19604, 20147, 20695, 22062,
      23219, 27743, 29211, 30907, 32768, 0],
    [6183, 6505, 26024, 26252, 26366, 26434, 27082, 28354, 28555,
      30467, 30794, 32086, 32768, 0],
    [10718, 11734, 14954, 17224, 17565, 17924, 18561, 21523,
      23878, 28975, 30287, 32252, 32768, 0],
    [9194, 9858, 16501, 17263, 18424, 19171, 21563, 25961, 26561,
      30072, 30737, 32463, 32768, 0]
  ],
  [
    [12602, 14399, 15488, 18381, 18778, 19315, 19724, 21419,
      25060, 29696, 30917, 32409, 32768, 0],
    [8203, 13821, 14524, 17105, 17439, 18131, 18404, 19468,
      25225, 29485, 31158, 32342, 32768, 0],
    [8451, 9731, 15004, 17643, 18012, 18425, 19070, 21538, 24605,
      29118, 30078, 32018, 32768, 0],
    [7714, 9048, 9516, 16667, 16817, 16994, 17153, 18767, 26743,
      30389, 31536, 32528, 32768, 0],
    [8843, 10280, 11496, 15317, 16652, 17943, 19108, 22718,
      25769, 29953, 30983, 32485, 32768, 0]
  ],
  [
    [12578, 13671, 15979, 16834, 19075, 20913, 22989, 25449,
      26219, 30214, 31150, 32477, 32768, 0],
    [9563, 13626, 15080, 15892, 17756, 20863, 22207, 24236,
      25380, 29653, 31143, 32277, 32768, 0],
    [8356, 8901, 17616, 18256, 19350, 20106, 22598, 25947, 26466,
      29900, 30523, 32261, 32768, 0],
    [10835, 11815, 13124, 16042, 17018, 18039, 18947, 22753,
      24615, 29489, 30883, 32482, 32768, 0],
    [7618, 8288, 9859, 10509, 15386, 18657, 22903, 28776, 29180,
      31355, 31802, 32593, 32768, 0]
  ]
];
const Default_Y_Mode_Cdf = [
  [22801, 23489, 24293, 24756,
    25601, 26123, 26606, 27418,
    27945, 29228, 29685, 30349,
    32768, 0],
  [18673, 19845, 22631, 23318,
    23950, 24649, 25527, 27364,
    28152, 29701, 29984, 30852,
    32768, 0],
  [19770, 20979, 23396, 23939,
    24241, 24654, 25136, 27073,
    27830, 29360, 29730, 30659,
    32768, 0],
  [20155, 21301, 22838, 23178,
    23261, 23533, 23703, 24804,
    25352, 26575, 27016, 28049,
    32768, 0]
];
const Default_Uv_Mode_Cfl_Not_Allowed_Cdf = [
  [22631, 24152, 25378, 25661, 25986, 26520, 27055, 27923,
    28244, 30059, 30941, 31961, 32768, 0],
  [9513, 26881, 26973, 27046, 27118, 27664, 27739, 27824,
    28359, 29505, 29800, 31796, 32768, 0],
  [9845, 9915, 28663, 28704, 28757, 28780, 29198, 29822, 29854,
    30764, 31777, 32029, 32768, 0],
  [13639, 13897, 14171, 25331, 25606, 25727, 25953, 27148,
    28577, 30612, 31355, 32493, 32768, 0],
  [9764, 9835, 9930, 9954, 25386, 27053, 27958, 28148, 28243,
    31101, 31744, 32363, 32768, 0],
  [11825, 13589, 13677, 13720, 15048, 29213, 29301, 29458,
    29711, 31161, 31441, 32550, 32768, 0],
  [14175, 14399, 16608, 16821, 17718, 17775, 28551, 30200,
    30245, 31837, 32342, 32667, 32768, 0],
  [12885, 13038, 14978, 15590, 15673, 15748, 16176, 29128,
    29267, 30643, 31961, 32461, 32768, 0],
  [12026, 13661, 13874, 15305, 15490, 15726, 15995, 16273,
    28443, 30388, 30767, 32416, 32768, 0],
  [19052, 19840, 20579, 20916, 21150, 21467, 21885, 22719,
    23174, 28861, 30379, 32175, 32768, 0],
  [18627, 19649, 20974, 21219, 21492, 21816, 22199, 23119,
    23527, 27053, 31397, 32148, 32768, 0],
  [17026, 19004, 19997, 20339, 20586, 21103, 21349, 21907,
    22482, 25896, 26541, 31819, 32768, 0],
  [12124, 13759, 14959, 14992, 15007, 15051, 15078, 15166,
    15255, 15753, 16039, 16606, 32768, 0]
];
const Default_Uv_Mode_Cfl_Allowed_Cdf = [
  [10407, 11208, 12900, 13181, 13823, 14175, 14899, 15656,
    15986, 20086, 20995, 22455, 24212, 32768, 0],
  [4532, 19780, 20057, 20215, 20428, 21071, 21199, 21451,
    22099, 24228, 24693, 27032, 29472, 32768, 0],
  [5273, 5379, 20177, 20270, 20385, 20439, 20949, 21695, 21774,
    23138, 24256, 24703, 26679, 32768, 0],
  [6740, 7167, 7662, 14152, 14536, 14785, 15034, 16741, 18371,
    21520, 22206, 23389, 24182, 32768, 0],
  [4987, 5368, 5928, 6068, 19114, 20315, 21857, 22253, 22411,
    24911, 25380, 26027, 26376, 32768, 0],
  [5370, 6889, 7247, 7393, 9498, 21114, 21402, 21753, 21981,
    24780, 25386, 26517, 27176, 32768, 0],
  [4816, 4961, 7204, 7326, 8765, 8930, 20169, 20682, 20803,
    23188, 23763, 24455, 24940, 32768, 0],
  [6608, 6740, 8529, 9049, 9257, 9356, 9735, 18827, 19059,
    22336, 23204, 23964, 24793, 32768, 0],
  [5998, 7419, 7781, 8933, 9255, 9549, 9753, 10417, 18898,
    22494, 23139, 24764, 25989, 32768, 0],
  [10660, 11298, 12550, 12957, 13322, 13624, 14040, 15004,
    15534, 20714, 21789, 23443, 24861, 32768, 0],
  [10522, 11530, 12552, 12963, 13378, 13779, 14245, 15235,
    15902, 20102, 22696, 23774, 25838, 32768, 0],
  [10099, 10691, 12639, 13049, 13386, 13665, 14125, 15163,
    15636, 19676, 20474, 23519, 25208, 32768, 0],
  [3144, 5087, 7382, 7504, 7593, 7690, 7801, 8064, 8232, 9248,
    9875, 10521, 29048, 32768, 0]
];
const Default_Angle_Delta_Cdf = [
  [2180, 5032, 7567, 22776, 26989, 30217, 32768, 0],
  [2301, 5608, 8801, 23487, 26974, 30330, 32768, 0],
  [3780, 11018, 13699, 19354, 23083, 31286, 32768, 0],
  [4581, 11226, 15147, 17138, 21834, 28397, 32768, 0],
  [1737, 10927, 14509, 19588, 22745, 28823, 32768, 0],
  [2664, 10176, 12485, 17650, 21600, 30495, 32768, 0],
  [2240, 11096, 15453, 20341, 22561, 28917, 32768, 0],
  [3605, 10428, 12459, 17676, 21244, 30655, 32768, 0]
];
const Default_Intrabc_Cdf = [30531, 32768, 0];
const Default_Partition_W8_Cdf = [
  [19132, 25510, 30392, 32768, 0],
  [13928, 19855, 28540, 32768, 0],
  [12522, 23679, 28629, 32768, 0],
  [9896, 18783, 25853, 32768, 0],
];
const Default_Partition_W16_Cdf = [
  [15597, 20929, 24571, 26706, 27664, 28821, 29601, 30571, 31902, 32768, 0],
  [7925, 11043, 16785, 22470, 23971, 25043, 26651, 28701, 29834, 32768, 0],
  [5414, 13269, 15111, 20488, 22360, 24500, 25537, 26336, 32117, 32768, 0],
  [2662, 6362, 8614, 20860, 23053, 24778, 26436, 27829, 31171, 32768, 0],
];
const Default_Partition_W32_Cdf = [
  [18462, 20920, 23124, 27647, 28227, 29049, 29519, 30178, 31544, 32768, 0],
  [7689, 9060, 12056, 24992, 25660, 26182, 26951, 28041, 29052, 32768, 0],
  [6015, 9009, 10062, 24544, 25409, 26545, 27071, 27526, 32047, 32768, 0],
  [1394, 2208, 2796, 28614, 29061, 29466, 29840, 30185, 31899, 32768, 0],
];
const Default_Partition_W64_Cdf = [
  [20137, 21547, 23078, 29566, 29837, 30261, 30524, 30892, 31724, 32768, 0],
  [6732, 7490, 9497, 27944, 28250, 28515, 28969, 29630, 30104, 32768, 0],
  [5945, 7663, 8348, 28683, 29117, 29749, 30064, 30298, 32238, 32768, 0],
  [870, 1212, 1487, 31198, 31394, 31574, 31743, 31881, 32332, 32768, 0],
];
const Default_Partition_W128_Cdf = [
  [27899, 28219, 28529, 32484, 32539, 32619, 32639, 32768, 0],
  [6607, 6990, 8268, 32060, 32219, 32338, 32371, 32768, 0],
  [5429, 6676, 7122, 32027, 32227, 32531, 32582, 32768, 0],
  [711, 966, 1172, 32448, 32538, 32617, 32664, 32768, 0],
];
const Default_Tx_8x8_Cdf = [
  [19968, 32768, 0],
  [19968, 32768, 0],
  [24320, 32768, 0]
];
const Default_Tx_16x16_Cdf = [
  [12272, 30172, 32768, 0],
  [12272, 30172, 32768, 0],
  [18677, 30848, 32768, 0]
];
const Default_Tx_32x32_Cdf = [
  [12986, 15180, 32768, 0],
  [12986, 15180, 32768, 0],
  [24302, 25602, 32768, 0]
];
const Default_Tx_64x64_Cdf = [
  [5782, 11475, 32768, 0],
  [5782, 11475, 32768, 0],
  [16803, 22759, 32768, 0]
];
const Default_Txfm_Split_Cdf = [
  [28581, 32768, 0], [23846, 32768, 0], [20847, 32768, 0],
  [24315, 32768, 0], [18196, 32768, 0], [12133, 32768, 0],
  [18791, 32768, 0], [10887, 32768, 0], [11005, 32768, 0],
  [27179, 32768, 0], [20004, 32768, 0], [11281, 32768, 0],
  [26549, 32768, 0], [19308, 32768, 0], [14224, 32768, 0],
  [28015, 32768, 0], [21546, 32768, 0], [14400, 32768, 0],
  [28165, 32768, 0], [22401, 32768, 0], [16088, 32768, 0]
];
const Default_Filter_Intra_Mode_Cdf = [8949, 12776, 17211, 29558, 32768, 0];
const Default_Filter_Intra_Cdf = [
  [4621, 32768, 0], [6743, 32768, 0], [5893, 32768, 0],
  [7866, 32768, 0], [12551, 32768, 0], [9394, 32768, 0],
  [12408, 32768, 0], [14301, 32768, 0], [12756, 32768, 0],
  [22343, 32768, 0], [16384, 32768, 0], [16384, 32768, 0],
  [16384, 32768, 0], [16384, 32768, 0], [16384, 32768, 0],
  [16384, 32768, 0], [12770, 32768, 0], [10368, 32768, 0],
  [20229, 32768, 0], [18101, 32768, 0], [16384, 32768, 0],
  [16384, 32768, 0]
];
const Default_Segment_Id_Cdf = [
  [5622, 7893, 16093, 18233, 27809, 28373, 32533, 32768, 0],
  [14274, 18230, 22557, 24935, 29980, 30851, 32344, 32768, 0],
  [27527, 28487, 28723, 28890, 32397, 32647, 32679, 32768, 0]
];
const Default_Segment_Id_Predicted_Cdf = [
  [128 * 128, 32768, 0],
  [128 * 128, 32768, 0],
  [128 * 128, 32768, 0]
];
const Default_Mv_Class0_Hp_Cdf = [
  160 * 128, 32768, 0
];
const Default_Mv_Hp_Cdf = [
  128 * 128, 32768, 0
];
const Default_Mv_Sign_Cdf = [
  128 * 128, 32768, 0
];
const Default_Mv_Bit_Cdf = [
  [136 * 128, 32768, 0],
  [140 * 128, 32768, 0],
  [148 * 128, 32768, 0],
  [160 * 128, 32768, 0],
  [176 * 128, 32768, 0],
  [192 * 128, 32768, 0],
  [224 * 128, 32768, 0],
  [234 * 128, 32768, 0],
  [234 * 128, 32768, 0],
  [240 * 128, 32768, 0]
];
const Default_Mv_Class0_Bit_Cdf = [
  216 * 128, 32768, 0
];
const Default_New_Mv_Cdf = [
  [24035, 32768, 0],
  [16630, 32768, 0],
  [15339, 32768, 0],
  [8386, 32768, 0],
  [12222, 32768, 0],
  [4676, 32768, 0]
];
const Default_Zero_Mv_Cdf = [
  [2175, 32768, 0],
  [1054, 32768, 0]
];
const Default_Ref_Mv_Cdf = [
  [23974, 32768, 0],
  [24188, 32768, 0],
  [17848, 32768, 0],
  [28622, 32768, 0],
  [24312, 32768, 0],
  [19923, 32768, 0]
];
const Default_Drl_Mode_Cdf = [
  [13104, 32768, 0],
  [24560, 32768, 0],
  [18945, 32768, 0]
];
const Default_Is_Inter_Cdf = [
  [806, 32768, 0],
  [16662, 32768, 0],
  [20186, 32768, 0],
  [26538, 32768, 0]
];
const Default_Comp_Mode_Cdf = [
  [26828, 32768, 0],
  [24035, 32768, 0],
  [12031, 32768, 0],
  [10640, 32768, 0],
  [2901, 32768, 0]
];
const Default_Skip_Mode_Cdf = [
  [32621, 32768, 0],
  [20708, 32768, 0],
  [8127, 32768, 0]
];
const Default_Skip_Cdf = [
  [31671, 32768, 0],
  [16515, 32768, 0],
  [4576, 32768, 0]
];
const Default_Comp_Ref_Cdf = [
  [[4946, 32768, 0],
  [9468, 32768, 0],
  [1503, 32768, 0]],
  [[19891, 32768, 0],
  [22441, 32768, 0],
  [15160, 32768, 0]],
  [[30731, 32768, 0],
  [31059, 32768, 0],
  [27544, 32768, 0]]
];
const Default_Comp_Bwd_Ref_Cdf = [
  [[2235, 32768, 0], [1423, 32768, 0]],
  [[17182, 32768, 0], [15175, 32768, 0]],
  [[30606, 32768, 0], [30489, 32768, 0]]
];
const Default_Single_Ref_Cdf = [
  [[4897, 32768, 0], [1555, 32768, 0], [4236, 32768, 0],
  [8650, 32768, 0], [904, 32768, 0], [1444, 32768, 0]],
  [[16973, 32768, 0], [16751, 32768, 0], [19647, 32768, 0],
  [24773, 32768, 0], [11014, 32768, 0], [15087, 32768, 0]],
  [[29744, 32768, 0], [30279, 32768, 0], [31194, 32768, 0],
  [31895, 32768, 0], [26875, 32768, 0], [30304, 32768, 0]]
];
const Default_Compound_Mode_Cdf = [
  [7760, 13823, 15808, 17641, 19156, 20666, 26891, 32768, 0],
  [10730, 19452, 21145, 22749, 24039, 25131, 28724, 32768, 0],
  [10664, 20221, 21588, 22906, 24295, 25387, 28436, 32768, 0],
  [13298, 16984, 20471, 24182, 25067, 25736, 26422, 32768, 0],
  [18904, 23325, 25242, 27432, 27898, 28258, 30758, 32768, 0],
  [10725, 17454, 20124, 22820, 24195, 25168, 26046, 32768, 0],
  [17125, 24273, 25814, 27492, 28214, 28704, 30592, 32768, 0],
  [13046, 23214, 24505, 25942, 27435, 28442, 29330, 32768, 0]
];
const Default_Interp_Filter_Cdf = [
  [31935, 32720, 32768, 0],
  [5568, 32719, 32768, 0],
  [422, 2938, 32768, 0],
  [28244, 32608, 32768, 0],
  [31206, 31953, 32768, 0],
  [4862, 32121, 32768, 0],
  [770, 1152, 32768, 0],
  [20889, 25637, 32768, 0],
  [31910, 32724, 32768, 0],
  [4120, 32712, 32768, 0],
  [305, 2247, 32768, 0],
  [27403, 32636, 32768, 0],
  [31022, 32009, 32768, 0],
  [2963, 32093, 32768, 0],
  [601, 943, 32768, 0],
  [14969, 21398, 32768, 0]
];
const Default_Motion_Mode_Cdf = [
  [10923, 21845, 32768, 0],
  [10923, 21845, 32768, 0],
  [10923, 21845, 32768, 0],
  [7651, 24760, 32768, 0],
  [4738, 24765, 32768, 0],
  [5391, 25528, 32768, 0],
  [19419, 26810, 32768, 0],
  [5123, 23606, 32768, 0],
  [11606, 24308, 32768, 0],
  [26260, 29116, 32768, 0],
  [20360, 28062, 32768, 0],
  [21679, 26830, 32768, 0],
  [29516, 30701, 32768, 0],
  [28898, 30397, 32768, 0],
  [30878, 31335, 32768, 0],
  [32507, 32558, 32768, 0],
  [10923, 21845, 32768, 0],
  [10923, 21845, 32768, 0],
  [28799, 31390, 32768, 0],
  [26431, 30774, 32768, 0],
  [28973, 31594, 32768, 0],
  [29742, 31203, 32768, 0]
];
const Default_Mv_Joint_Cdf = [
  4096, 11264, 19328, 32768, 0
];
const Default_Mv_Class_Cdf = [
  [28672, 30976, 31858, 32320,
    32551, 32656, 32740, 32757,
    32762, 32767, 32768, 0],
  [28672, 30976, 31858, 32320,
    32551, 32656, 32740, 32757,
    32762, 32767, 32768, 0]
];
const Default_Mv_Class0_Fr_Cdf = [
  [[16384, 24576, 26624, 32768, 0],
  [12288, 21248, 24128, 32768, 0]],
  [[16384, 24576, 26624, 32768, 0],
  [12288, 21248, 24128, 32768, 0]],
];
const Default_Mv_Fr_Cdf = [
  [8192, 17408, 21248, 32768, 0],
  [8192, 17408, 21248, 32768, 0],
];
const Default_Palette_Y_Size_Cdf = [
  [7952, 13000, 18149, 21478, 25527, 29241, 32768, 0],
  [7139, 11421, 16195, 19544, 23666, 28073, 32768, 0],
  [7788, 12741, 17325, 20500, 24315, 28530, 32768, 0],
  [8271, 14064, 18246, 21564, 25071, 28533, 32768, 0],
  [12725, 19180, 21863, 24839, 27535, 30120, 32768, 0],
  [9711, 14888, 16923, 21052, 25661, 27875, 32768, 0],
  [14940, 20797, 21678, 24186, 27033, 28999, 32768, 0]
];
const Default_Palette_Uv_Size_Cdf = [
  [8713, 19979, 27128, 29609, 31331, 32272, 32768, 0],
  [5839, 15573, 23581, 26947, 29848, 31700, 32768, 0],
  [4426, 11260, 17999, 21483, 25863, 29430, 32768, 0],
  [3228, 9464, 14993, 18089, 22523, 27420, 32768, 0],
  [3768, 8886, 13091, 17852, 22495, 27207, 32768, 0],
  [2464, 8451, 12861, 21632, 25525, 28555, 32768, 0],
  [1269, 5435, 10433, 18963, 21700, 25865, 32768, 0]
];
const Default_Palette_Size_2_Y_Color_Cdf = [
  [28710, 32768, 0],
  [16384, 32768, 0],
  [10553, 32768, 0],
  [27036, 32768, 0],
  [31603, 32768, 0]
];
const Default_Palette_Size_3_Y_Color_Cdf = [
  [27877, 30490, 32768, 0],
  [11532, 25697, 32768, 0],
  [6544, 30234, 32768, 0],
  [23018, 28072, 32768, 0],
  [31915, 32385, 32768, 0]
];
const Default_Palette_Size_4_Y_Color_Cdf = [
  [25572, 28046, 30045, 32768, 0],
  [9478, 21590, 27256, 32768, 0],
  [7248, 26837, 29824, 32768, 0],
  [19167, 24486, 28349, 32768, 0],
  [31400, 31825, 32250, 32768, 0]
];
const Default_Palette_Size_5_Y_Color_Cdf = [
  [24779, 26955, 28576, 30282, 32768, 0],
  [8669, 20364, 24073, 28093, 32768, 0],
  [4255, 27565, 29377, 31067, 32768, 0],
  [19864, 23674, 26716, 29530, 32768, 0],
  [31646, 31893, 32147, 32426, 32768, 0]
];
const Default_Palette_Size_6_Y_Color_Cdf = [
  [23132, 25407, 26970, 28435, 30073, 32768, 0],
  [7443, 17242, 20717, 24762, 27982, 32768, 0],
  [6300, 24862, 26944, 28784, 30671, 32768, 0],
  [18916, 22895, 25267, 27435, 29652, 32768, 0],
  [31270, 31550, 31808, 32059, 32353, 32768, 0]
];
const Default_Palette_Size_7_Y_Color_Cdf = [
  [23105, 25199, 26464, 27684, 28931, 30318, 32768, 0],
  [6950, 15447, 18952, 22681, 25567, 28563, 32768, 0],
  [7560, 23474, 25490, 27203, 28921, 30708, 32768, 0],
  [18544, 22373, 24457, 26195, 28119, 30045, 32768, 0],
  [31198, 31451, 31670, 31882, 32123, 32391, 32768, 0]
];
const Default_Palette_Size_8_Y_Color_Cdf = [
  [21689, 23883, 25163, 26352, 27506, 28827, 30195, 32768, 0],
  [6892, 15385, 17840, 21606, 24287, 26753, 29204, 32768, 0],
  [5651, 23182, 25042, 26518, 27982, 29392, 30900, 32768, 0],
  [19349, 22578, 24418, 25994, 27524, 29031, 30448, 32768, 0],
  [31028, 31270, 31504, 31705, 31927, 32153, 32392, 32768, 0]
];
const Default_Palette_Size_2_Uv_Color_Cdf = [
  [29089, 32768, 0],
  [16384, 32768, 0],
  [8713, 32768, 0],
  [29257, 32768, 0],
  [31610, 32768, 0]
];
const Default_Palette_Size_3_Uv_Color_Cdf = [
  [25257, 29145, 32768, 0],
  [12287, 27293, 32768, 0],
  [7033, 27960, 32768, 0],
  [20145, 25405, 32768, 0],
  [30608, 31639, 32768, 0]
];
const Default_Palette_Size_4_Uv_Color_Cdf = [
  [24210, 27175, 29903, 32768, 0],
  [9888, 22386, 27214, 32768, 0],
  [5901, 26053, 29293, 32768, 0],
  [18318, 22152, 28333, 32768, 0],
  [30459, 31136, 31926, 32768, 0]
];
const Default_Palette_Size_5_Uv_Color_Cdf = [
  [22980, 25479, 27781, 29986, 32768, 0],
  [8413, 21408, 24859, 28874, 32768, 0],
  [2257, 29449, 30594, 31598, 32768, 0],
  [19189, 21202, 25915, 28620, 32768, 0],
  [31844, 32044, 32281, 32518, 32768, 0]
];
const Default_Palette_Size_6_Uv_Color_Cdf = [
  [22217, 24567, 26637, 28683, 30548, 32768, 0],
  [7307, 16406, 19636, 24632, 28424, 32768, 0],
  [4441, 25064, 26879, 28942, 30919, 32768, 0],
  [17210, 20528, 23319, 26750, 29582, 32768, 0],
  [30674, 30953, 31396, 31735, 32207, 32768, 0]
];
const Default_Palette_Size_7_Uv_Color_Cdf = [
  [21239, 23168, 25044, 26962, 28705, 30506, 32768, 0],
  [6545, 15012, 18004, 21817, 25503, 28701, 32768, 0],
  [3448, 26295, 27437, 28704, 30126, 31442, 32768, 0],
  [15889, 18323, 21704, 24698, 26976, 29690, 32768, 0],
  [30988, 31204, 31479, 31734, 31983, 32325, 32768, 0]
];
const Default_Palette_Size_8_Uv_Color_Cdf = [
  [21442, 23288, 24758, 26246, 27649, 28980, 30563, 32768, 0],
  [5863, 14933, 17552, 20668, 23683, 26411, 29273, 32768, 0],
  [3415, 25810, 26877, 27990, 29223, 30394, 31618, 32768, 0],
  [17965, 20084, 22232, 23974, 26274, 28402, 30390, 32768, 0],
  [31190, 31329, 31516, 31679, 31825, 32026, 32322, 32768, 0]
];
const Default_Palette_Y_Mode_Cdf = [
  [[31676, 32768, 0], [3419, 32768, 0], [1261, 32768, 0]],
  [[31912, 32768, 0], [2859, 32768, 0], [980, 32768, 0]],
  [[31823, 32768, 0], [3400, 32768, 0], [781, 32768, 0]],
  [[32030, 32768, 0], [3561, 32768, 0], [904, 32768, 0]],
  [[32309, 32768, 0], [7337, 32768, 0], [1462, 32768, 0]],
  [[32265, 32768, 0], [4015, 32768, 0], [1521, 32768, 0]],
  [[32450, 32768, 0], [7946, 32768, 0], [129, 32768, 0]]
];
const Default_Palette_Uv_Mode_Cdf = [
  [32461, 32768, 0], [21488, 32768, 0]
];
const Default_Delta_Q_Cdf = [
  28160, 32120, 32677, 32768, 0
];
const Default_Delta_Lf_Cdf = [
  28160, 32120, 32677, 32768, 0
];
const Default_Intra_Tx_Type_Set1_Cdf = [
  [
    [1535, 8035, 9461, 12751, 23467, 27825, 32768, 0],
    [564, 3335, 9709, 10870, 18143, 28094, 32768, 0],
    [672, 3247, 3676, 11982, 19415, 23127, 32768, 0],
    [5279, 13885, 15487, 18044, 23527, 30252, 32768, 0],
    [4423, 6074, 7985, 10416, 25693, 29298, 32768, 0],
    [1486, 4241, 9460, 10662, 16456, 27694, 32768, 0],
    [439, 2838, 3522, 6737, 18058, 23754, 32768, 0],
    [1190, 4233, 4855, 11670, 20281, 24377, 32768, 0],
    [1045, 4312, 8647, 10159, 18644, 29335, 32768, 0],
    [202, 3734, 4747, 7298, 17127, 24016, 32768, 0],
    [447, 4312, 6819, 8884, 16010, 23858, 32768, 0],
    [277, 4369, 5255, 8905, 16465, 22271, 32768, 0],
    [3409, 5436, 10599, 15599, 19687, 24040, 32768, 0]
  ],
  [
    [1870, 13742, 14530, 16498, 23770, 27698, 32768, 0],
    [326, 8796, 14632, 15079, 19272, 27486, 32768, 0],
    [484, 7576, 7712, 14443, 19159, 22591, 32768, 0],
    [1126, 15340, 15895, 17023, 20896, 30279, 32768, 0],
    [655, 4854, 5249, 5913, 22099, 27138, 32768, 0],
    [1299, 6458, 8885, 9290, 14851, 25497, 32768, 0],
    [311, 5295, 5552, 6885, 16107, 22672, 32768, 0],
    [883, 8059, 8270, 11258, 17289, 21549, 32768, 0],
    [741, 7580, 9318, 10345, 16688, 29046, 32768, 0],
    [110, 7406, 7915, 9195, 16041, 23329, 32768, 0],
    [363, 7974, 9357, 10673, 15629, 24474, 32768, 0],
    [153, 7647, 8112, 9936, 15307, 19996, 32768, 0],
    [3511, 6332, 11165, 15335, 19323, 23594, 32768, 0]
  ]
];
const Default_Intra_Tx_Type_Set2_Cdf = [
  [
    [6554, 13107, 19661, 26214, 32768, 0],
    [6554, 13107, 19661, 26214, 32768, 0],
    [6554, 13107, 19661, 26214, 32768, 0],
    [6554, 13107, 19661, 26214, 32768, 0],
    [6554, 13107, 19661, 26214, 32768, 0],
    [6554, 13107, 19661, 26214, 32768, 0],
    [6554, 13107, 19661, 26214, 32768, 0],
    [6554, 13107, 19661, 26214, 32768, 0],
    [6554, 13107, 19661, 26214, 32768, 0],
    [6554, 13107, 19661, 26214, 32768, 0],
    [6554, 13107, 19661, 26214, 32768, 0],
    [6554, 13107, 19661, 26214, 32768, 0],
    [6554, 13107, 19661, 26214, 32768, 0]
  ],
  [
    [6554, 13107, 19661, 26214, 32768, 0],
    [6554, 13107, 19661, 26214, 32768, 0],
    [6554, 13107, 19661, 26214, 32768, 0],
    [6554, 13107, 19661, 26214, 32768, 0],
    [6554, 13107, 19661, 26214, 32768, 0],
    [6554, 13107, 19661, 26214, 32768, 0],
    [6554, 13107, 19661, 26214, 32768, 0],
    [6554, 13107, 19661, 26214, 32768, 0],
    [6554, 13107, 19661, 26214, 32768, 0],
    [6554, 13107, 19661, 26214, 32768, 0],
    [6554, 13107, 19661, 26214, 32768, 0],
    [6554, 13107, 19661, 26214, 32768, 0],
    [6554, 13107, 19661, 26214, 32768, 0]
  ],
  [
    [1127, 12814, 22772, 27483, 32768, 0],
    [145, 6761, 11980, 26667, 32768, 0],
    [362, 5887, 11678, 16725, 32768, 0],
    [385, 15213, 18587, 30693, 32768, 0],
    [25, 2914, 23134, 27903, 32768, 0],
    [60, 4470, 11749, 23991, 32768, 0],
    [37, 3332, 14511, 21448, 32768, 0],
    [157, 6320, 13036, 17439, 32768, 0],
    [119, 6719, 12906, 29396, 32768, 0],
    [47, 5537, 12576, 21499, 32768, 0],
    [269, 6076, 11258, 23115, 32768, 0],
    [83, 5615, 12001, 17228, 32768, 0],
    [1968, 5556, 12023, 18547, 32768, 0]
  ]
];
const Default_Inter_Tx_Type_Set1_Cdf = [
  [4458, 5560, 7695, 9709, 13330, 14789, 17537, 20266, 21504,
    22848, 23934, 25474, 27727, 28915, 30631, 32768, 0],
  [1645, 2573, 4778, 5711, 7807, 8622, 10522, 15357, 17674,
    20408, 22517, 25010, 27116, 28856, 30749, 32768, 0]
];
const Default_Inter_Tx_Type_Set2_Cdf = [
  770, 2421, 5225, 12907, 15819, 18927, 21561, 24089, 26595,
  28526, 30529, 32768, 0
];
const Default_Inter_Tx_Type_Set3_Cdf = [
  [16384, 32768, 0],
  [4167, 32768, 0],
  [1998, 32768, 0],
  [748, 32768, 0]
];
const Default_Compound_Idx_Cdf = [
  [18244, 32768, 0],
  [12865, 32768, 0],
  [7053, 32768, 0],
  [13259, 32768, 0],
  [9334, 32768, 0],
  [4644, 32768, 0]
];
const Default_Comp_Group_Idx_Cdf = [
  [26607, 32768, 0],
  [22891, 32768, 0],
  [18840, 32768, 0],
  [24594, 32768, 0],
  [19934, 32768, 0],
  [22674, 32768, 0]
];
const Default_Compound_Type_Cdf = [
  [16384, 32768, 0],
  [16384, 32768, 0],
  [16384, 32768, 0],
  [23431, 32768, 0],
  [13171, 32768, 0],
  [11470, 32768, 0],
  [9770, 32768, 0],
  [9100, 32768, 0],
  [8233, 32768, 0],
  [6172, 32768, 0],
  [16384, 32768, 0],
  [16384, 32768, 0],
  [16384, 32768, 0],
  [16384, 32768, 0],
  [16384, 32768, 0],
  [16384, 32768, 0],
  [16384, 32768, 0],
  [16384, 32768, 0],
  [11820, 32768, 0],
  [7701, 32768, 0],
  [16384, 32768, 0],
  [16384, 32768, 0]
];
const Default_Inter_Intra_Cdf = [
  [26887, 32768, 0],
  [27597, 32768, 0],
  [30237, 32768, 0]
];
const Default_Inter_Intra_Mode_Cdf = [
  [1875, 11082, 27332, 32768, 0],
  [2473, 9996, 26388, 32768, 0],
  [4238, 11537, 25926, 32768, 0]
];
const Default_Wedge_Index_Cdf = [
  [2048, 4096, 6144, 8192, 10240, 12288, 14336, 16384, 18432, 20480, 22528, 24576, 26624, 28672, 30720, 32768, 0],
  [2048, 4096, 6144, 8192, 10240, 12288, 14336, 16384, 18432, 20480, 22528, 24576, 26624, 28672, 30720, 32768, 0],
  [2048, 4096, 6144, 8192, 10240, 12288, 14336, 16384, 18432, 20480, 22528, 24576, 26624, 28672, 30720, 32768, 0],
  [2438, 4440, 6599, 8663, 11005, 12874, 15751, 18094, 20359, 22362, 24127, 25702, 27752, 29450, 31171, 32768, 0],
  [806, 3266, 6005, 6738, 7218, 7367, 7771, 14588, 16323, 17367, 18452, 19422, 22839, 26127, 29629, 32768, 0],
  [2779, 3738, 4683, 7213, 7775, 8017, 8655, 14357, 17939, 21332, 24520, 27470, 29456, 30529, 31656, 32768, 0],
  [1684, 3625, 5675, 7108, 9302, 11274, 14429, 17144, 19163, 20961, 22884, 24471, 26719, 28714, 30877, 32768, 0],
  [1142, 3491, 6277, 7314, 8089, 8355, 9023, 13624, 15369, 16730, 18114, 19313, 22521, 26012, 29550, 32768, 0],
  [2742, 4195, 5727, 8035, 8980, 9336, 10146, 14124, 17270, 20533, 23434, 25972, 27944, 29570, 31416, 32768, 0],
  [1727, 3948, 6101, 7796, 9841, 12344, 15766, 18944, 20638, 22038, 23963, 25311, 26988, 28766, 31012, 32768, 0],
  [2048, 4096, 6144, 8192, 10240, 12288, 14336, 16384, 18432, 20480, 22528, 24576, 26624, 28672, 30720, 32768, 0],
  [2048, 4096, 6144, 8192, 10240, 12288, 14336, 16384, 18432, 20480, 22528, 24576, 26624, 28672, 30720, 32768, 0],
  [2048, 4096, 6144, 8192, 10240, 12288, 14336, 16384, 18432, 20480, 22528, 24576, 26624, 28672, 30720, 32768, 0],
  [2048, 4096, 6144, 8192, 10240, 12288, 14336, 16384, 18432, 20480, 22528, 24576, 26624, 28672, 30720, 32768, 0],
  [2048, 4096, 6144, 8192, 10240, 12288, 14336, 16384, 18432, 20480, 22528, 24576, 26624, 28672, 30720, 32768, 0],
  [2048, 4096, 6144, 8192, 10240, 12288, 14336, 16384, 18432, 20480, 22528, 24576, 26624, 28672, 30720, 32768, 0],
  [2048, 4096, 6144, 8192, 10240, 12288, 14336, 16384, 18432, 20480, 22528, 24576, 26624, 28672, 30720, 32768, 0],
  [2048, 4096, 6144, 8192, 10240, 12288, 14336, 16384, 18432, 20480, 22528, 24576, 26624, 28672, 30720, 32768, 0],
  [154, 987, 1925, 2051, 2088, 2111, 2151, 23033, 23703, 24284, 24985, 25684, 27259, 28883, 30911, 32768, 0],
  [1135, 1322, 1493, 2635, 2696, 2737, 2770, 21016, 22935, 25057, 27251, 29173, 30089, 30960, 31933, 32768, 0],
  [2048, 4096, 6144, 8192, 10240, 12288, 14336, 16384, 18432, 20480, 22528, 24576, 26624, 28672, 30720, 32768, 0],
  [2048, 4096, 6144, 8192, 10240, 12288, 14336, 16384, 18432, 20480, 22528, 24576, 26624, 28672, 30720, 32768, 0]
];
const Default_Wedge_Inter_Intra_Cdf = [
  [16384, 32768, 0],
  [16384, 32768, 0],
  [16384, 32768, 0],
  [20036, 32768, 0],
  [24957, 32768, 0],
  [26704, 32768, 0],
  [27530, 32768, 0],
  [29564, 32768, 0],
  [29444, 32768, 0],
  [26872, 32768, 0],
  [16384, 32768, 0],
  [16384, 32768, 0],
  [16384, 32768, 0],
  [16384, 32768, 0],
  [16384, 32768, 0],
  [16384, 32768, 0],
  [16384, 32768, 0],
  [16384, 32768, 0],
  [16384, 32768, 0],
  [16384, 32768, 0],
  [16384, 32768, 0],
  [16384, 32768, 0]
];
const Default_Use_Obmc_Cdf = [
  [16384, 32768, 0],
  [16384, 32768, 0],
  [16384, 32768, 0],
  [10437, 32768, 0],
  [9371, 32768, 0],
  [9301, 32768, 0],
  [17432, 32768, 0],
  [14423, 32768, 0],
  [15142, 32768, 0],
  [25817, 32768, 0],
  [22823, 32768, 0],
  [22083, 32768, 0],
  [30128, 32768, 0],
  [31014, 32768, 0],
  [31560, 32768, 0],
  [32638, 32768, 0],
  [16384, 32768, 0],
  [16384, 32768, 0],
  [23664, 32768, 0],
  [20901, 32768, 0],
  [24008, 32768, 0],
  [26879, 32768, 0]
];
const Default_Comp_Ref_Type_Cdf = [
  [1198, 32768, 0],
  [2070, 32768, 0],
  [9166, 32768, 0],
  [7499, 32768, 0],
  [22475, 32768, 0]
];
const Default_Uni_Comp_Ref_Cdf = [
  [[5284, 32768, 0], [3865, 32768, 0], [3128, 32768, 0]],
  [[23152, 32768, 0], [14173, 32768, 0], [15270, 32768, 0]],
  [[31774, 32768, 0], [25120, 32768, 0], [26710, 32768, 0]]
];
const Default_Cfl_Sign_Cdf = [
  1418, 2123, 13340, 18405, 26972, 28343, 32294, 32768, 0
];
const Default_Cfl_Alpha_Cdf = [
  [7637, 20719, 31401, 32481, 32657, 32688, 32692, 32696, 32700,
    32704, 32708, 32712, 32716, 32720, 32724, 32768, 0],
  [14365, 23603, 28135, 31168, 32167, 32395, 32487, 32573, 32620,
    32647, 32668, 32672, 32676, 32680, 32684, 32768, 0],
  [11532, 22380, 28445, 31360, 32349, 32523, 32584, 32649, 32673,
    32677, 32681, 32685, 32689, 32693, 32697, 32768, 0],
  [26990, 31402, 32282, 32571, 32692, 32696, 32700, 32704, 32708,
    32712, 32716, 32720, 32724, 32728, 32732, 32768, 0],
  [17248, 26058, 28904, 30608, 31305, 31877, 32126, 32321, 32394,
    32464, 32516, 32560, 32576, 32593, 32622, 32768, 0],
  [14738, 21678, 25779, 27901, 29024, 30302, 30980, 31843, 32144,
    32413, 32520, 32594, 32622, 32656, 32660, 32768, 0]
];
const Default_Use_Wiener_Cdf = [
  11570, 32768, 0
];
const Default_Use_Sgrproj_Cdf = [
  16855, 32768, 0
];
const Default_Restoration_Type_Cdf = [
  9413, 22581, 32768, 0
];
const Default_Txb_Skip_Cdf = [
  [
    [[31849, 32768, 0],
    [5892, 32768, 0],
    [12112, 32768, 0],
    [21935, 32768, 0],
    [20289, 32768, 0],
    [27473, 32768, 0],
    [32487, 32768, 0],
    [7654, 32768, 0],
    [19473, 32768, 0],
    [29984, 32768, 0],
    [9961, 32768, 0],
    [30242, 32768, 0],
    [32117, 32768, 0]],
    [[31548, 32768, 0],
    [1549, 32768, 0],
    [10130, 32768, 0],
    [16656, 32768, 0],
    [18591, 32768, 0],
    [26308, 32768, 0],
    [32537, 32768, 0],
    [5403, 32768, 0],
    [18096, 32768, 0],
    [30003, 32768, 0],
    [16384, 32768, 0],
    [16384, 32768, 0],
    [16384, 32768, 0]],
    [[29957, 32768, 0],
    [5391, 32768, 0],
    [18039, 32768, 0],
    [23566, 32768, 0],
    [22431, 32768, 0],
    [25822, 32768, 0],
    [32197, 32768, 0],
    [3778, 32768, 0],
    [15336, 32768, 0],
    [28981, 32768, 0],
    [16384, 32768, 0],
    [16384, 32768, 0],
    [16384, 32768, 0]],
    [[17920, 32768, 0],
    [1818, 32768, 0],
    [7282, 32768, 0],
    [25273, 32768, 0],
    [10923, 32768, 0],
    [31554, 32768, 0],
    [32624, 32768, 0],
    [1366, 32768, 0],
    [15628, 32768, 0],
    [30462, 32768, 0],
    [146, 32768, 0],
    [5132, 32768, 0],
    [31657, 32768, 0]],
    [[6308, 32768, 0],
    [117, 32768, 0],
    [1638, 32768, 0],
    [2161, 32768, 0],
    [16384, 32768, 0],
    [10923, 32768, 0],
    [30247, 32768, 0],
    [16384, 32768, 0],
    [16384, 32768, 0],
    [16384, 32768, 0],
    [16384, 32768, 0],
    [16384, 32768, 0],
    [16384, 32768, 0]]
  ],
  [
    [[30371, 32768, 0],
    [7570, 32768, 0],
    [13155, 32768, 0],
    [20751, 32768, 0],
    [20969, 32768, 0],
    [27067, 32768, 0],
    [32013, 32768, 0],
    [5495, 32768, 0],
    [17942, 32768, 0],
    [28280, 32768, 0],
    [16384, 32768, 0],
    [16384, 32768, 0],
    [16384, 32768, 0]],
    [[31782, 32768, 0],
    [1836, 32768, 0],
    [10689, 32768, 0],
    [17604, 32768, 0],
    [21622, 32768, 0],
    [27518, 32768, 0],
    [32399, 32768, 0],
    [4419, 32768, 0],
    [16294, 32768, 0],
    [28345, 32768, 0],
    [16384, 32768, 0],
    [16384, 32768, 0],
    [16384, 32768, 0]],
    [[31901, 32768, 0],
    [10311, 32768, 0],
    [18047, 32768, 0],
    [24806, 32768, 0],
    [23288, 32768, 0],
    [27914, 32768, 0],
    [32296, 32768, 0],
    [4215, 32768, 0],
    [15756, 32768, 0],
    [28341, 32768, 0],
    [16384, 32768, 0],
    [16384, 32768, 0],
    [16384, 32768, 0]],
    [[26726, 32768, 0],
    [1045, 32768, 0],
    [11703, 32768, 0],
    [20590, 32768, 0],
    [18554, 32768, 0],
    [25970, 32768, 0],
    [31938, 32768, 0],
    [5583, 32768, 0],
    [21313, 32768, 0],
    [29390, 32768, 0],
    [641, 32768, 0],
    [22265, 32768, 0],
    [31452, 32768, 0]],
    [[26584, 32768, 0],
    [188, 32768, 0],
    [8847, 32768, 0],
    [24519, 32768, 0],
    [22938, 32768, 0],
    [30583, 32768, 0],
    [32608, 32768, 0],
    [16384, 32768, 0],
    [16384, 32768, 0],
    [16384, 32768, 0],
    [16384, 32768, 0],
    [16384, 32768, 0],
    [16384, 32768, 0]]
  ],
  [
    [[29614, 32768, 0],
    [9068, 32768, 0],
    [12924, 32768, 0],
    [19538, 32768, 0],
    [17737, 32768, 0],
    [24619, 32768, 0],
    [30642, 32768, 0],
    [4119, 32768, 0],
    [16026, 32768, 0],
    [25657, 32768, 0],
    [16384, 32768, 0],
    [16384, 32768, 0],
    [16384, 32768, 0]],
    [[31957, 32768, 0],
    [3230, 32768, 0],
    [11153, 32768, 0],
    [18123, 32768, 0],
    [20143, 32768, 0],
    [26536, 32768, 0],
    [31986, 32768, 0],
    [3050, 32768, 0],
    [14603, 32768, 0],
    [25155, 32768, 0],
    [16384, 32768, 0],
    [16384, 32768, 0],
    [16384, 32768, 0]],
    [[32363, 32768, 0],
    [10692, 32768, 0],
    [19090, 32768, 0],
    [24357, 32768, 0],
    [24442, 32768, 0],
    [28312, 32768, 0],
    [32169, 32768, 0],
    [3648, 32768, 0],
    [15690, 32768, 0],
    [26815, 32768, 0],
    [16384, 32768, 0],
    [16384, 32768, 0],
    [16384, 32768, 0]],
    [[30669, 32768, 0],
    [3832, 32768, 0],
    [11663, 32768, 0],
    [18889, 32768, 0],
    [19782, 32768, 0],
    [23313, 32768, 0],
    [31330, 32768, 0],
    [5124, 32768, 0],
    [18719, 32768, 0],
    [28468, 32768, 0],
    [3082, 32768, 0],
    [20982, 32768, 0],
    [29443, 32768, 0]],
    [[28573, 32768, 0],
    [3183, 32768, 0],
    [17802, 32768, 0],
    [25977, 32768, 0],
    [26677, 32768, 0],
    [27832, 32768, 0],
    [32387, 32768, 0],
    [16384, 32768, 0],
    [16384, 32768, 0],
    [16384, 32768, 0],
    [16384, 32768, 0],
    [16384, 32768, 0],
    [16384, 32768, 0]]
  ],
  [
    [[26887, 32768, 0],
    [6729, 32768, 0],
    [10361, 32768, 0],
    [17442, 32768, 0],
    [15045, 32768, 0],
    [22478, 32768, 0],
    [29072, 32768, 0],
    [2713, 32768, 0],
    [11861, 32768, 0],
    [20773, 32768, 0],
    [16384, 32768, 0],
    [16384, 32768, 0],
    [16384, 32768, 0]],
    [[31903, 32768, 0],
    [2044, 32768, 0],
    [7528, 32768, 0],
    [14618, 32768, 0],
    [16182, 32768, 0],
    [24168, 32768, 0],
    [31037, 32768, 0],
    [2786, 32768, 0],
    [11194, 32768, 0],
    [20155, 32768, 0],
    [16384, 32768, 0],
    [16384, 32768, 0],
    [16384, 32768, 0]],
    [[32510, 32768, 0],
    [8430, 32768, 0],
    [17318, 32768, 0],
    [24154, 32768, 0],
    [23674, 32768, 0],
    [28789, 32768, 0],
    [32139, 32768, 0],
    [3440, 32768, 0],
    [13117, 32768, 0],
    [22702, 32768, 0],
    [16384, 32768, 0],
    [16384, 32768, 0],
    [16384, 32768, 0]],
    [[31671, 32768, 0],
    [2056, 32768, 0],
    [11746, 32768, 0],
    [16852, 32768, 0],
    [18635, 32768, 0],
    [24715, 32768, 0],
    [31484, 32768, 0],
    [4656, 32768, 0],
    [16074, 32768, 0],
    [24704, 32768, 0],
    [1806, 32768, 0],
    [14645, 32768, 0],
    [25336, 32768, 0]],
    [[31539, 32768, 0],
    [8433, 32768, 0],
    [20576, 32768, 0],
    [27904, 32768, 0],
    [27852, 32768, 0],
    [30026, 32768, 0],
    [32441, 32768, 0],
    [16384, 32768, 0],
    [16384, 32768, 0],
    [16384, 32768, 0],
    [16384, 32768, 0],
    [16384, 32768, 0],
    [16384, 32768, 0]]
  ]
];
const Default_Eob_Pt_16_Cdf = [
  [[[840, 1039, 1980, 4895, 32768, 0],
  [370, 671, 1883, 4471, 32768, 0]],
  [[3247, 4950, 9688, 14563, 32768, 0],
  [1904, 3354, 7763, 14647, 32768, 0]]],
  [[[2125, 2551, 5165, 8946, 32768, 0],
  [513, 765, 1859, 6339, 32768, 0]],
  [[7637, 9498, 14259, 19108, 32768, 0],
  [2497, 4096, 8866, 16993, 32768, 0]]],
  [[[4016, 4897, 8881, 14968, 32768, 0],
  [716, 1105, 2646, 10056, 32768, 0]],
  [[11139, 13270, 18241, 23566, 32768, 0],
  [3192, 5032, 10297, 19755, 32768, 0]]],
  [[[6708, 8958, 14746, 22133, 32768, 0],
  [1222, 2074, 4783, 15410, 32768, 0]],
  [[19575, 21766, 26044, 29709, 32768, 0],
  [7297, 10767, 19273, 28194, 32768, 0]]]
];
const Default_Eob_Pt_32_Cdf = [
  [[[400, 520, 977, 2102, 6542, 32768, 0],
  [210, 405, 1315, 3326, 7537, 32768, 0]],
  [[2636, 4273, 7588, 11794, 20401, 32768, 0],
  [1786, 3179, 6902, 11357, 19054, 32768, 0]]],
  [[[989, 1249, 2019, 4151, 10785, 32768, 0],
  [313, 441, 1099, 2917, 8562, 32768, 0]],
  [[8394, 10352, 13932, 18855, 26014, 32768, 0],
  [2578, 4124, 8181, 13670, 24234, 32768, 0]]],
  [[[2515, 3003, 4452, 8162, 16041, 32768, 0],
  [574, 821, 1836, 5089, 13128, 32768, 0]],
  [[13468, 16303, 20361, 25105, 29281, 32768, 0],
  [3542, 5502, 10415, 16760, 25644, 32768, 0]]],
  [[[4617, 5709, 8446, 13584, 23135, 32768, 0],
  [1156, 1702, 3675, 9274, 20539, 32768, 0]],
  [[22086, 24282, 27010, 29770, 31743, 32768, 0],
  [7699, 10897, 20891, 26926, 31628, 32768, 0]]]
];
const Default_Eob_Pt_64_Cdf = [
  [[[329, 498, 1101, 1784, 3265, 7758, 32768, 0],
  [335, 730, 1459, 5494, 8755, 12997, 32768, 0]],
  [[3505, 5304, 10086, 13814, 17684, 23370, 32768, 0],
  [1563, 2700, 4876, 10911, 14706, 22480, 32768, 0]]],
  [[[1260, 1446, 2253, 3712, 6652, 13369, 32768, 0],
  [401, 605, 1029, 2563, 5845, 12626, 32768, 0]],
  [[8609, 10612, 14624, 18714, 22614, 29024, 32768, 0],
  [1923, 3127, 5867, 9703, 14277, 27100, 32768, 0]]],
  [[[2374, 2772, 4583, 7276, 12288, 19706, 32768, 0],
  [497, 810, 1315, 3000, 7004, 15641, 32768, 0]],
  [[15050, 17126, 21410, 24886, 28156, 30726, 32768, 0],
  [4034, 6290, 10235, 14982, 21214, 28491, 32768, 0]]],
  [[[6307, 7541, 12060, 16358, 22553, 27865, 32768, 0],
  [1289, 2320, 3971, 7926, 14153, 24291, 32768, 0]],
  [[24212, 25708, 28268, 30035, 31307, 32049, 32768, 0],
  [8726, 12378, 19409, 26450, 30038, 32462, 32768, 0]]]
];
const Default_Eob_Pt_128_Cdf = [
  [[[219, 482, 1140, 2091, 3680, 6028, 12586, 32768, 0],
  [371, 699, 1254, 4830, 9479, 12562, 17497, 32768, 0]],
  [[5245, 7456, 12880, 15852, 20033, 23932, 27608, 32768, 0],
  [2054, 3472, 5869, 14232, 18242, 20590, 26752, 32768, 0]]],
  [[[685, 933, 1488, 2714, 4766, 8562, 19254, 32768, 0],
  [217, 352, 618, 2303, 5261, 9969, 17472, 32768, 0]],
  [[8045, 11200, 15497, 19595, 23948, 27408, 30938, 32768, 0],
  [2310, 4160, 7471, 14997, 17931, 20768, 30240, 32768, 0]]],
  [[[1366, 1738, 2527, 5016, 9355, 15797, 24643, 32768, 0],
  [354, 558, 944, 2760, 7287, 14037, 21779, 32768, 0]],
  [[13627, 16246, 20173, 24429, 27948, 30415, 31863, 32768, 0],
  [6275, 9889, 14769, 23164, 27988, 30493, 32272, 32768, 0]]],
  [[[3472, 4885, 7489, 12481, 18517, 24536, 29635, 32768, 0],
  [886, 1731, 3271, 8469, 15569, 22126, 28383, 32768, 0]],
  [[24313, 26062, 28385, 30107, 31217, 31898, 32345, 32768, 0],
  [9165, 13282, 21150, 30286, 31894, 32571, 32712, 32768, 0]]]
];
const Default_Eob_Pt_256_Cdf = [
  [[[310, 584, 1887, 3589, 6168, 8611, 11352, 15652, 32768, 0],
  [998, 1850, 2998, 5604, 17341, 19888, 22899, 25583, 32768, 0]],
  [[2520, 3240, 5952, 8870, 12577, 17558, 19954, 24168, 32768, 0],
  [2203, 4130, 7435, 10739, 20652, 23681, 25609, 27261, 32768, 0]]],
  [[[1448, 2109, 4151, 6263, 9329, 13260, 17944, 23300, 32768, 0],
  [399, 1019, 1749, 3038, 10444, 15546, 22739, 27294, 32768, 0]],
  [[6402, 8148, 12623, 15072, 18728, 22847, 26447, 29377, 32768, 0],
  [1674, 3252, 5734, 10159, 22397, 23802, 24821, 30940, 32768, 0]]],
  [[[3089, 3920, 6038, 9460, 14266, 19881, 25766, 29176, 32768, 0],
  [1084, 2358, 3488, 5122, 11483, 18103, 26023, 29799, 32768, 0]],
  [[11514, 13794, 17480, 20754, 24361, 27378, 29492, 31277, 32768, 0],
  [6571, 9610, 15516, 21826, 29092, 30829, 31842, 32708, 32768, 0]]],
  [[[5348, 7113, 11820, 15924, 22106, 26777, 30334, 31757, 32768, 0],
  [2453, 4474, 6307, 8777, 16474, 22975, 29000, 31547, 32768, 0]],
  [[23110, 24597, 27140, 28894, 30167, 30927, 31392, 32094, 32768, 0],
  [9998, 17661, 25178, 28097, 31308, 32038, 32403, 32695, 32768, 0]]]
];
const Default_Eob_Pt_512_Cdf = [
  [[641, 983, 3707, 5430, 10234, 14958, 18788, 23412, 26061, 32768, 0],
  [5095, 6446, 9996, 13354, 16017, 17986, 20919, 26129, 29140, 32768, 0]],
  [[1230, 2278, 5035, 7776, 11871, 15346, 19590, 24584, 28749, 32768, 0],
  [7265, 9979, 15819, 19250, 21780, 23846, 26478, 28396, 31811, 32768, 0]],
  [[2624, 3936, 6480, 9686, 13979, 17726, 23267, 28410, 31078, 32768, 0],
  [12015, 14769, 19588, 22052, 24222, 25812, 27300, 29219, 32114, 32768, 0]],
  [[5927, 7809, 10923, 14597, 19439, 24135, 28456, 31142, 32060, 32768, 0],
  [21093, 23043, 25742, 27658, 29097, 29716, 30073, 30820, 31956, 32768, 0]]
];
const Default_Eob_Pt_1024_Cdf = [
  [[393, 421, 751, 1623, 3160, 6352, 13345, 18047, 22571, 25830, 32768, 0],
  [1865, 1988, 2930, 4242, 10533, 16538, 21354, 27255, 28546, 31784, 32768, 0]],
  [[696, 948, 3145, 5702, 9706, 13217, 17851, 21856, 25692, 28034, 32768, 0],
  [2672, 3591, 9330, 17084, 22725, 24284, 26527, 28027, 28377, 30876, 32768, 0]],
  [[2784, 3831, 7041, 10521, 14847, 18844, 23155, 26682, 29229, 31045, 32768, 0],
  [9577, 12466, 17739, 20750, 22061, 23215, 24601, 25483, 25843, 32056, 32768, 0]],
  [[6698, 8334, 11961, 15762, 20186, 23862, 27434, 29326, 31082, 32050, 32768, 0],
  [20569, 22426, 25569, 26859, 28053, 28913, 29486, 29724, 29807, 32570, 32768, 0]]
];
const Default_Eob_Extra_Cdf = [
  [[[[16961, 32768, 0], [17223, 32768, 0], [7621, 32768, 0],
  [16384, 32768, 0], [16384, 32768, 0], [16384, 32768, 0],
  [16384, 32768, 0], [16384, 32768, 0], [16384, 32768, 0]
  ],
  [[19069, 32768, 0], [22525, 32768, 0], [13377, 32768, 0],
  [16384, 32768, 0], [16384, 32768, 0], [16384, 32768, 0],
  [16384, 32768, 0], [16384, 32768, 0], [16384, 32768, 0]
  ]],
  [[[20401, 32768, 0], [17025, 32768, 0], [12845, 32768, 0],
  [12873, 32768, 0], [14094, 32768, 0], [16384, 32768, 0],
  [16384, 32768, 0], [16384, 32768, 0], [16384, 32768, 0]
  ],
  [[20681, 32768, 0], [20701, 32768, 0], [15250, 32768, 0],
  [15017, 32768, 0], [14928, 32768, 0], [16384, 32768, 0],
  [16384, 32768, 0], [16384, 32768, 0], [16384, 32768, 0]
  ]],
  [[[23905, 32768, 0], [17194, 32768, 0], [16170, 32768, 0],
  [17695, 32768, 0], [13826, 32768, 0], [15810, 32768, 0],
  [12036, 32768, 0], [16384, 32768, 0], [16384, 32768, 0]
  ],
  [[23959, 32768, 0], [20799, 32768, 0], [19021, 32768, 0],
  [16203, 32768, 0], [17886, 32768, 0], [14144, 32768, 0],
  [12010, 32768, 0], [16384, 32768, 0], [16384, 32768, 0]
  ]],
  [[[27399, 32768, 0], [16327, 32768, 0], [18071, 32768, 0],
  [19584, 32768, 0], [20721, 32768, 0], [18432, 32768, 0],
  [19560, 32768, 0], [10150, 32768, 0], [8805, 32768, 0]
  ],
  [[24932, 32768, 0], [20833, 32768, 0], [12027, 32768, 0],
  [16670, 32768, 0], [19914, 32768, 0], [15106, 32768, 0],
  [17662, 32768, 0], [13783, 32768, 0], [28756, 32768, 0]
  ]],
  [[[23406, 32768, 0], [21845, 32768, 0], [18432, 32768, 0],
  [16384, 32768, 0], [17096, 32768, 0], [12561, 32768, 0],
  [17320, 32768, 0], [22395, 32768, 0], [21370, 32768, 0]
  ],
  [[16384, 32768, 0], [16384, 32768, 0], [16384, 32768, 0],
  [16384, 32768, 0], [16384, 32768, 0], [16384, 32768, 0],
  [16384, 32768, 0], [16384, 32768, 0], [16384, 32768, 0]
  ]]],
  [[[[17471, 32768, 0], [20223, 32768, 0], [11357, 32768, 0],
  [16384, 32768, 0], [16384, 32768, 0], [16384, 32768, 0],
  [16384, 32768, 0], [16384, 32768, 0], [16384, 32768, 0]
  ],
  [[20335, 32768, 0], [21667, 32768, 0], [14818, 32768, 0],
  [16384, 32768, 0], [16384, 32768, 0], [16384, 32768, 0],
  [16384, 32768, 0], [16384, 32768, 0], [16384, 32768, 0]
  ]],
  [[[20430, 32768, 0], [20662, 32768, 0], [15367, 32768, 0],
  [16970, 32768, 0], [14657, 32768, 0], [16384, 32768, 0],
  [16384, 32768, 0], [16384, 32768, 0], [16384, 32768, 0]
  ],
  [[22117, 32768, 0], [22028, 32768, 0], [18650, 32768, 0],
  [16042, 32768, 0], [15885, 32768, 0], [16384, 32768, 0],
  [16384, 32768, 0], [16384, 32768, 0], [16384, 32768, 0]
  ]],
  [[[22409, 32768, 0], [21012, 32768, 0], [15650, 32768, 0],
  [17395, 32768, 0], [15469, 32768, 0], [20205, 32768, 0],
  [19511, 32768, 0], [16384, 32768, 0], [16384, 32768, 0]
  ],
  [[24220, 32768, 0], [22480, 32768, 0], [17737, 32768, 0],
  [18916, 32768, 0], [19268, 32768, 0], [18412, 32768, 0],
  [18844, 32768, 0], [16384, 32768, 0], [16384, 32768, 0]
  ]],
  [[[25991, 32768, 0], [20314, 32768, 0], [17731, 32768, 0],
  [19678, 32768, 0], [18649, 32768, 0], [17307, 32768, 0],
  [21798, 32768, 0], [17549, 32768, 0], [15630, 32768, 0]
  ],
  [[26585, 32768, 0], [21469, 32768, 0], [20432, 32768, 0],
  [17735, 32768, 0], [19280, 32768, 0], [15235, 32768, 0],
  [20297, 32768, 0], [22471, 32768, 0], [28997, 32768, 0]
  ]],
  [[[26605, 32768, 0], [11304, 32768, 0], [16726, 32768, 0],
  [16560, 32768, 0], [20866, 32768, 0], [23524, 32768, 0],
  [19878, 32768, 0], [13469, 32768, 0], [23084, 32768, 0]
  ],
  [[16384, 32768, 0], [16384, 32768, 0], [16384, 32768, 0],
  [16384, 32768, 0], [16384, 32768, 0], [16384, 32768, 0],
  [16384, 32768, 0], [16384, 32768, 0], [16384, 32768, 0]
  ]]],
  [[[[18983, 32768, 0], [20512, 32768, 0], [14885, 32768, 0],
  [16384, 32768, 0], [16384, 32768, 0], [16384, 32768, 0],
  [16384, 32768, 0], [16384, 32768, 0], [16384, 32768, 0]
  ],
  [[20090, 32768, 0], [19444, 32768, 0], [17286, 32768, 0],
  [16384, 32768, 0], [16384, 32768, 0], [16384, 32768, 0],
  [16384, 32768, 0], [16384, 32768, 0], [16384, 32768, 0]
  ]],
  [[[19139, 32768, 0], [21487, 32768, 0], [18959, 32768, 0],
  [20910, 32768, 0], [19089, 32768, 0], [16384, 32768, 0],
  [16384, 32768, 0], [16384, 32768, 0], [16384, 32768, 0]
  ],
  [[20536, 32768, 0], [20664, 32768, 0], [20625, 32768, 0],
  [19123, 32768, 0], [14862, 32768, 0], [16384, 32768, 0],
  [16384, 32768, 0], [16384, 32768, 0], [16384, 32768, 0]
  ]],
  [[[19833, 32768, 0], [21502, 32768, 0], [17485, 32768, 0],
  [20267, 32768, 0], [18353, 32768, 0], [23329, 32768, 0],
  [21478, 32768, 0], [16384, 32768, 0], [16384, 32768, 0]
  ],
  [[22041, 32768, 0], [23434, 32768, 0], [20001, 32768, 0],
  [20554, 32768, 0], [20951, 32768, 0], [20145, 32768, 0],
  [15562, 32768, 0], [16384, 32768, 0], [16384, 32768, 0]
  ]],
  [[[23312, 32768, 0], [21607, 32768, 0], [16526, 32768, 0],
  [18957, 32768, 0], [18034, 32768, 0], [18934, 32768, 0],
  [24247, 32768, 0], [16921, 32768, 0], [17080, 32768, 0]
  ],
  [[26579, 32768, 0], [24910, 32768, 0], [18637, 32768, 0],
  [19800, 32768, 0], [20388, 32768, 0], [9887, 32768, 0],
  [15642, 32768, 0], [30198, 32768, 0], [24721, 32768, 0]
  ]],
  [[[26998, 32768, 0], [16737, 32768, 0], [17838, 32768, 0],
  [18922, 32768, 0], [19515, 32768, 0], [18636, 32768, 0],
  [17333, 32768, 0], [15776, 32768, 0], [22658, 32768, 0]
  ],
  [[16384, 32768, 0], [16384, 32768, 0], [16384, 32768, 0],
  [16384, 32768, 0], [16384, 32768, 0], [16384, 32768, 0],
  [16384, 32768, 0], [16384, 32768, 0], [16384, 32768, 0]
  ]]],
  [[[[20177, 32768, 0], [20789, 32768, 0], [20262, 32768, 0],
  [16384, 32768, 0], [16384, 32768, 0], [16384, 32768, 0],
  [16384, 32768, 0], [16384, 32768, 0], [16384, 32768, 0]
  ],
  [[21416, 32768, 0], [20855, 32768, 0], [23410, 32768, 0],
  [16384, 32768, 0], [16384, 32768, 0], [16384, 32768, 0],
  [16384, 32768, 0], [16384, 32768, 0], [16384, 32768, 0]
  ]],
  [[[20238, 32768, 0], [21057, 32768, 0], [19159, 32768, 0],
  [22337, 32768, 0], [20159, 32768, 0], [16384, 32768, 0],
  [16384, 32768, 0], [16384, 32768, 0], [16384, 32768, 0]
  ],
  [[20125, 32768, 0], [20559, 32768, 0], [21707, 32768, 0],
  [22296, 32768, 0], [17333, 32768, 0], [16384, 32768, 0],
  [16384, 32768, 0], [16384, 32768, 0], [16384, 32768, 0]
  ]],
  [[[19941, 32768, 0], [20527, 32768, 0], [21470, 32768, 0],
  [22487, 32768, 0], [19558, 32768, 0], [22354, 32768, 0],
  [20331, 32768, 0], [16384, 32768, 0], [16384, 32768, 0]
  ],
  [[22752, 32768, 0], [25006, 32768, 0], [22075, 32768, 0],
  [21576, 32768, 0], [17740, 32768, 0], [21690, 32768, 0],
  [19211, 32768, 0], [16384, 32768, 0], [16384, 32768, 0]
  ]],
  [[[21442, 32768, 0], [22358, 32768, 0], [18503, 32768, 0],
  [20291, 32768, 0], [19945, 32768, 0], [21294, 32768, 0],
  [21178, 32768, 0], [19400, 32768, 0], [10556, 32768, 0]
  ],
  [[24648, 32768, 0], [24949, 32768, 0], [20708, 32768, 0],
  [23905, 32768, 0], [20501, 32768, 0], [9558, 32768, 0],
  [9423, 32768, 0], [30365, 32768, 0], [19253, 32768, 0]
  ]],
  [[[26064, 32768, 0], [22098, 32768, 0], [19613, 32768, 0],
  [20525, 32768, 0], [17595, 32768, 0], [16618, 32768, 0],
  [20497, 32768, 0], [18989, 32768, 0], [15513, 32768, 0]
  ],
  [[16384, 32768, 0], [16384, 32768, 0], [16384, 32768, 0],
  [16384, 32768, 0], [16384, 32768, 0], [16384, 32768, 0],
  [16384, 32768, 0], [16384, 32768, 0], [16384, 32768, 0]
  ]]]
];
const Default_Dc_Sign_Cdf = [
  [[
    [128 * 125, 32768, 0],
    [128 * 102, 32768, 0],
    [128 * 147, 32768, 0],
  ],
  [
    [128 * 119, 32768, 0],
    [128 * 101, 32768, 0],
    [128 * 135, 32768, 0],
  ]],
  [[
    [128 * 125, 32768, 0],
    [128 * 102, 32768, 0],
    [128 * 147, 32768, 0],
  ],
  [
    [128 * 119, 32768, 0],
    [128 * 101, 32768, 0],
    [128 * 135, 32768, 0],
  ]],
  [[
    [128 * 125, 32768, 0],
    [128 * 102, 32768, 0],
    [128 * 147, 32768, 0],
  ],
  [
    [128 * 119, 32768, 0],
    [128 * 101, 32768, 0],
    [128 * 135, 32768, 0],
  ]],
  [[
    [128 * 125, 32768, 0],
    [128 * 102, 32768, 0],
    [128 * 147, 32768, 0],
  ],
  [
    [128 * 119, 32768, 0],
    [128 * 101, 32768, 0],
    [128 * 135, 32768, 0],
  ]]
];
const Default_Coeff_Base_Eob_Cdf = [
  [[[[17837, 29055, 32768, 0],
  [29600, 31446, 32768, 0],
  [30844, 31878, 32768, 0],
  [24926, 28948, 32768, 0]],
  [[21365, 30026, 32768, 0],
  [30512, 32423, 32768, 0],
  [31658, 32621, 32768, 0],
  [29630, 31881, 32768, 0]]],
  [[[5717, 26477, 32768, 0],
  [30491, 31703, 32768, 0],
  [31550, 32158, 32768, 0],
  [29648, 31491, 32768, 0]],
  [[12608, 27820, 32768, 0],
  [30680, 32225, 32768, 0],
  [30809, 32335, 32768, 0],
  [31299, 32423, 32768, 0]]],
  [[[1786, 12612, 32768, 0],
  [30663, 31625, 32768, 0],
  [32339, 32468, 32768, 0],
  [31148, 31833, 32768, 0]],
  [[18857, 23865, 32768, 0],
  [31428, 32428, 32768, 0],
  [31744, 32373, 32768, 0],
  [31775, 32526, 32768, 0]]],
  [[[1787, 2532, 32768, 0],
  [30832, 31662, 32768, 0],
  [31824, 32682, 32768, 0],
  [32133, 32569, 32768, 0]],
  [[13751, 22235, 32768, 0],
  [32089, 32409, 32768, 0],
  [27084, 27920, 32768, 0],
  [29291, 32594, 32768, 0]]],
  [[[1725, 3449, 32768, 0],
  [31102, 31935, 32768, 0],
  [32457, 32613, 32768, 0],
  [32412, 32649, 32768, 0]],
  [[10923, 21845, 32768, 0],
  [10923, 21845, 32768, 0],
  [10923, 21845, 32768, 0],
  [10923, 21845, 32768, 0]]]],
  [[[[17560, 29888, 32768, 0],
  [29671, 31549, 32768, 0],
  [31007, 32056, 32768, 0],
  [27286, 30006, 32768, 0]],
  [[26594, 31212, 32768, 0],
  [31208, 32582, 32768, 0],
  [31835, 32637, 32768, 0],
  [30595, 32206, 32768, 0]]],
  [[[15239, 29932, 32768, 0],
  [31315, 32095, 32768, 0],
  [32130, 32434, 32768, 0],
  [30864, 31996, 32768, 0]],
  [[26279, 30968, 32768, 0],
  [31142, 32495, 32768, 0],
  [31713, 32540, 32768, 0],
  [31929, 32594, 32768, 0]]],
  [[[2644, 25198, 32768, 0],
  [32038, 32451, 32768, 0],
  [32639, 32695, 32768, 0],
  [32166, 32518, 32768, 0]],
  [[17187, 27668, 32768, 0],
  [31714, 32550, 32768, 0],
  [32283, 32678, 32768, 0],
  [31930, 32563, 32768, 0]]],
  [[[1044, 2257, 32768, 0],
  [30755, 31923, 32768, 0],
  [32208, 32693, 32768, 0],
  [32244, 32615, 32768, 0]],
  [[21317, 26207, 32768, 0],
  [29133, 30868, 32768, 0],
  [29311, 31231, 32768, 0],
  [29657, 31087, 32768, 0]]],
  [[[478, 1834, 32768, 0],
  [31005, 31987, 32768, 0],
  [32317, 32724, 32768, 0],
  [30865, 32648, 32768, 0]],
  [[10923, 21845, 32768, 0],
  [10923, 21845, 32768, 0],
  [10923, 21845, 32768, 0],
  [10923, 21845, 32768, 0]]]],
  [[[[20092, 30774, 32768, 0],
  [30695, 32020, 32768, 0],
  [31131, 32103, 32768, 0],
  [28666, 30870, 32768, 0]],
  [[27258, 31095, 32768, 0],
  [31804, 32623, 32768, 0],
  [31763, 32528, 32768, 0],
  [31438, 32506, 32768, 0]]],
  [[[18049, 30489, 32768, 0],
  [31706, 32286, 32768, 0],
  [32163, 32473, 32768, 0],
  [31550, 32184, 32768, 0]],
  [[27116, 30842, 32768, 0],
  [31971, 32598, 32768, 0],
  [32088, 32576, 32768, 0],
  [32067, 32664, 32768, 0]]],
  [[[12854, 29093, 32768, 0],
  [32272, 32558, 32768, 0],
  [32667, 32729, 32768, 0],
  [32306, 32585, 32768, 0]],
  [[25476, 30366, 32768, 0],
  [32169, 32687, 32768, 0],
  [32479, 32689, 32768, 0],
  [31673, 32634, 32768, 0]]],
  [[[2809, 19301, 32768, 0],
  [32205, 32622, 32768, 0],
  [32338, 32730, 32768, 0],
  [31786, 32616, 32768, 0]],
  [[22737, 29105, 32768, 0],
  [30810, 32362, 32768, 0],
  [30014, 32627, 32768, 0],
  [30528, 32574, 32768, 0]]],
  [[[935, 3382, 32768, 0],
  [30789, 31909, 32768, 0],
  [32466, 32756, 32768, 0],
  [30860, 32513, 32768, 0]],
  [[10923, 21845, 32768, 0],
  [10923, 21845, 32768, 0],
  [10923, 21845, 32768, 0],
  [10923, 21845, 32768, 0]]]],
  [[[[22497, 31198, 32768, 0],
  [31715, 32495, 32768, 0],
  [31606, 32337, 32768, 0],
  [30388, 31990, 32768, 0]],
  [[27877, 31584, 32768, 0],
  [32170, 32728, 32768, 0],
  [32155, 32688, 32768, 0],
  [32219, 32702, 32768, 0]]],
  [[[21457, 31043, 32768, 0],
  [31951, 32483, 32768, 0],
  [32153, 32562, 32768, 0],
  [31473, 32215, 32768, 0]],
  [[27558, 31151, 32768, 0],
  [32020, 32640, 32768, 0],
  [32097, 32575, 32768, 0],
  [32242, 32719, 32768, 0]]],
  [[[19980, 30591, 32768, 0],
  [32219, 32597, 32768, 0],
  [32581, 32706, 32768, 0],
  [31803, 32287, 32768, 0]],
  [[26473, 30507, 32768, 0],
  [32431, 32723, 32768, 0],
  [32196, 32611, 32768, 0],
  [31588, 32528, 32768, 0]]],
  [[[24647, 30463, 32768, 0],
  [32412, 32695, 32768, 0],
  [32468, 32720, 32768, 0],
  [31269, 32523, 32768, 0]],
  [[28482, 31505, 32768, 0],
  [32152, 32701, 32768, 0],
  [31732, 32598, 32768, 0],
  [31767, 32712, 32768, 0]]],
  [[[12358, 24977, 32768, 0],
  [31331, 32385, 32768, 0],
  [32634, 32756, 32768, 0],
  [30411, 32548, 32768, 0]],
  [[10923, 21845, 32768, 0],
  [10923, 21845, 32768, 0],
  [10923, 21845, 32768, 0],
  [10923, 21845, 32768, 0]]]]
];
const Default_Coeff_Base_Cdf = [
  [[[[4034, 8930, 12727, 32768, 0],
  [18082, 29741, 31877, 32768, 0],
  [12596, 26124, 30493, 32768, 0],
  [9446, 21118, 27005, 32768, 0],
  [6308, 15141, 21279, 32768, 0],
  [2463, 6357, 9783, 32768, 0],
  [20667, 30546, 31929, 32768, 0],
  [13043, 26123, 30134, 32768, 0],
  [8151, 18757, 24778, 32768, 0],
  [5255, 12839, 18632, 32768, 0],
  [2820, 7206, 11161, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [15736, 27553, 30604, 32768, 0],
  [11210, 23794, 28787, 32768, 0],
  [5947, 13874, 19701, 32768, 0],
  [4215, 9323, 13891, 32768, 0],
  [2833, 6462, 10059, 32768, 0],
  [19605, 30393, 31582, 32768, 0],
  [13523, 26252, 30248, 32768, 0],
  [8446, 18622, 24512, 32768, 0],
  [3818, 10343, 15974, 32768, 0],
  [1481, 4117, 6796, 32768, 0],
  [22649, 31302, 32190, 32768, 0],
  [14829, 27127, 30449, 32768, 0],
  [8313, 17702, 23304, 32768, 0],
  [3022, 8301, 12786, 32768, 0],
  [1536, 4412, 7184, 32768, 0],
  [22354, 29774, 31372, 32768, 0],
  [14723, 25472, 29214, 32768, 0],
  [6673, 13745, 18662, 32768, 0],
  [2068, 5766, 9322, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0]],
  [[6302, 16444, 21761, 32768, 0],
  [23040, 31538, 32475, 32768, 0],
  [15196, 28452, 31496, 32768, 0],
  [10020, 22946, 28514, 32768, 0],
  [6533, 16862, 23501, 32768, 0],
  [3538, 9816, 15076, 32768, 0],
  [24444, 31875, 32525, 32768, 0],
  [15881, 28924, 31635, 32768, 0],
  [9922, 22873, 28466, 32768, 0],
  [6527, 16966, 23691, 32768, 0],
  [4114, 11303, 17220, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [20201, 30770, 32209, 32768, 0],
  [14754, 28071, 31258, 32768, 0],
  [8378, 20186, 26517, 32768, 0],
  [5916, 15299, 21978, 32768, 0],
  [4268, 11583, 17901, 32768, 0],
  [24361, 32025, 32581, 32768, 0],
  [18673, 30105, 31943, 32768, 0],
  [10196, 22244, 27576, 32768, 0],
  [5495, 14349, 20417, 32768, 0],
  [2676, 7415, 11498, 32768, 0],
  [24678, 31958, 32585, 32768, 0],
  [18629, 29906, 31831, 32768, 0],
  [9364, 20724, 26315, 32768, 0],
  [4641, 12318, 18094, 32768, 0],
  [2758, 7387, 11579, 32768, 0],
  [25433, 31842, 32469, 32768, 0],
  [18795, 29289, 31411, 32768, 0],
  [7644, 17584, 23592, 32768, 0],
  [3408, 9014, 15047, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0]]],
  [[[4536, 10072, 14001, 32768, 0],
  [25459, 31416, 32206, 32768, 0],
  [16605, 28048, 30818, 32768, 0],
  [11008, 22857, 27719, 32768, 0],
  [6915, 16268, 22315, 32768, 0],
  [2625, 6812, 10537, 32768, 0],
  [24257, 31788, 32499, 32768, 0],
  [16880, 29454, 31879, 32768, 0],
  [11958, 25054, 29778, 32768, 0],
  [7916, 18718, 25084, 32768, 0],
  [3383, 8777, 13446, 32768, 0],
  [22720, 31603, 32393, 32768, 0],
  [14960, 28125, 31335, 32768, 0],
  [9731, 22210, 27928, 32768, 0],
  [6304, 15832, 22277, 32768, 0],
  [2910, 7818, 12166, 32768, 0],
  [20375, 30627, 32131, 32768, 0],
  [13904, 27284, 30887, 32768, 0],
  [9368, 21558, 27144, 32768, 0],
  [5937, 14966, 21119, 32768, 0],
  [2667, 7225, 11319, 32768, 0],
  [23970, 31470, 32378, 32768, 0],
  [17173, 29734, 32018, 32768, 0],
  [12795, 25441, 29965, 32768, 0],
  [8981, 19680, 25893, 32768, 0],
  [4728, 11372, 16902, 32768, 0],
  [24287, 31797, 32439, 32768, 0],
  [16703, 29145, 31696, 32768, 0],
  [10833, 23554, 28725, 32768, 0],
  [6468, 16566, 23057, 32768, 0],
  [2415, 6562, 10278, 32768, 0],
  [26610, 32395, 32659, 32768, 0],
  [18590, 30498, 32117, 32768, 0],
  [12420, 25756, 29950, 32768, 0],
  [7639, 18746, 24710, 32768, 0],
  [3001, 8086, 12347, 32768, 0],
  [25076, 32064, 32580, 32768, 0],
  [17946, 30128, 32028, 32768, 0],
  [12024, 24985, 29378, 32768, 0],
  [7517, 18390, 24304, 32768, 0],
  [3243, 8781, 13331, 32768, 0],
  [8192, 16384, 24576, 32768, 0]],
  [[6037, 16771, 21957, 32768, 0],
  [24774, 31704, 32426, 32768, 0],
  [16830, 28589, 31056, 32768, 0],
  [10602, 22828, 27760, 32768, 0],
  [6733, 16829, 23071, 32768, 0],
  [3250, 8914, 13556, 32768, 0],
  [25582, 32220, 32668, 32768, 0],
  [18659, 30342, 32223, 32768, 0],
  [12546, 26149, 30515, 32768, 0],
  [8420, 20451, 26801, 32768, 0],
  [4636, 12420, 18344, 32768, 0],
  [27581, 32362, 32639, 32768, 0],
  [18987, 30083, 31978, 32768, 0],
  [11327, 24248, 29084, 32768, 0],
  [7264, 17719, 24120, 32768, 0],
  [3995, 10768, 16169, 32768, 0],
  [25893, 31831, 32487, 32768, 0],
  [16577, 28587, 31379, 32768, 0],
  [10189, 22748, 28182, 32768, 0],
  [6832, 17094, 23556, 32768, 0],
  [3708, 10110, 15334, 32768, 0],
  [25904, 32282, 32656, 32768, 0],
  [19721, 30792, 32276, 32768, 0],
  [12819, 26243, 30411, 32768, 0],
  [8572, 20614, 26891, 32768, 0],
  [5364, 14059, 20467, 32768, 0],
  [26580, 32438, 32677, 32768, 0],
  [20852, 31225, 32340, 32768, 0],
  [12435, 25700, 29967, 32768, 0],
  [8691, 20825, 26976, 32768, 0],
  [4446, 12209, 17269, 32768, 0],
  [27350, 32429, 32696, 32768, 0],
  [21372, 30977, 32272, 32768, 0],
  [12673, 25270, 29853, 32768, 0],
  [9208, 20925, 26640, 32768, 0],
  [5018, 13351, 18732, 32768, 0],
  [27351, 32479, 32713, 32768, 0],
  [21398, 31209, 32387, 32768, 0],
  [12162, 25047, 29842, 32768, 0],
  [7896, 18691, 25319, 32768, 0],
  [4670, 12882, 18881, 32768, 0],
  [8192, 16384, 24576, 32768, 0]]],
  [[[5487, 10460, 13708, 32768, 0],
  [21597, 28303, 30674, 32768, 0],
  [11037, 21953, 26476, 32768, 0],
  [8147, 17962, 22952, 32768, 0],
  [5242, 13061, 18532, 32768, 0],
  [1889, 5208, 8182, 32768, 0],
  [26774, 32133, 32590, 32768, 0],
  [17844, 29564, 31767, 32768, 0],
  [11690, 24438, 29171, 32768, 0],
  [7542, 18215, 24459, 32768, 0],
  [2993, 8050, 12319, 32768, 0],
  [28023, 32328, 32591, 32768, 0],
  [18651, 30126, 31954, 32768, 0],
  [12164, 25146, 29589, 32768, 0],
  [7762, 18530, 24771, 32768, 0],
  [3492, 9183, 13920, 32768, 0],
  [27591, 32008, 32491, 32768, 0],
  [17149, 28853, 31510, 32768, 0],
  [11485, 24003, 28860, 32768, 0],
  [7697, 18086, 24210, 32768, 0],
  [3075, 7999, 12218, 32768, 0],
  [28268, 32482, 32654, 32768, 0],
  [19631, 31051, 32404, 32768, 0],
  [13860, 27260, 31020, 32768, 0],
  [9605, 21613, 27594, 32768, 0],
  [4876, 12162, 17908, 32768, 0],
  [27248, 32316, 32576, 32768, 0],
  [18955, 30457, 32075, 32768, 0],
  [11824, 23997, 28795, 32768, 0],
  [7346, 18196, 24647, 32768, 0],
  [3403, 9247, 14111, 32768, 0],
  [29711, 32655, 32735, 32768, 0],
  [21169, 31394, 32417, 32768, 0],
  [13487, 27198, 30957, 32768, 0],
  [8828, 21683, 27614, 32768, 0],
  [4270, 11451, 17038, 32768, 0],
  [28708, 32578, 32731, 32768, 0],
  [20120, 31241, 32482, 32768, 0],
  [13692, 27550, 31321, 32768, 0],
  [9418, 22514, 28439, 32768, 0],
  [4999, 13283, 19462, 32768, 0],
  [8192, 16384, 24576, 32768, 0]],
  [[5673, 14302, 19711, 32768, 0],
  [26251, 30701, 31834, 32768, 0],
  [12782, 23783, 27803, 32768, 0],
  [9127, 20657, 25808, 32768, 0],
  [6368, 16208, 21462, 32768, 0],
  [2465, 7177, 10822, 32768, 0],
  [29961, 32563, 32719, 32768, 0],
  [18318, 29891, 31949, 32768, 0],
  [11361, 24514, 29357, 32768, 0],
  [7900, 19603, 25607, 32768, 0],
  [4002, 10590, 15546, 32768, 0],
  [29637, 32310, 32595, 32768, 0],
  [18296, 29913, 31809, 32768, 0],
  [10144, 21515, 26871, 32768, 0],
  [5358, 14322, 20394, 32768, 0],
  [3067, 8362, 13346, 32768, 0],
  [28652, 32470, 32676, 32768, 0],
  [17538, 30771, 32209, 32768, 0],
  [13924, 26882, 30494, 32768, 0],
  [10496, 22837, 27869, 32768, 0],
  [7236, 16396, 21621, 32768, 0],
  [30743, 32687, 32746, 32768, 0],
  [23006, 31676, 32489, 32768, 0],
  [14494, 27828, 31120, 32768, 0],
  [10174, 22801, 28352, 32768, 0],
  [6242, 15281, 21043, 32768, 0],
  [25817, 32243, 32720, 32768, 0],
  [18618, 31367, 32325, 32768, 0],
  [13997, 28318, 31878, 32768, 0],
  [12255, 26534, 31383, 32768, 0],
  [9561, 21588, 28450, 32768, 0],
  [28188, 32635, 32724, 32768, 0],
  [22060, 32365, 32728, 32768, 0],
  [18102, 30690, 32528, 32768, 0],
  [14196, 28864, 31999, 32768, 0],
  [12262, 25792, 30865, 32768, 0],
  [24176, 32109, 32628, 32768, 0],
  [18280, 29681, 31963, 32768, 0],
  [10205, 23703, 29664, 32768, 0],
  [7889, 20025, 27676, 32768, 0],
  [6060, 16743, 23970, 32768, 0],
  [8192, 16384, 24576, 32768, 0]]],
  [[[5141, 7096, 8260, 32768, 0],
  [27186, 29022, 29789, 32768, 0],
  [6668, 12568, 15682, 32768, 0],
  [2172, 6181, 8638, 32768, 0],
  [1126, 3379, 4531, 32768, 0],
  [443, 1361, 2254, 32768, 0],
  [26083, 31153, 32436, 32768, 0],
  [13486, 24603, 28483, 32768, 0],
  [6508, 14840, 19910, 32768, 0],
  [3386, 8800, 13286, 32768, 0],
  [1530, 4322, 7054, 32768, 0],
  [29639, 32080, 32548, 32768, 0],
  [15897, 27552, 30290, 32768, 0],
  [8588, 20047, 25383, 32768, 0],
  [4889, 13339, 19269, 32768, 0],
  [2240, 6871, 10498, 32768, 0],
  [28165, 32197, 32517, 32768, 0],
  [20735, 30427, 31568, 32768, 0],
  [14325, 24671, 27692, 32768, 0],
  [5119, 12554, 17805, 32768, 0],
  [1810, 5441, 8261, 32768, 0],
  [31212, 32724, 32748, 32768, 0],
  [23352, 31766, 32545, 32768, 0],
  [14669, 27570, 31059, 32768, 0],
  [8492, 20894, 27272, 32768, 0],
  [3644, 10194, 15204, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0]],
  [[2461, 7013, 9371, 32768, 0],
  [24749, 29600, 30986, 32768, 0],
  [9466, 19037, 22417, 32768, 0],
  [3584, 9280, 14400, 32768, 0],
  [1505, 3929, 5433, 32768, 0],
  [677, 1500, 2736, 32768, 0],
  [23987, 30702, 32117, 32768, 0],
  [13554, 24571, 29263, 32768, 0],
  [6211, 14556, 21155, 32768, 0],
  [3135, 10972, 15625, 32768, 0],
  [2435, 7127, 11427, 32768, 0],
  [31300, 32532, 32550, 32768, 0],
  [14757, 30365, 31954, 32768, 0],
  [4405, 11612, 18553, 32768, 0],
  [580, 4132, 7322, 32768, 0],
  [1695, 10169, 14124, 32768, 0],
  [30008, 32282, 32591, 32768, 0],
  [19244, 30108, 31748, 32768, 0],
  [11180, 24158, 29555, 32768, 0],
  [5650, 14972, 19209, 32768, 0],
  [2114, 5109, 8456, 32768, 0],
  [31856, 32716, 32748, 32768, 0],
  [23012, 31664, 32572, 32768, 0],
  [13694, 26656, 30636, 32768, 0],
  [8142, 19508, 26093, 32768, 0],
  [4253, 10955, 16724, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0]]],
  [[[601, 983, 1311, 32768, 0],
  [18725, 23406, 28087, 32768, 0],
  [5461, 8192, 10923, 32768, 0],
  [3781, 15124, 21425, 32768, 0],
  [2587, 7761, 12072, 32768, 0],
  [106, 458, 810, 32768, 0],
  [22282, 29710, 31894, 32768, 0],
  [8508, 20926, 25984, 32768, 0],
  [3726, 12713, 18083, 32768, 0],
  [1620, 7112, 10893, 32768, 0],
  [729, 2236, 3495, 32768, 0],
  [30163, 32474, 32684, 32768, 0],
  [18304, 30464, 32000, 32768, 0],
  [11443, 26526, 29647, 32768, 0],
  [6007, 15292, 21299, 32768, 0],
  [2234, 6703, 8937, 32768, 0],
  [30954, 32177, 32571, 32768, 0],
  [17363, 29562, 31076, 32768, 0],
  [9686, 22464, 27410, 32768, 0],
  [8192, 16384, 21390, 32768, 0],
  [1755, 8046, 11264, 32768, 0],
  [31168, 32734, 32748, 32768, 0],
  [22486, 31441, 32471, 32768, 0],
  [12833, 25627, 29738, 32768, 0],
  [6980, 17379, 23122, 32768, 0],
  [3111, 8887, 13479, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0]],
  [[8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0]]]],
  [[[[6041, 11854, 15927, 32768, 0],
  [20326, 30905, 32251, 32768, 0],
  [14164, 26831, 30725, 32768, 0],
  [9760, 20647, 26585, 32768, 0],
  [6416, 14953, 21219, 32768, 0],
  [2966, 7151, 10891, 32768, 0],
  [23567, 31374, 32254, 32768, 0],
  [14978, 27416, 30946, 32768, 0],
  [9434, 20225, 26254, 32768, 0],
  [6658, 14558, 20535, 32768, 0],
  [3916, 8677, 12989, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [18088, 29545, 31587, 32768, 0],
  [13062, 25843, 30073, 32768, 0],
  [8940, 16827, 22251, 32768, 0],
  [7654, 13220, 17973, 32768, 0],
  [5733, 10316, 14456, 32768, 0],
  [22879, 31388, 32114, 32768, 0],
  [15215, 27993, 30955, 32768, 0],
  [9397, 19445, 24978, 32768, 0],
  [3442, 9813, 15344, 32768, 0],
  [1368, 3936, 6532, 32768, 0],
  [25494, 32033, 32406, 32768, 0],
  [16772, 27963, 30718, 32768, 0],
  [9419, 18165, 23260, 32768, 0],
  [2677, 7501, 11797, 32768, 0],
  [1516, 4344, 7170, 32768, 0],
  [26556, 31454, 32101, 32768, 0],
  [17128, 27035, 30108, 32768, 0],
  [8324, 15344, 20249, 32768, 0],
  [1903, 5696, 9469, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0]],
  [[8455, 19003, 24368, 32768, 0],
  [23563, 32021, 32604, 32768, 0],
  [16237, 29446, 31935, 32768, 0],
  [10724, 23999, 29358, 32768, 0],
  [6725, 17528, 24416, 32768, 0],
  [3927, 10927, 16825, 32768, 0],
  [26313, 32288, 32634, 32768, 0],
  [17430, 30095, 32095, 32768, 0],
  [11116, 24606, 29679, 32768, 0],
  [7195, 18384, 25269, 32768, 0],
  [4726, 12852, 19315, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [22822, 31648, 32483, 32768, 0],
  [16724, 29633, 31929, 32768, 0],
  [10261, 23033, 28725, 32768, 0],
  [7029, 17840, 24528, 32768, 0],
  [4867, 13886, 21502, 32768, 0],
  [25298, 31892, 32491, 32768, 0],
  [17809, 29330, 31512, 32768, 0],
  [9668, 21329, 26579, 32768, 0],
  [4774, 12956, 18976, 32768, 0],
  [2322, 7030, 11540, 32768, 0],
  [25472, 31920, 32543, 32768, 0],
  [17957, 29387, 31632, 32768, 0],
  [9196, 20593, 26400, 32768, 0],
  [4680, 12705, 19202, 32768, 0],
  [2917, 8456, 13436, 32768, 0],
  [26471, 32059, 32574, 32768, 0],
  [18458, 29783, 31909, 32768, 0],
  [8400, 19464, 25956, 32768, 0],
  [3812, 10973, 17206, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0]]],
  [[[6779, 13743, 17678, 32768, 0],
  [24806, 31797, 32457, 32768, 0],
  [17616, 29047, 31372, 32768, 0],
  [11063, 23175, 28003, 32768, 0],
  [6521, 16110, 22324, 32768, 0],
  [2764, 7504, 11654, 32768, 0],
  [25266, 32367, 32637, 32768, 0],
  [19054, 30553, 32175, 32768, 0],
  [12139, 25212, 29807, 32768, 0],
  [7311, 18162, 24704, 32768, 0],
  [3397, 9164, 14074, 32768, 0],
  [25988, 32208, 32522, 32768, 0],
  [16253, 28912, 31526, 32768, 0],
  [9151, 21387, 27372, 32768, 0],
  [5688, 14915, 21496, 32768, 0],
  [2717, 7627, 12004, 32768, 0],
  [23144, 31855, 32443, 32768, 0],
  [16070, 28491, 31325, 32768, 0],
  [8702, 20467, 26517, 32768, 0],
  [5243, 13956, 20367, 32768, 0],
  [2621, 7335, 11567, 32768, 0],
  [26636, 32340, 32630, 32768, 0],
  [19990, 31050, 32341, 32768, 0],
  [13243, 26105, 30315, 32768, 0],
  [8588, 19521, 25918, 32768, 0],
  [4717, 11585, 17304, 32768, 0],
  [25844, 32292, 32582, 32768, 0],
  [19090, 30635, 32097, 32768, 0],
  [11963, 24546, 28939, 32768, 0],
  [6218, 16087, 22354, 32768, 0],
  [2340, 6608, 10426, 32768, 0],
  [28046, 32576, 32694, 32768, 0],
  [21178, 31313, 32296, 32768, 0],
  [13486, 26184, 29870, 32768, 0],
  [7149, 17871, 23723, 32768, 0],
  [2833, 7958, 12259, 32768, 0],
  [27710, 32528, 32686, 32768, 0],
  [20674, 31076, 32268, 32768, 0],
  [12413, 24955, 29243, 32768, 0],
  [6676, 16927, 23097, 32768, 0],
  [2966, 8333, 12919, 32768, 0],
  [8192, 16384, 24576, 32768, 0]],
  [[8639, 19339, 24429, 32768, 0],
  [24404, 31837, 32525, 32768, 0],
  [16997, 29425, 31784, 32768, 0],
  [11253, 24234, 29149, 32768, 0],
  [6751, 17394, 24028, 32768, 0],
  [3490, 9830, 15191, 32768, 0],
  [26283, 32471, 32714, 32768, 0],
  [19599, 31168, 32442, 32768, 0],
  [13146, 26954, 30893, 32768, 0],
  [8214, 20588, 26890, 32768, 0],
  [4699, 13081, 19300, 32768, 0],
  [28212, 32458, 32669, 32768, 0],
  [18594, 30316, 32100, 32768, 0],
  [11219, 24408, 29234, 32768, 0],
  [6865, 17656, 24149, 32768, 0],
  [3678, 10362, 16006, 32768, 0],
  [25825, 32136, 32616, 32768, 0],
  [17313, 29853, 32021, 32768, 0],
  [11197, 24471, 29472, 32768, 0],
  [6947, 17781, 24405, 32768, 0],
  [3768, 10660, 16261, 32768, 0],
  [27352, 32500, 32706, 32768, 0],
  [20850, 31468, 32469, 32768, 0],
  [14021, 27707, 31133, 32768, 0],
  [8964, 21748, 27838, 32768, 0],
  [5437, 14665, 21187, 32768, 0],
  [26304, 32492, 32698, 32768, 0],
  [20409, 31380, 32385, 32768, 0],
  [13682, 27222, 30632, 32768, 0],
  [8974, 21236, 26685, 32768, 0],
  [4234, 11665, 16934, 32768, 0],
  [26273, 32357, 32711, 32768, 0],
  [20672, 31242, 32441, 32768, 0],
  [14172, 27254, 30902, 32768, 0],
  [9870, 21898, 27275, 32768, 0],
  [5164, 13506, 19270, 32768, 0],
  [26725, 32459, 32728, 32768, 0],
  [20991, 31442, 32527, 32768, 0],
  [13071, 26434, 30811, 32768, 0],
  [8184, 20090, 26742, 32768, 0],
  [4803, 13255, 19895, 32768, 0],
  [8192, 16384, 24576, 32768, 0]]],
  [[[7555, 14942, 18501, 32768, 0],
  [24410, 31178, 32287, 32768, 0],
  [14394, 26738, 30253, 32768, 0],
  [8413, 19554, 25195, 32768, 0],
  [4766, 12924, 18785, 32768, 0],
  [2029, 5806, 9207, 32768, 0],
  [26776, 32364, 32663, 32768, 0],
  [18732, 29967, 31931, 32768, 0],
  [11005, 23786, 28852, 32768, 0],
  [6466, 16909, 23510, 32768, 0],
  [3044, 8638, 13419, 32768, 0],
  [29208, 32582, 32704, 32768, 0],
  [20068, 30857, 32208, 32768, 0],
  [12003, 25085, 29595, 32768, 0],
  [6947, 17750, 24189, 32768, 0],
  [3245, 9103, 14007, 32768, 0],
  [27359, 32465, 32669, 32768, 0],
  [19421, 30614, 32174, 32768, 0],
  [11915, 25010, 29579, 32768, 0],
  [6950, 17676, 24074, 32768, 0],
  [3007, 8473, 13096, 32768, 0],
  [29002, 32676, 32735, 32768, 0],
  [22102, 31849, 32576, 32768, 0],
  [14408, 28009, 31405, 32768, 0],
  [9027, 21679, 27931, 32768, 0],
  [4694, 12678, 18748, 32768, 0],
  [28216, 32528, 32682, 32768, 0],
  [20849, 31264, 32318, 32768, 0],
  [12756, 25815, 29751, 32768, 0],
  [7565, 18801, 24923, 32768, 0],
  [3509, 9533, 14477, 32768, 0],
  [30133, 32687, 32739, 32768, 0],
  [23063, 31910, 32515, 32768, 0],
  [14588, 28051, 31132, 32768, 0],
  [9085, 21649, 27457, 32768, 0],
  [4261, 11654, 17264, 32768, 0],
  [29518, 32691, 32748, 32768, 0],
  [22451, 31959, 32613, 32768, 0],
  [14864, 28722, 31700, 32768, 0],
  [9695, 22964, 28716, 32768, 0],
  [4932, 13358, 19502, 32768, 0],
  [8192, 16384, 24576, 32768, 0]],
  [[6465, 16958, 21688, 32768, 0],
  [25199, 31514, 32360, 32768, 0],
  [14774, 27149, 30607, 32768, 0],
  [9257, 21438, 26972, 32768, 0],
  [5723, 15183, 21882, 32768, 0],
  [3150, 8879, 13731, 32768, 0],
  [26989, 32262, 32682, 32768, 0],
  [17396, 29937, 32085, 32768, 0],
  [11387, 24901, 29784, 32768, 0],
  [7289, 18821, 25548, 32768, 0],
  [3734, 10577, 16086, 32768, 0],
  [29728, 32501, 32695, 32768, 0],
  [17431, 29701, 31903, 32768, 0],
  [9921, 22826, 28300, 32768, 0],
  [5896, 15434, 22068, 32768, 0],
  [3430, 9646, 14757, 32768, 0],
  [28614, 32511, 32705, 32768, 0],
  [19364, 30638, 32263, 32768, 0],
  [13129, 26254, 30402, 32768, 0],
  [8754, 20484, 26440, 32768, 0],
  [4378, 11607, 17110, 32768, 0],
  [30292, 32671, 32744, 32768, 0],
  [21780, 31603, 32501, 32768, 0],
  [14314, 27829, 31291, 32768, 0],
  [9611, 22327, 28263, 32768, 0],
  [4890, 13087, 19065, 32768, 0],
  [25862, 32567, 32733, 32768, 0],
  [20794, 32050, 32567, 32768, 0],
  [17243, 30625, 32254, 32768, 0],
  [13283, 27628, 31474, 32768, 0],
  [9669, 22532, 28918, 32768, 0],
  [27435, 32697, 32748, 32768, 0],
  [24922, 32390, 32714, 32768, 0],
  [21449, 31504, 32536, 32768, 0],
  [16392, 29729, 31832, 32768, 0],
  [11692, 24884, 29076, 32768, 0],
  [24193, 32290, 32735, 32768, 0],
  [18909, 31104, 32563, 32768, 0],
  [12236, 26841, 31403, 32768, 0],
  [8171, 21840, 29082, 32768, 0],
  [7224, 17280, 25275, 32768, 0],
  [8192, 16384, 24576, 32768, 0]]],
  [[[3078, 6839, 9890, 32768, 0],
  [13837, 20450, 24479, 32768, 0],
  [5914, 14222, 19328, 32768, 0],
  [3866, 10267, 14762, 32768, 0],
  [2612, 7208, 11042, 32768, 0],
  [1067, 2991, 4776, 32768, 0],
  [25817, 31646, 32529, 32768, 0],
  [13708, 26338, 30385, 32768, 0],
  [7328, 18585, 24870, 32768, 0],
  [4691, 13080, 19276, 32768, 0],
  [1825, 5253, 8352, 32768, 0],
  [29386, 32315, 32624, 32768, 0],
  [17160, 29001, 31360, 32768, 0],
  [9602, 21862, 27396, 32768, 0],
  [5915, 15772, 22148, 32768, 0],
  [2786, 7779, 12047, 32768, 0],
  [29246, 32450, 32663, 32768, 0],
  [18696, 29929, 31818, 32768, 0],
  [10510, 23369, 28560, 32768, 0],
  [6229, 16499, 23125, 32768, 0],
  [2608, 7448, 11705, 32768, 0],
  [30753, 32710, 32748, 32768, 0],
  [21638, 31487, 32503, 32768, 0],
  [12937, 26854, 30870, 32768, 0],
  [8182, 20596, 26970, 32768, 0],
  [3637, 10269, 15497, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0]],
  [[5244, 12150, 16906, 32768, 0],
  [20486, 26858, 29701, 32768, 0],
  [7756, 18317, 23735, 32768, 0],
  [3452, 9256, 13146, 32768, 0],
  [2020, 5206, 8229, 32768, 0],
  [1801, 4993, 7903, 32768, 0],
  [27051, 31858, 32531, 32768, 0],
  [15988, 27531, 30619, 32768, 0],
  [9188, 21484, 26719, 32768, 0],
  [6273, 17186, 23800, 32768, 0],
  [3108, 9355, 14764, 32768, 0],
  [31076, 32520, 32680, 32768, 0],
  [18119, 30037, 31850, 32768, 0],
  [10244, 22969, 27472, 32768, 0],
  [4692, 14077, 19273, 32768, 0],
  [3694, 11677, 17556, 32768, 0],
  [30060, 32581, 32720, 32768, 0],
  [21011, 30775, 32120, 32768, 0],
  [11931, 24820, 29289, 32768, 0],
  [7119, 17662, 24356, 32768, 0],
  [3833, 10706, 16304, 32768, 0],
  [31954, 32731, 32748, 32768, 0],
  [23913, 31724, 32489, 32768, 0],
  [15520, 28060, 31286, 32768, 0],
  [11517, 23008, 28571, 32768, 0],
  [6193, 14508, 20629, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0]]],
  [[[1035, 2807, 4156, 32768, 0],
  [13162, 18138, 20939, 32768, 0],
  [2696, 6633, 8755, 32768, 0],
  [1373, 4161, 6853, 32768, 0],
  [1099, 2746, 4716, 32768, 0],
  [340, 1021, 1599, 32768, 0],
  [22826, 30419, 32135, 32768, 0],
  [10395, 21762, 26942, 32768, 0],
  [4726, 12407, 17361, 32768, 0],
  [2447, 7080, 10593, 32768, 0],
  [1227, 3717, 6011, 32768, 0],
  [28156, 31424, 31934, 32768, 0],
  [16915, 27754, 30373, 32768, 0],
  [9148, 20990, 26431, 32768, 0],
  [5950, 15515, 21148, 32768, 0],
  [2492, 7327, 11526, 32768, 0],
  [30602, 32477, 32670, 32768, 0],
  [20026, 29955, 31568, 32768, 0],
  [11220, 23628, 28105, 32768, 0],
  [6652, 17019, 22973, 32768, 0],
  [3064, 8536, 13043, 32768, 0],
  [31769, 32724, 32748, 32768, 0],
  [22230, 30887, 32373, 32768, 0],
  [12234, 25079, 29731, 32768, 0],
  [7326, 18816, 25353, 32768, 0],
  [3933, 10907, 16616, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0]],
  [[8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0]]]],
  [[[[8896, 16227, 20630, 32768, 0],
  [23629, 31782, 32527, 32768, 0],
  [15173, 27755, 31321, 32768, 0],
  [10158, 21233, 27382, 32768, 0],
  [6420, 14857, 21558, 32768, 0],
  [3269, 8155, 12646, 32768, 0],
  [24835, 32009, 32496, 32768, 0],
  [16509, 28421, 31579, 32768, 0],
  [10957, 21514, 27418, 32768, 0],
  [7881, 15930, 22096, 32768, 0],
  [5388, 10960, 15918, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [20745, 30773, 32093, 32768, 0],
  [15200, 27221, 30861, 32768, 0],
  [13032, 20873, 25667, 32768, 0],
  [12285, 18663, 23494, 32768, 0],
  [11563, 17481, 21489, 32768, 0],
  [26260, 31982, 32320, 32768, 0],
  [15397, 28083, 31100, 32768, 0],
  [9742, 19217, 24824, 32768, 0],
  [3261, 9629, 15362, 32768, 0],
  [1480, 4322, 7499, 32768, 0],
  [27599, 32256, 32460, 32768, 0],
  [16857, 27659, 30774, 32768, 0],
  [9551, 18290, 23748, 32768, 0],
  [3052, 8933, 14103, 32768, 0],
  [2021, 5910, 9787, 32768, 0],
  [29005, 32015, 32392, 32768, 0],
  [17677, 27694, 30863, 32768, 0],
  [9204, 17356, 23219, 32768, 0],
  [2403, 7516, 12814, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0]],
  [[10808, 22056, 26896, 32768, 0],
  [25739, 32313, 32676, 32768, 0],
  [17288, 30203, 32221, 32768, 0],
  [11359, 24878, 29896, 32768, 0],
  [6949, 17767, 24893, 32768, 0],
  [4287, 11796, 18071, 32768, 0],
  [27880, 32521, 32705, 32768, 0],
  [19038, 31004, 32414, 32768, 0],
  [12564, 26345, 30768, 32768, 0],
  [8269, 19947, 26779, 32768, 0],
  [5674, 14657, 21674, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [25742, 32319, 32671, 32768, 0],
  [19557, 31164, 32454, 32768, 0],
  [13381, 26381, 30755, 32768, 0],
  [10101, 21466, 26722, 32768, 0],
  [9209, 19650, 26825, 32768, 0],
  [27107, 31917, 32432, 32768, 0],
  [18056, 28893, 31203, 32768, 0],
  [10200, 21434, 26764, 32768, 0],
  [4660, 12913, 19502, 32768, 0],
  [2368, 6930, 12504, 32768, 0],
  [26960, 32158, 32613, 32768, 0],
  [18628, 30005, 32031, 32768, 0],
  [10233, 22442, 28232, 32768, 0],
  [5471, 14630, 21516, 32768, 0],
  [3235, 10767, 17109, 32768, 0],
  [27696, 32440, 32692, 32768, 0],
  [20032, 31167, 32438, 32768, 0],
  [8700, 21341, 28442, 32768, 0],
  [5662, 14831, 21795, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0]]],
  [[[9704, 17294, 21132, 32768, 0],
  [26762, 32278, 32633, 32768, 0],
  [18382, 29620, 31819, 32768, 0],
  [10891, 23475, 28723, 32768, 0],
  [6358, 16583, 23309, 32768, 0],
  [3248, 9118, 14141, 32768, 0],
  [27204, 32573, 32699, 32768, 0],
  [19818, 30824, 32329, 32768, 0],
  [11772, 25120, 30041, 32768, 0],
  [6995, 18033, 25039, 32768, 0],
  [3752, 10442, 16098, 32768, 0],
  [27222, 32256, 32559, 32768, 0],
  [15356, 28399, 31475, 32768, 0],
  [8821, 20635, 27057, 32768, 0],
  [5511, 14404, 21239, 32768, 0],
  [2935, 8222, 13051, 32768, 0],
  [24875, 32120, 32529, 32768, 0],
  [15233, 28265, 31445, 32768, 0],
  [8605, 20570, 26932, 32768, 0],
  [5431, 14413, 21196, 32768, 0],
  [2994, 8341, 13223, 32768, 0],
  [28201, 32604, 32700, 32768, 0],
  [21041, 31446, 32456, 32768, 0],
  [13221, 26213, 30475, 32768, 0],
  [8255, 19385, 26037, 32768, 0],
  [4930, 12585, 18830, 32768, 0],
  [28768, 32448, 32627, 32768, 0],
  [19705, 30561, 32021, 32768, 0],
  [11572, 23589, 28220, 32768, 0],
  [5532, 15034, 21446, 32768, 0],
  [2460, 7150, 11456, 32768, 0],
  [29874, 32619, 32699, 32768, 0],
  [21621, 31071, 32201, 32768, 0],
  [12511, 24747, 28992, 32768, 0],
  [6281, 16395, 22748, 32768, 0],
  [3246, 9278, 14497, 32768, 0],
  [29715, 32625, 32712, 32768, 0],
  [20958, 31011, 32283, 32768, 0],
  [11233, 23671, 28806, 32768, 0],
  [6012, 16128, 22868, 32768, 0],
  [3427, 9851, 15414, 32768, 0],
  [8192, 16384, 24576, 32768, 0]],
  [[11016, 22111, 26794, 32768, 0],
  [25946, 32357, 32677, 32768, 0],
  [17890, 30452, 32252, 32768, 0],
  [11678, 25142, 29816, 32768, 0],
  [6720, 17534, 24584, 32768, 0],
  [4230, 11665, 17820, 32768, 0],
  [28400, 32623, 32747, 32768, 0],
  [21164, 31668, 32575, 32768, 0],
  [13572, 27388, 31182, 32768, 0],
  [8234, 20750, 27358, 32768, 0],
  [5065, 14055, 20897, 32768, 0],
  [28981, 32547, 32705, 32768, 0],
  [18681, 30543, 32239, 32768, 0],
  [10919, 24075, 29286, 32768, 0],
  [6431, 17199, 24077, 32768, 0],
  [3819, 10464, 16618, 32768, 0],
  [26870, 32467, 32693, 32768, 0],
  [19041, 30831, 32347, 32768, 0],
  [11794, 25211, 30016, 32768, 0],
  [6888, 18019, 24970, 32768, 0],
  [4370, 12363, 18992, 32768, 0],
  [29578, 32670, 32744, 32768, 0],
  [23159, 32007, 32613, 32768, 0],
  [15315, 28669, 31676, 32768, 0],
  [9298, 22607, 28782, 32768, 0],
  [6144, 15913, 22968, 32768, 0],
  [28110, 32499, 32669, 32768, 0],
  [21574, 30937, 32015, 32768, 0],
  [12759, 24818, 28727, 32768, 0],
  [6545, 16761, 23042, 32768, 0],
  [3649, 10597, 16833, 32768, 0],
  [28163, 32552, 32728, 32768, 0],
  [22101, 31469, 32464, 32768, 0],
  [13160, 25472, 30143, 32768, 0],
  [7303, 18684, 25468, 32768, 0],
  [5241, 13975, 20955, 32768, 0],
  [28400, 32631, 32744, 32768, 0],
  [22104, 31793, 32603, 32768, 0],
  [13557, 26571, 30846, 32768, 0],
  [7749, 19861, 26675, 32768, 0],
  [4873, 14030, 21234, 32768, 0],
  [8192, 16384, 24576, 32768, 0]]],
  [[[9800, 17635, 21073, 32768, 0],
  [26153, 31885, 32527, 32768, 0],
  [15038, 27852, 31006, 32768, 0],
  [8718, 20564, 26486, 32768, 0],
  [5128, 14076, 20514, 32768, 0],
  [2636, 7566, 11925, 32768, 0],
  [27551, 32504, 32701, 32768, 0],
  [18310, 30054, 32100, 32768, 0],
  [10211, 23420, 29082, 32768, 0],
  [6222, 16876, 23916, 32768, 0],
  [3462, 9954, 15498, 32768, 0],
  [29991, 32633, 32721, 32768, 0],
  [19883, 30751, 32201, 32768, 0],
  [11141, 24184, 29285, 32768, 0],
  [6420, 16940, 23774, 32768, 0],
  [3392, 9753, 15118, 32768, 0],
  [28465, 32616, 32712, 32768, 0],
  [19850, 30702, 32244, 32768, 0],
  [10983, 24024, 29223, 32768, 0],
  [6294, 16770, 23582, 32768, 0],
  [3244, 9283, 14509, 32768, 0],
  [30023, 32717, 32748, 32768, 0],
  [22940, 32032, 32626, 32768, 0],
  [14282, 27928, 31473, 32768, 0],
  [8562, 21327, 27914, 32768, 0],
  [4846, 13393, 19919, 32768, 0],
  [29981, 32590, 32695, 32768, 0],
  [20465, 30963, 32166, 32768, 0],
  [11479, 23579, 28195, 32768, 0],
  [5916, 15648, 22073, 32768, 0],
  [3031, 8605, 13398, 32768, 0],
  [31146, 32691, 32739, 32768, 0],
  [23106, 31724, 32444, 32768, 0],
  [13783, 26738, 30439, 32768, 0],
  [7852, 19468, 25807, 32768, 0],
  [3860, 11124, 16853, 32768, 0],
  [31014, 32724, 32748, 32768, 0],
  [23629, 32109, 32628, 32768, 0],
  [14747, 28115, 31403, 32768, 0],
  [8545, 21242, 27478, 32768, 0],
  [4574, 12781, 19067, 32768, 0],
  [8192, 16384, 24576, 32768, 0]],
  [[9185, 19694, 24688, 32768, 0],
  [26081, 31985, 32621, 32768, 0],
  [16015, 29000, 31787, 32768, 0],
  [10542, 23690, 29206, 32768, 0],
  [6732, 17945, 24677, 32768, 0],
  [3916, 11039, 16722, 32768, 0],
  [28224, 32566, 32744, 32768, 0],
  [19100, 31138, 32485, 32768, 0],
  [12528, 26620, 30879, 32768, 0],
  [7741, 20277, 26885, 32768, 0],
  [4566, 12845, 18990, 32768, 0],
  [29933, 32593, 32718, 32768, 0],
  [17670, 30333, 32155, 32768, 0],
  [10385, 23600, 28909, 32768, 0],
  [6243, 16236, 22407, 32768, 0],
  [3976, 10389, 16017, 32768, 0],
  [28377, 32561, 32738, 32768, 0],
  [19366, 31175, 32482, 32768, 0],
  [13327, 27175, 31094, 32768, 0],
  [8258, 20769, 27143, 32768, 0],
  [4703, 13198, 19527, 32768, 0],
  [31086, 32706, 32748, 32768, 0],
  [22853, 31902, 32583, 32768, 0],
  [14759, 28186, 31419, 32768, 0],
  [9284, 22382, 28348, 32768, 0],
  [5585, 15192, 21868, 32768, 0],
  [28291, 32652, 32746, 32768, 0],
  [19849, 32107, 32571, 32768, 0],
  [14834, 26818, 29214, 32768, 0],
  [10306, 22594, 28672, 32768, 0],
  [6615, 17384, 23384, 32768, 0],
  [28947, 32604, 32745, 32768, 0],
  [25625, 32289, 32646, 32768, 0],
  [18758, 28672, 31403, 32768, 0],
  [10017, 23430, 28523, 32768, 0],
  [6862, 15269, 22131, 32768, 0],
  [23933, 32509, 32739, 32768, 0],
  [19927, 31495, 32631, 32768, 0],
  [11903, 26023, 30621, 32768, 0],
  [7026, 20094, 27252, 32768, 0],
  [5998, 18106, 24437, 32768, 0],
  [8192, 16384, 24576, 32768, 0]]],
  [[[4456, 11274, 15533, 32768, 0],
  [21219, 29079, 31616, 32768, 0],
  [11173, 23774, 28567, 32768, 0],
  [7282, 18293, 24263, 32768, 0],
  [4890, 13286, 19115, 32768, 0],
  [1890, 5508, 8659, 32768, 0],
  [26651, 32136, 32647, 32768, 0],
  [14630, 28254, 31455, 32768, 0],
  [8716, 21287, 27395, 32768, 0],
  [5615, 15331, 22008, 32768, 0],
  [2675, 7700, 12150, 32768, 0],
  [29954, 32526, 32690, 32768, 0],
  [16126, 28982, 31633, 32768, 0],
  [9030, 21361, 27352, 32768, 0],
  [5411, 14793, 21271, 32768, 0],
  [2943, 8422, 13163, 32768, 0],
  [29539, 32601, 32730, 32768, 0],
  [18125, 30385, 32201, 32768, 0],
  [10422, 24090, 29468, 32768, 0],
  [6468, 17487, 24438, 32768, 0],
  [2970, 8653, 13531, 32768, 0],
  [30912, 32715, 32748, 32768, 0],
  [20666, 31373, 32497, 32768, 0],
  [12509, 26640, 30917, 32768, 0],
  [8058, 20629, 27290, 32768, 0],
  [4231, 12006, 18052, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0]],
  [[10202, 20633, 25484, 32768, 0],
  [27336, 31445, 32352, 32768, 0],
  [12420, 24384, 28552, 32768, 0],
  [7648, 18115, 23856, 32768, 0],
  [5662, 14341, 19902, 32768, 0],
  [3611, 10328, 15390, 32768, 0],
  [30945, 32616, 32736, 32768, 0],
  [18682, 30505, 32253, 32768, 0],
  [11513, 25336, 30203, 32768, 0],
  [7449, 19452, 26148, 32768, 0],
  [4482, 13051, 18886, 32768, 0],
  [32022, 32690, 32747, 32768, 0],
  [18578, 30501, 32146, 32768, 0],
  [11249, 23368, 28631, 32768, 0],
  [5645, 16958, 22158, 32768, 0],
  [5009, 11444, 16637, 32768, 0],
  [31357, 32710, 32748, 32768, 0],
  [21552, 31494, 32504, 32768, 0],
  [13891, 27677, 31340, 32768, 0],
  [9051, 22098, 28172, 32768, 0],
  [5190, 13377, 19486, 32768, 0],
  [32364, 32740, 32748, 32768, 0],
  [24839, 31907, 32551, 32768, 0],
  [17160, 28779, 31696, 32768, 0],
  [12452, 24137, 29602, 32768, 0],
  [6165, 15389, 22477, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0]]],
  [[[2575, 7281, 11077, 32768, 0],
  [14002, 20866, 25402, 32768, 0],
  [6343, 15056, 19658, 32768, 0],
  [4474, 11858, 17041, 32768, 0],
  [2865, 8299, 12534, 32768, 0],
  [1344, 3949, 6391, 32768, 0],
  [24720, 31239, 32459, 32768, 0],
  [12585, 25356, 29968, 32768, 0],
  [7181, 18246, 24444, 32768, 0],
  [5025, 13667, 19885, 32768, 0],
  [2521, 7304, 11605, 32768, 0],
  [29908, 32252, 32584, 32768, 0],
  [17421, 29156, 31575, 32768, 0],
  [9889, 22188, 27782, 32768, 0],
  [5878, 15647, 22123, 32768, 0],
  [2814, 8665, 13323, 32768, 0],
  [30183, 32568, 32713, 32768, 0],
  [18528, 30195, 32049, 32768, 0],
  [10982, 24606, 29657, 32768, 0],
  [6957, 18165, 25231, 32768, 0],
  [3508, 10118, 15468, 32768, 0],
  [31761, 32736, 32748, 32768, 0],
  [21041, 31328, 32546, 32768, 0],
  [12568, 26732, 31166, 32768, 0],
  [8052, 20720, 27733, 32768, 0],
  [4336, 12192, 18396, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0]],
  [[8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0]]]],
  [[[[7062, 16472, 22319, 32768, 0],
  [24538, 32261, 32674, 32768, 0],
  [13675, 28041, 31779, 32768, 0],
  [8590, 20674, 27631, 32768, 0],
  [5685, 14675, 22013, 32768, 0],
  [3655, 9898, 15731, 32768, 0],
  [26493, 32418, 32658, 32768, 0],
  [16376, 29342, 32090, 32768, 0],
  [10594, 22649, 28970, 32768, 0],
  [8176, 17170, 24303, 32768, 0],
  [5605, 12694, 19139, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [23888, 31902, 32542, 32768, 0],
  [18612, 29687, 31987, 32768, 0],
  [16245, 24852, 29249, 32768, 0],
  [15765, 22608, 27559, 32768, 0],
  [19895, 24699, 27510, 32768, 0],
  [28401, 32212, 32457, 32768, 0],
  [15274, 27825, 30980, 32768, 0],
  [9364, 18128, 24332, 32768, 0],
  [2283, 8193, 15082, 32768, 0],
  [1228, 3972, 7881, 32768, 0],
  [29455, 32469, 32620, 32768, 0],
  [17981, 28245, 31388, 32768, 0],
  [10921, 20098, 26240, 32768, 0],
  [3743, 11829, 18657, 32768, 0],
  [2374, 9593, 15715, 32768, 0],
  [31068, 32466, 32635, 32768, 0],
  [20321, 29572, 31971, 32768, 0],
  [10771, 20255, 27119, 32768, 0],
  [2795, 10410, 17361, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0]],
  [[9320, 22102, 27840, 32768, 0],
  [27057, 32464, 32724, 32768, 0],
  [16331, 30268, 32309, 32768, 0],
  [10319, 23935, 29720, 32768, 0],
  [6189, 16448, 24106, 32768, 0],
  [3589, 10884, 18808, 32768, 0],
  [29026, 32624, 32748, 32768, 0],
  [19226, 31507, 32587, 32768, 0],
  [12692, 26921, 31203, 32768, 0],
  [7049, 19532, 27635, 32768, 0],
  [7727, 15669, 23252, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [28056, 32625, 32748, 32768, 0],
  [22383, 32075, 32669, 32768, 0],
  [15417, 27098, 31749, 32768, 0],
  [18127, 26493, 27190, 32768, 0],
  [5461, 16384, 21845, 32768, 0],
  [27982, 32091, 32584, 32768, 0],
  [19045, 29868, 31972, 32768, 0],
  [10397, 22266, 27932, 32768, 0],
  [5990, 13697, 21500, 32768, 0],
  [1792, 6912, 15104, 32768, 0],
  [28198, 32501, 32718, 32768, 0],
  [21534, 31521, 32569, 32768, 0],
  [11109, 25217, 30017, 32768, 0],
  [5671, 15124, 26151, 32768, 0],
  [4681, 14043, 18725, 32768, 0],
  [28688, 32580, 32741, 32768, 0],
  [22576, 32079, 32661, 32768, 0],
  [10627, 22141, 28340, 32768, 0],
  [9362, 14043, 28087, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0]]],
  [[[7754, 16948, 22142, 32768, 0],
  [25670, 32330, 32691, 32768, 0],
  [15663, 29225, 31994, 32768, 0],
  [9878, 23288, 29158, 32768, 0],
  [6419, 17088, 24336, 32768, 0],
  [3859, 11003, 17039, 32768, 0],
  [27562, 32595, 32725, 32768, 0],
  [17575, 30588, 32399, 32768, 0],
  [10819, 24838, 30309, 32768, 0],
  [7124, 18686, 25916, 32768, 0],
  [4479, 12688, 19340, 32768, 0],
  [28385, 32476, 32673, 32768, 0],
  [15306, 29005, 31938, 32768, 0],
  [8937, 21615, 28322, 32768, 0],
  [5982, 15603, 22786, 32768, 0],
  [3620, 10267, 16136, 32768, 0],
  [27280, 32464, 32667, 32768, 0],
  [15607, 29160, 32004, 32768, 0],
  [9091, 22135, 28740, 32768, 0],
  [6232, 16632, 24020, 32768, 0],
  [4047, 11377, 17672, 32768, 0],
  [29220, 32630, 32718, 32768, 0],
  [19650, 31220, 32462, 32768, 0],
  [13050, 26312, 30827, 32768, 0],
  [9228, 20870, 27468, 32768, 0],
  [6146, 15149, 21971, 32768, 0],
  [30169, 32481, 32623, 32768, 0],
  [17212, 29311, 31554, 32768, 0],
  [9911, 21311, 26882, 32768, 0],
  [4487, 13314, 20372, 32768, 0],
  [2570, 7772, 12889, 32768, 0],
  [30924, 32613, 32708, 32768, 0],
  [19490, 30206, 32107, 32768, 0],
  [11232, 23998, 29276, 32768, 0],
  [6769, 17955, 25035, 32768, 0],
  [4398, 12623, 19214, 32768, 0],
  [30609, 32627, 32722, 32768, 0],
  [19370, 30582, 32287, 32768, 0],
  [10457, 23619, 29409, 32768, 0],
  [6443, 17637, 24834, 32768, 0],
  [4645, 13236, 20106, 32768, 0],
  [8192, 16384, 24576, 32768, 0]],
  [[8626, 20271, 26216, 32768, 0],
  [26707, 32406, 32711, 32768, 0],
  [16999, 30329, 32286, 32768, 0],
  [11445, 25123, 30286, 32768, 0],
  [6411, 18828, 25601, 32768, 0],
  [6801, 12458, 20248, 32768, 0],
  [29918, 32682, 32748, 32768, 0],
  [20649, 31739, 32618, 32768, 0],
  [12879, 27773, 31581, 32768, 0],
  [7896, 21751, 28244, 32768, 0],
  [5260, 14870, 23698, 32768, 0],
  [29252, 32593, 32731, 32768, 0],
  [17072, 30460, 32294, 32768, 0],
  [10653, 24143, 29365, 32768, 0],
  [6536, 17490, 23983, 32768, 0],
  [4929, 13170, 20085, 32768, 0],
  [28137, 32518, 32715, 32768, 0],
  [18171, 30784, 32407, 32768, 0],
  [11437, 25436, 30459, 32768, 0],
  [7252, 18534, 26176, 32768, 0],
  [4126, 13353, 20978, 32768, 0],
  [31162, 32726, 32748, 32768, 0],
  [23017, 32222, 32701, 32768, 0],
  [15629, 29233, 32046, 32768, 0],
  [9387, 22621, 29480, 32768, 0],
  [6922, 17616, 25010, 32768, 0],
  [28838, 32265, 32614, 32768, 0],
  [19701, 30206, 31920, 32768, 0],
  [11214, 22410, 27933, 32768, 0],
  [5320, 14177, 23034, 32768, 0],
  [5049, 12881, 17827, 32768, 0],
  [27484, 32471, 32734, 32768, 0],
  [21076, 31526, 32561, 32768, 0],
  [12707, 26303, 31211, 32768, 0],
  [8169, 21722, 28219, 32768, 0],
  [6045, 19406, 27042, 32768, 0],
  [27753, 32572, 32745, 32768, 0],
  [20832, 31878, 32653, 32768, 0],
  [13250, 27356, 31674, 32768, 0],
  [7718, 21508, 29858, 32768, 0],
  [7209, 18350, 25559, 32768, 0],
  [8192, 16384, 24576, 32768, 0]]],
  [[[7876, 16901, 21741, 32768, 0],
  [24001, 31898, 32625, 32768, 0],
  [14529, 27959, 31451, 32768, 0],
  [8273, 20818, 27258, 32768, 0],
  [5278, 14673, 21510, 32768, 0],
  [2983, 8843, 14039, 32768, 0],
  [28016, 32574, 32732, 32768, 0],
  [17471, 30306, 32301, 32768, 0],
  [10224, 24063, 29728, 32768, 0],
  [6602, 17954, 25052, 32768, 0],
  [4002, 11585, 17759, 32768, 0],
  [30190, 32634, 32739, 32768, 0],
  [17497, 30282, 32270, 32768, 0],
  [10229, 23729, 29538, 32768, 0],
  [6344, 17211, 24440, 32768, 0],
  [3849, 11189, 17108, 32768, 0],
  [28570, 32583, 32726, 32768, 0],
  [17521, 30161, 32238, 32768, 0],
  [10153, 23565, 29378, 32768, 0],
  [6455, 17341, 24443, 32768, 0],
  [3907, 11042, 17024, 32768, 0],
  [30689, 32715, 32748, 32768, 0],
  [21546, 31840, 32610, 32768, 0],
  [13547, 27581, 31459, 32768, 0],
  [8912, 21757, 28309, 32768, 0],
  [5548, 15080, 22046, 32768, 0],
  [30783, 32540, 32685, 32768, 0],
  [17540, 29528, 31668, 32768, 0],
  [10160, 21468, 26783, 32768, 0],
  [4724, 13393, 20054, 32768, 0],
  [2702, 8174, 13102, 32768, 0],
  [31648, 32686, 32742, 32768, 0],
  [20954, 31094, 32337, 32768, 0],
  [12420, 25698, 30179, 32768, 0],
  [7304, 19320, 26248, 32768, 0],
  [4366, 12261, 18864, 32768, 0],
  [31581, 32723, 32748, 32768, 0],
  [21373, 31586, 32525, 32768, 0],
  [12744, 26625, 30885, 32768, 0],
  [7431, 20322, 26950, 32768, 0],
  [4692, 13323, 20111, 32768, 0],
  [8192, 16384, 24576, 32768, 0]],
  [[7833, 18369, 24095, 32768, 0],
  [26650, 32273, 32702, 32768, 0],
  [16371, 29961, 32191, 32768, 0],
  [11055, 24082, 29629, 32768, 0],
  [6892, 18644, 25400, 32768, 0],
  [5006, 13057, 19240, 32768, 0],
  [29834, 32666, 32748, 32768, 0],
  [19577, 31335, 32570, 32768, 0],
  [12253, 26509, 31122, 32768, 0],
  [7991, 20772, 27711, 32768, 0],
  [5677, 15910, 23059, 32768, 0],
  [30109, 32532, 32720, 32768, 0],
  [16747, 30166, 32252, 32768, 0],
  [10134, 23542, 29184, 32768, 0],
  [5791, 16176, 23556, 32768, 0],
  [4362, 10414, 17284, 32768, 0],
  [29492, 32626, 32748, 32768, 0],
  [19894, 31402, 32525, 32768, 0],
  [12942, 27071, 30869, 32768, 0],
  [8346, 21216, 27405, 32768, 0],
  [6572, 17087, 23859, 32768, 0],
  [32035, 32735, 32748, 32768, 0],
  [22957, 31838, 32618, 32768, 0],
  [14724, 28572, 31772, 32768, 0],
  [10364, 23999, 29553, 32768, 0],
  [7004, 18433, 25655, 32768, 0],
  [27528, 32277, 32681, 32768, 0],
  [16959, 31171, 32096, 32768, 0],
  [10486, 23593, 27962, 32768, 0],
  [8192, 16384, 23211, 32768, 0],
  [8937, 17873, 20852, 32768, 0],
  [27715, 32002, 32615, 32768, 0],
  [15073, 29491, 31676, 32768, 0],
  [11264, 24576, 28672, 32768, 0],
  [2341, 18725, 23406, 32768, 0],
  [7282, 18204, 25486, 32768, 0],
  [28547, 32213, 32657, 32768, 0],
  [20788, 29773, 32239, 32768, 0],
  [6780, 21469, 30508, 32768, 0],
  [5958, 14895, 23831, 32768, 0],
  [16384, 21845, 27307, 32768, 0],
  [8192, 16384, 24576, 32768, 0]]],
  [[[5992, 14304, 19765, 32768, 0],
  [22612, 31238, 32456, 32768, 0],
  [13456, 27162, 31087, 32768, 0],
  [8001, 20062, 26504, 32768, 0],
  [5168, 14105, 20764, 32768, 0],
  [2632, 7771, 12385, 32768, 0],
  [27034, 32344, 32709, 32768, 0],
  [15850, 29415, 31997, 32768, 0],
  [9494, 22776, 28841, 32768, 0],
  [6151, 16830, 23969, 32768, 0],
  [3461, 10039, 15722, 32768, 0],
  [30134, 32569, 32731, 32768, 0],
  [15638, 29422, 31945, 32768, 0],
  [9150, 21865, 28218, 32768, 0],
  [5647, 15719, 22676, 32768, 0],
  [3402, 9772, 15477, 32768, 0],
  [28530, 32586, 32735, 32768, 0],
  [17139, 30298, 32292, 32768, 0],
  [10200, 24039, 29685, 32768, 0],
  [6419, 17674, 24786, 32768, 0],
  [3544, 10225, 15824, 32768, 0],
  [31333, 32726, 32748, 32768, 0],
  [20618, 31487, 32544, 32768, 0],
  [12901, 27217, 31232, 32768, 0],
  [8624, 21734, 28171, 32768, 0],
  [5104, 14191, 20748, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0]],
  [[11206, 21090, 26561, 32768, 0],
  [28759, 32279, 32671, 32768, 0],
  [14171, 27952, 31569, 32768, 0],
  [9743, 22907, 29141, 32768, 0],
  [6871, 17886, 24868, 32768, 0],
  [4960, 13152, 19315, 32768, 0],
  [31077, 32661, 32748, 32768, 0],
  [19400, 31195, 32515, 32768, 0],
  [12752, 26858, 31040, 32768, 0],
  [8370, 22098, 28591, 32768, 0],
  [5457, 15373, 22298, 32768, 0],
  [31697, 32706, 32748, 32768, 0],
  [17860, 30657, 32333, 32768, 0],
  [12510, 24812, 29261, 32768, 0],
  [6180, 19124, 24722, 32768, 0],
  [5041, 13548, 17959, 32768, 0],
  [31552, 32716, 32748, 32768, 0],
  [21908, 31769, 32623, 32768, 0],
  [14470, 28201, 31565, 32768, 0],
  [9493, 22982, 28608, 32768, 0],
  [6858, 17240, 24137, 32768, 0],
  [32543, 32752, 32756, 32768, 0],
  [24286, 32097, 32666, 32768, 0],
  [15958, 29217, 32024, 32768, 0],
  [10207, 24234, 29958, 32768, 0],
  [6929, 18305, 25652, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0]]],
  [[[4137, 10847, 15682, 32768, 0],
  [17824, 27001, 30058, 32768, 0],
  [10204, 22796, 28291, 32768, 0],
  [6076, 15935, 22125, 32768, 0],
  [3852, 10937, 16816, 32768, 0],
  [2252, 6324, 10131, 32768, 0],
  [25840, 32016, 32662, 32768, 0],
  [15109, 28268, 31531, 32768, 0],
  [9385, 22231, 28340, 32768, 0],
  [6082, 16672, 23479, 32768, 0],
  [3318, 9427, 14681, 32768, 0],
  [30594, 32574, 32718, 32768, 0],
  [16836, 29552, 31859, 32768, 0],
  [9556, 22542, 28356, 32768, 0],
  [6305, 16725, 23540, 32768, 0],
  [3376, 9895, 15184, 32768, 0],
  [29383, 32617, 32745, 32768, 0],
  [18891, 30809, 32401, 32768, 0],
  [11688, 25942, 30687, 32768, 0],
  [7468, 19469, 26651, 32768, 0],
  [3909, 11358, 17012, 32768, 0],
  [31564, 32736, 32748, 32768, 0],
  [20906, 31611, 32600, 32768, 0],
  [13191, 27621, 31537, 32768, 0],
  [8768, 22029, 28676, 32768, 0],
  [5079, 14109, 20906, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0]],
  [[8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0]]]]
];
const Default_Coeff_Br_Cdf = [
  [[[[14298, 20718, 24174, 32768, 0],
  [12536, 19601, 23789, 32768, 0],
  [8712, 15051, 19503, 32768, 0],
  [6170, 11327, 15434, 32768, 0],
  [4742, 8926, 12538, 32768, 0],
  [3803, 7317, 10546, 32768, 0],
  [1696, 3317, 4871, 32768, 0],
  [14392, 19951, 22756, 32768, 0],
  [15978, 23218, 26818, 32768, 0],
  [12187, 19474, 23889, 32768, 0],
  [9176, 15640, 20259, 32768, 0],
  [7068, 12655, 17028, 32768, 0],
  [5656, 10442, 14472, 32768, 0],
  [2580, 4992, 7244, 32768, 0],
  [12136, 18049, 21426, 32768, 0],
  [13784, 20721, 24481, 32768, 0],
  [10836, 17621, 21900, 32768, 0],
  [8372, 14444, 18847, 32768, 0],
  [6523, 11779, 16000, 32768, 0],
  [5337, 9898, 13760, 32768, 0],
  [3034, 5860, 8462, 32768, 0]],
  [[15967, 22905, 26286, 32768, 0],
  [13534, 20654, 24579, 32768, 0],
  [9504, 16092, 20535, 32768, 0],
  [6975, 12568, 16903, 32768, 0],
  [5364, 10091, 14020, 32768, 0],
  [4357, 8370, 11857, 32768, 0],
  [2506, 4934, 7218, 32768, 0],
  [23032, 28815, 30936, 32768, 0],
  [19540, 26704, 29719, 32768, 0],
  [15158, 22969, 27097, 32768, 0],
  [11408, 18865, 23650, 32768, 0],
  [8885, 15448, 20250, 32768, 0],
  [7108, 12853, 17416, 32768, 0],
  [4231, 8041, 11480, 32768, 0],
  [19823, 26490, 29156, 32768, 0],
  [18890, 25929, 28932, 32768, 0],
  [15660, 23491, 27433, 32768, 0],
  [12147, 19776, 24488, 32768, 0],
  [9728, 16774, 21649, 32768, 0],
  [7919, 14277, 19066, 32768, 0],
  [5440, 10170, 14185, 32768, 0]]],
  [[[14406, 20862, 24414, 32768, 0],
  [11824, 18907, 23109, 32768, 0],
  [8257, 14393, 18803, 32768, 0],
  [5860, 10747, 14778, 32768, 0],
  [4475, 8486, 11984, 32768, 0],
  [3606, 6954, 10043, 32768, 0],
  [1736, 3410, 5048, 32768, 0],
  [14430, 20046, 22882, 32768, 0],
  [15593, 22899, 26709, 32768, 0],
  [12102, 19368, 23811, 32768, 0],
  [9059, 15584, 20262, 32768, 0],
  [6999, 12603, 17048, 32768, 0],
  [5684, 10497, 14553, 32768, 0],
  [2822, 5438, 7862, 32768, 0],
  [15785, 21585, 24359, 32768, 0],
  [18347, 25229, 28266, 32768, 0],
  [14974, 22487, 26389, 32768, 0],
  [11423, 18681, 23271, 32768, 0],
  [8863, 15350, 20008, 32768, 0],
  [7153, 12852, 17278, 32768, 0],
  [3707, 7036, 9982, 32768, 0]],
  [[15460, 21696, 25469, 32768, 0],
  [12170, 19249, 23191, 32768, 0],
  [8723, 15027, 19332, 32768, 0],
  [6428, 11704, 15874, 32768, 0],
  [4922, 9292, 13052, 32768, 0],
  [4139, 7695, 11010, 32768, 0],
  [2291, 4508, 6598, 32768, 0],
  [19856, 26920, 29828, 32768, 0],
  [17923, 25289, 28792, 32768, 0],
  [14278, 21968, 26297, 32768, 0],
  [10910, 18136, 22950, 32768, 0],
  [8423, 14815, 19627, 32768, 0],
  [6771, 12283, 16774, 32768, 0],
  [4074, 7750, 11081, 32768, 0],
  [19852, 26074, 28672, 32768, 0],
  [19371, 26110, 28989, 32768, 0],
  [16265, 23873, 27663, 32768, 0],
  [12758, 20378, 24952, 32768, 0],
  [10095, 17098, 21961, 32768, 0],
  [8250, 14628, 19451, 32768, 0],
  [5205, 9745, 13622, 32768, 0]]],
  [[[10563, 16233, 19763, 32768, 0],
  [9794, 16022, 19804, 32768, 0],
  [6750, 11945, 15759, 32768, 0],
  [4963, 9186, 12752, 32768, 0],
  [3845, 7435, 10627, 32768, 0],
  [3051, 6085, 8834, 32768, 0],
  [1311, 2596, 3830, 32768, 0],
  [11246, 16404, 19689, 32768, 0],
  [12315, 18911, 22731, 32768, 0],
  [10557, 17095, 21289, 32768, 0],
  [8136, 14006, 18249, 32768, 0],
  [6348, 11474, 15565, 32768, 0],
  [5196, 9655, 13400, 32768, 0],
  [2349, 4526, 6587, 32768, 0],
  [13337, 18730, 21569, 32768, 0],
  [19306, 26071, 28882, 32768, 0],
  [15952, 23540, 27254, 32768, 0],
  [12409, 19934, 24430, 32768, 0],
  [9760, 16706, 21389, 32768, 0],
  [8004, 14220, 18818, 32768, 0],
  [4138, 7794, 10961, 32768, 0]],
  [[10870, 16684, 20949, 32768, 0],
  [9664, 15230, 18680, 32768, 0],
  [6886, 12109, 15408, 32768, 0],
  [4825, 8900, 12305, 32768, 0],
  [3630, 7162, 10314, 32768, 0],
  [3036, 6429, 9387, 32768, 0],
  [1671, 3296, 4940, 32768, 0],
  [13819, 19159, 23026, 32768, 0],
  [11984, 19108, 23120, 32768, 0],
  [10690, 17210, 21663, 32768, 0],
  [7984, 14154, 18333, 32768, 0],
  [6868, 12294, 16124, 32768, 0],
  [5274, 8994, 12868, 32768, 0],
  [2988, 5771, 8424, 32768, 0],
  [19736, 26647, 29141, 32768, 0],
  [18933, 26070, 28984, 32768, 0],
  [15779, 23048, 27200, 32768, 0],
  [12638, 20061, 24532, 32768, 0],
  [10692, 17545, 22220, 32768, 0],
  [9217, 15251, 20054, 32768, 0],
  [5078, 9284, 12594, 32768, 0]]],
  [[[2331, 3662, 5244, 32768, 0],
  [2891, 4771, 6145, 32768, 0],
  [4598, 7623, 9729, 32768, 0],
  [3520, 6845, 9199, 32768, 0],
  [3417, 6119, 9324, 32768, 0],
  [2601, 5412, 7385, 32768, 0],
  [600, 1173, 1744, 32768, 0],
  [7672, 13286, 17469, 32768, 0],
  [4232, 7792, 10793, 32768, 0],
  [2915, 5317, 7397, 32768, 0],
  [2318, 4356, 6152, 32768, 0],
  [2127, 4000, 5554, 32768, 0],
  [1850, 3478, 5275, 32768, 0],
  [977, 1933, 2843, 32768, 0],
  [18280, 24387, 27989, 32768, 0],
  [15852, 22671, 26185, 32768, 0],
  [13845, 20951, 24789, 32768, 0],
  [11055, 17966, 22129, 32768, 0],
  [9138, 15422, 19801, 32768, 0],
  [7454, 13145, 17456, 32768, 0],
  [3370, 6393, 9013, 32768, 0]],
  [[5842, 9229, 10838, 32768, 0],
  [2313, 3491, 4276, 32768, 0],
  [2998, 6104, 7496, 32768, 0],
  [2420, 7447, 9868, 32768, 0],
  [3034, 8495, 10923, 32768, 0],
  [4076, 8937, 10975, 32768, 0],
  [1086, 2370, 3299, 32768, 0],
  [9714, 17254, 20444, 32768, 0],
  [8543, 13698, 17123, 32768, 0],
  [4918, 9007, 11910, 32768, 0],
  [4129, 7532, 10553, 32768, 0],
  [2364, 5533, 8058, 32768, 0],
  [1834, 3546, 5563, 32768, 0],
  [1473, 2908, 4133, 32768, 0],
  [15405, 21193, 25619, 32768, 0],
  [15691, 21952, 26561, 32768, 0],
  [12962, 19194, 24165, 32768, 0],
  [10272, 17855, 22129, 32768, 0],
  [8588, 15270, 20718, 32768, 0],
  [8682, 14669, 19500, 32768, 0],
  [4870, 9636, 13205, 32768, 0]]],
  [[[8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0]],
  [[8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0]]]],
  [[[[14995, 21341, 24749, 32768, 0],
  [13158, 20289, 24601, 32768, 0],
  [8941, 15326, 19876, 32768, 0],
  [6297, 11541, 15807, 32768, 0],
  [4817, 9029, 12776, 32768, 0],
  [3731, 7273, 10627, 32768, 0],
  [1847, 3617, 5354, 32768, 0],
  [14472, 19659, 22343, 32768, 0],
  [16806, 24162, 27533, 32768, 0],
  [12900, 20404, 24713, 32768, 0],
  [9411, 16112, 20797, 32768, 0],
  [7056, 12697, 17148, 32768, 0],
  [5544, 10339, 14460, 32768, 0],
  [2954, 5704, 8319, 32768, 0],
  [12464, 18071, 21354, 32768, 0],
  [15482, 22528, 26034, 32768, 0],
  [12070, 19269, 23624, 32768, 0],
  [8953, 15406, 20106, 32768, 0],
  [7027, 12730, 17220, 32768, 0],
  [5887, 10913, 15140, 32768, 0],
  [3793, 7278, 10447, 32768, 0]],
  [[15571, 22232, 25749, 32768, 0],
  [14506, 21575, 25374, 32768, 0],
  [10189, 17089, 21569, 32768, 0],
  [7316, 13301, 17915, 32768, 0],
  [5783, 10912, 15190, 32768, 0],
  [4760, 9155, 13088, 32768, 0],
  [2993, 5966, 8774, 32768, 0],
  [23424, 28903, 30778, 32768, 0],
  [20775, 27666, 30290, 32768, 0],
  [16474, 24410, 28299, 32768, 0],
  [12471, 20180, 24987, 32768, 0],
  [9410, 16487, 21439, 32768, 0],
  [7536, 13614, 18529, 32768, 0],
  [5048, 9586, 13549, 32768, 0],
  [21090, 27290, 29756, 32768, 0],
  [20796, 27402, 30026, 32768, 0],
  [17819, 25485, 28969, 32768, 0],
  [13860, 21909, 26462, 32768, 0],
  [11002, 18494, 23529, 32768, 0],
  [8953, 15929, 20897, 32768, 0],
  [6448, 11918, 16454, 32768, 0]]],
  [[[15999, 22208, 25449, 32768, 0],
  [13050, 19988, 24122, 32768, 0],
  [8594, 14864, 19378, 32768, 0],
  [6033, 11079, 15238, 32768, 0],
  [4554, 8683, 12347, 32768, 0],
  [3672, 7139, 10337, 32768, 0],
  [1900, 3771, 5576, 32768, 0],
  [15788, 21340, 23949, 32768, 0],
  [16825, 24235, 27758, 32768, 0],
  [12873, 20402, 24810, 32768, 0],
  [9590, 16363, 21094, 32768, 0],
  [7352, 13209, 17733, 32768, 0],
  [5960, 10989, 15184, 32768, 0],
  [3232, 6234, 9007, 32768, 0],
  [15761, 20716, 23224, 32768, 0],
  [19318, 25989, 28759, 32768, 0],
  [15529, 23094, 26929, 32768, 0],
  [11662, 18989, 23641, 32768, 0],
  [8955, 15568, 20366, 32768, 0],
  [7281, 13106, 17708, 32768, 0],
  [4248, 8059, 11440, 32768, 0]],
  [[14899, 21217, 24503, 32768, 0],
  [13519, 20283, 24047, 32768, 0],
  [9429, 15966, 20365, 32768, 0],
  [6700, 12355, 16652, 32768, 0],
  [5088, 9704, 13716, 32768, 0],
  [4243, 8154, 11731, 32768, 0],
  [2702, 5364, 7861, 32768, 0],
  [22745, 28388, 30454, 32768, 0],
  [20235, 27146, 29922, 32768, 0],
  [15896, 23715, 27637, 32768, 0],
  [11840, 19350, 24131, 32768, 0],
  [9122, 15932, 20880, 32768, 0],
  [7488, 13581, 18362, 32768, 0],
  [5114, 9568, 13370, 32768, 0],
  [20845, 26553, 28932, 32768, 0],
  [20981, 27372, 29884, 32768, 0],
  [17781, 25335, 28785, 32768, 0],
  [13760, 21708, 26297, 32768, 0],
  [10975, 18415, 23365, 32768, 0],
  [9045, 15789, 20686, 32768, 0],
  [6130, 11199, 15423, 32768, 0]]],
  [[[13549, 19724, 23158, 32768, 0],
  [11844, 18382, 22246, 32768, 0],
  [7919, 13619, 17773, 32768, 0],
  [5486, 10143, 13946, 32768, 0],
  [4166, 7983, 11324, 32768, 0],
  [3364, 6506, 9427, 32768, 0],
  [1598, 3160, 4674, 32768, 0],
  [15281, 20979, 23781, 32768, 0],
  [14939, 22119, 25952, 32768, 0],
  [11363, 18407, 22812, 32768, 0],
  [8609, 14857, 19370, 32768, 0],
  [6737, 12184, 16480, 32768, 0],
  [5506, 10263, 14262, 32768, 0],
  [2990, 5786, 8380, 32768, 0],
  [20249, 25253, 27417, 32768, 0],
  [21070, 27518, 30001, 32768, 0],
  [16854, 24469, 28074, 32768, 0],
  [12864, 20486, 25000, 32768, 0],
  [9962, 16978, 21778, 32768, 0],
  [8074, 14338, 19048, 32768, 0],
  [4494, 8479, 11906, 32768, 0]],
  [[13960, 19617, 22829, 32768, 0],
  [11150, 17341, 21228, 32768, 0],
  [7150, 12964, 17190, 32768, 0],
  [5331, 10002, 13867, 32768, 0],
  [4167, 7744, 11057, 32768, 0],
  [3480, 6629, 9646, 32768, 0],
  [1883, 3784, 5686, 32768, 0],
  [18752, 25660, 28912, 32768, 0],
  [16968, 24586, 28030, 32768, 0],
  [13520, 21055, 25313, 32768, 0],
  [10453, 17626, 22280, 32768, 0],
  [8386, 14505, 19116, 32768, 0],
  [6742, 12595, 17008, 32768, 0],
  [4273, 8140, 11499, 32768, 0],
  [22120, 27827, 30233, 32768, 0],
  [20563, 27358, 29895, 32768, 0],
  [17076, 24644, 28153, 32768, 0],
  [13362, 20942, 25309, 32768, 0],
  [10794, 17965, 22695, 32768, 0],
  [9014, 15652, 20319, 32768, 0],
  [5708, 10512, 14497, 32768, 0]]],
  [[[5705, 10930, 15725, 32768, 0],
  [7946, 12765, 16115, 32768, 0],
  [6801, 12123, 16226, 32768, 0],
  [5462, 10135, 14200, 32768, 0],
  [4189, 8011, 11507, 32768, 0],
  [3191, 6229, 9408, 32768, 0],
  [1057, 2137, 3212, 32768, 0],
  [10018, 17067, 21491, 32768, 0],
  [7380, 12582, 16453, 32768, 0],
  [6068, 10845, 14339, 32768, 0],
  [5098, 9198, 12555, 32768, 0],
  [4312, 8010, 11119, 32768, 0],
  [3700, 6966, 9781, 32768, 0],
  [1693, 3326, 4887, 32768, 0],
  [18757, 24930, 27774, 32768, 0],
  [17648, 24596, 27817, 32768, 0],
  [14707, 22052, 26026, 32768, 0],
  [11720, 18852, 23292, 32768, 0],
  [9357, 15952, 20525, 32768, 0],
  [7810, 13753, 18210, 32768, 0],
  [3879, 7333, 10328, 32768, 0]],
  [[8278, 13242, 15922, 32768, 0],
  [10547, 15867, 18919, 32768, 0],
  [9106, 15842, 20609, 32768, 0],
  [6833, 13007, 17218, 32768, 0],
  [4811, 9712, 13923, 32768, 0],
  [3985, 7352, 11128, 32768, 0],
  [1688, 3458, 5262, 32768, 0],
  [12951, 21861, 26510, 32768, 0],
  [9788, 16044, 20276, 32768, 0],
  [6309, 11244, 14870, 32768, 0],
  [5183, 9349, 12566, 32768, 0],
  [4389, 8229, 11492, 32768, 0],
  [3633, 6945, 10620, 32768, 0],
  [3600, 6847, 9907, 32768, 0],
  [21748, 28137, 30255, 32768, 0],
  [19436, 26581, 29560, 32768, 0],
  [16359, 24201, 27953, 32768, 0],
  [13961, 21693, 25871, 32768, 0],
  [11544, 18686, 23322, 32768, 0],
  [9372, 16462, 20952, 32768, 0],
  [6138, 11210, 15390, 32768, 0]]],
  [[[8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0]],
  [[8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0]]]],
  [[[[16138, 22223, 25509, 32768, 0],
  [15347, 22430, 26332, 32768, 0],
  [9614, 16736, 21332, 32768, 0],
  [6600, 12275, 16907, 32768, 0],
  [4811, 9424, 13547, 32768, 0],
  [3748, 7809, 11420, 32768, 0],
  [2254, 4587, 6890, 32768, 0],
  [15196, 20284, 23177, 32768, 0],
  [18317, 25469, 28451, 32768, 0],
  [13918, 21651, 25842, 32768, 0],
  [10052, 17150, 21995, 32768, 0],
  [7499, 13630, 18587, 32768, 0],
  [6158, 11417, 16003, 32768, 0],
  [4014, 7785, 11252, 32768, 0],
  [15048, 21067, 24384, 32768, 0],
  [18202, 25346, 28553, 32768, 0],
  [14302, 22019, 26356, 32768, 0],
  [10839, 18139, 23166, 32768, 0],
  [8715, 15744, 20806, 32768, 0],
  [7536, 13576, 18544, 32768, 0],
  [5413, 10335, 14498, 32768, 0]],
  [[17394, 24501, 27895, 32768, 0],
  [15889, 23420, 27185, 32768, 0],
  [11561, 19133, 23870, 32768, 0],
  [8285, 14812, 19844, 32768, 0],
  [6496, 12043, 16550, 32768, 0],
  [4771, 9574, 13677, 32768, 0],
  [3603, 6830, 10144, 32768, 0],
  [21656, 27704, 30200, 32768, 0],
  [21324, 27915, 30511, 32768, 0],
  [17327, 25336, 28997, 32768, 0],
  [13417, 21381, 26033, 32768, 0],
  [10132, 17425, 22338, 32768, 0],
  [8580, 15016, 19633, 32768, 0],
  [5694, 11477, 16411, 32768, 0],
  [24116, 29780, 31450, 32768, 0],
  [23853, 29695, 31591, 32768, 0],
  [20085, 27614, 30428, 32768, 0],
  [15326, 24335, 28575, 32768, 0],
  [11814, 19472, 24810, 32768, 0],
  [10221, 18611, 24767, 32768, 0],
  [7689, 14558, 20321, 32768, 0]]],
  [[[16214, 22380, 25770, 32768, 0],
  [14213, 21304, 25295, 32768, 0],
  [9213, 15823, 20455, 32768, 0],
  [6395, 11758, 16139, 32768, 0],
  [4779, 9187, 13066, 32768, 0],
  [3821, 7501, 10953, 32768, 0],
  [2293, 4567, 6795, 32768, 0],
  [15859, 21283, 23820, 32768, 0],
  [18404, 25602, 28726, 32768, 0],
  [14325, 21980, 26206, 32768, 0],
  [10669, 17937, 22720, 32768, 0],
  [8297, 14642, 19447, 32768, 0],
  [6746, 12389, 16893, 32768, 0],
  [4324, 8251, 11770, 32768, 0],
  [16532, 21631, 24475, 32768, 0],
  [20667, 27150, 29668, 32768, 0],
  [16728, 24510, 28175, 32768, 0],
  [12861, 20645, 25332, 32768, 0],
  [10076, 17361, 22417, 32768, 0],
  [8395, 14940, 19963, 32768, 0],
  [5731, 10683, 14912, 32768, 0]],
  [[14433, 21155, 24938, 32768, 0],
  [14658, 21716, 25545, 32768, 0],
  [9923, 16824, 21557, 32768, 0],
  [6982, 13052, 17721, 32768, 0],
  [5419, 10503, 15050, 32768, 0],
  [4852, 9162, 13014, 32768, 0],
  [3271, 6395, 9630, 32768, 0],
  [22210, 27833, 30109, 32768, 0],
  [20750, 27368, 29821, 32768, 0],
  [16894, 24828, 28573, 32768, 0],
  [13247, 21276, 25757, 32768, 0],
  [10038, 17265, 22563, 32768, 0],
  [8587, 14947, 20327, 32768, 0],
  [5645, 11371, 15252, 32768, 0],
  [22027, 27526, 29714, 32768, 0],
  [23098, 29146, 31221, 32768, 0],
  [19886, 27341, 30272, 32768, 0],
  [15609, 23747, 28046, 32768, 0],
  [11993, 20065, 24939, 32768, 0],
  [9637, 18267, 23671, 32768, 0],
  [7625, 13801, 19144, 32768, 0]]],
  [[[14438, 20798, 24089, 32768, 0],
  [12621, 19203, 23097, 32768, 0],
  [8177, 14125, 18402, 32768, 0],
  [5674, 10501, 14456, 32768, 0],
  [4236, 8239, 11733, 32768, 0],
  [3447, 6750, 9806, 32768, 0],
  [1986, 3950, 5864, 32768, 0],
  [16208, 22099, 24930, 32768, 0],
  [16537, 24025, 27585, 32768, 0],
  [12780, 20381, 24867, 32768, 0],
  [9767, 16612, 21416, 32768, 0],
  [7686, 13738, 18398, 32768, 0],
  [6333, 11614, 15964, 32768, 0],
  [3941, 7571, 10836, 32768, 0],
  [22819, 27422, 29202, 32768, 0],
  [22224, 28514, 30721, 32768, 0],
  [17660, 25433, 28913, 32768, 0],
  [13574, 21482, 26002, 32768, 0],
  [10629, 17977, 22938, 32768, 0],
  [8612, 15298, 20265, 32768, 0],
  [5607, 10491, 14596, 32768, 0]],
  [[13569, 19800, 23206, 32768, 0],
  [13128, 19924, 23869, 32768, 0],
  [8329, 14841, 19403, 32768, 0],
  [6130, 10976, 15057, 32768, 0],
  [4682, 8839, 12518, 32768, 0],
  [3656, 7409, 10588, 32768, 0],
  [2577, 5099, 7412, 32768, 0],
  [22427, 28684, 30585, 32768, 0],
  [20913, 27750, 30139, 32768, 0],
  [15840, 24109, 27834, 32768, 0],
  [12308, 20029, 24569, 32768, 0],
  [10216, 16785, 21458, 32768, 0],
  [8309, 14203, 19113, 32768, 0],
  [6043, 11168, 15307, 32768, 0],
  [23166, 28901, 30998, 32768, 0],
  [21899, 28405, 30751, 32768, 0],
  [18413, 26091, 29443, 32768, 0],
  [15233, 23114, 27352, 32768, 0],
  [12683, 20472, 25288, 32768, 0],
  [10702, 18259, 23409, 32768, 0],
  [8125, 14464, 19226, 32768, 0]]],
  [[[9040, 14786, 18360, 32768, 0],
  [9979, 15718, 19415, 32768, 0],
  [7913, 13918, 18311, 32768, 0],
  [5859, 10889, 15184, 32768, 0],
  [4593, 8677, 12510, 32768, 0],
  [3820, 7396, 10791, 32768, 0],
  [1730, 3471, 5192, 32768, 0],
  [11803, 18365, 22709, 32768, 0],
  [11419, 18058, 22225, 32768, 0],
  [9418, 15774, 20243, 32768, 0],
  [7539, 13325, 17657, 32768, 0],
  [6233, 11317, 15384, 32768, 0],
  [5137, 9656, 13545, 32768, 0],
  [2977, 5774, 8349, 32768, 0],
  [21207, 27246, 29640, 32768, 0],
  [19547, 26578, 29497, 32768, 0],
  [16169, 23871, 27690, 32768, 0],
  [12820, 20458, 25018, 32768, 0],
  [10224, 17332, 22214, 32768, 0],
  [8526, 15048, 19884, 32768, 0],
  [5037, 9410, 13118, 32768, 0]],
  [[12339, 17329, 20140, 32768, 0],
  [13505, 19895, 23225, 32768, 0],
  [9847, 16944, 21564, 32768, 0],
  [7280, 13256, 18348, 32768, 0],
  [4712, 10009, 14454, 32768, 0],
  [4361, 7914, 12477, 32768, 0],
  [2870, 5628, 7995, 32768, 0],
  [20061, 25504, 28526, 32768, 0],
  [15235, 22878, 26145, 32768, 0],
  [12985, 19958, 24155, 32768, 0],
  [9782, 16641, 21403, 32768, 0],
  [9456, 16360, 20760, 32768, 0],
  [6855, 12940, 18557, 32768, 0],
  [5661, 10564, 15002, 32768, 0],
  [25656, 30602, 31894, 32768, 0],
  [22570, 29107, 31092, 32768, 0],
  [18917, 26423, 29541, 32768, 0],
  [15940, 23649, 27754, 32768, 0],
  [12803, 20581, 25219, 32768, 0],
  [11082, 18695, 23376, 32768, 0],
  [7939, 14373, 19005, 32768, 0]]],
  [[[8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0]],
  [[8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0]]]],
  [[[[18315, 24289, 27551, 32768, 0],
  [16854, 24068, 27835, 32768, 0],
  [10140, 17927, 23173, 32768, 0],
  [6722, 12982, 18267, 32768, 0],
  [4661, 9826, 14706, 32768, 0],
  [3832, 8165, 12294, 32768, 0],
  [2795, 6098, 9245, 32768, 0],
  [17145, 23326, 26672, 32768, 0],
  [20733, 27680, 30308, 32768, 0],
  [16032, 24461, 28546, 32768, 0],
  [11653, 20093, 25081, 32768, 0],
  [9290, 16429, 22086, 32768, 0],
  [7796, 14598, 19982, 32768, 0],
  [6502, 12378, 17441, 32768, 0],
  [21681, 27732, 30320, 32768, 0],
  [22389, 29044, 31261, 32768, 0],
  [19027, 26731, 30087, 32768, 0],
  [14739, 23755, 28624, 32768, 0],
  [11358, 20778, 25511, 32768, 0],
  [10995, 18073, 24190, 32768, 0],
  [9162, 14990, 20617, 32768, 0]],
  [[21425, 27952, 30388, 32768, 0],
  [18062, 25838, 29034, 32768, 0],
  [11956, 19881, 24808, 32768, 0],
  [7718, 15000, 20980, 32768, 0],
  [5702, 11254, 16143, 32768, 0],
  [4898, 9088, 16864, 32768, 0],
  [3679, 6776, 11907, 32768, 0],
  [23294, 30160, 31663, 32768, 0],
  [24397, 29896, 31836, 32768, 0],
  [19245, 27128, 30593, 32768, 0],
  [13202, 19825, 26404, 32768, 0],
  [11578, 19297, 23957, 32768, 0],
  [8073, 13297, 21370, 32768, 0],
  [5461, 10923, 19745, 32768, 0],
  [27367, 30521, 31934, 32768, 0],
  [24904, 30671, 31940, 32768, 0],
  [23075, 28460, 31299, 32768, 0],
  [14400, 23658, 30417, 32768, 0],
  [13885, 23882, 28325, 32768, 0],
  [14746, 22938, 27853, 32768, 0],
  [5461, 16384, 27307, 32768, 0]]],
  [[[18274, 24813, 27890, 32768, 0],
  [15537, 23149, 27003, 32768, 0],
  [9449, 16740, 21827, 32768, 0],
  [6700, 12498, 17261, 32768, 0],
  [4988, 9866, 14198, 32768, 0],
  [4236, 8147, 11902, 32768, 0],
  [2867, 5860, 8654, 32768, 0],
  [17124, 23171, 26101, 32768, 0],
  [20396, 27477, 30148, 32768, 0],
  [16573, 24629, 28492, 32768, 0],
  [12749, 20846, 25674, 32768, 0],
  [10233, 17878, 22818, 32768, 0],
  [8525, 15332, 20363, 32768, 0],
  [6283, 11632, 16255, 32768, 0],
  [20466, 26511, 29286, 32768, 0],
  [23059, 29174, 31191, 32768, 0],
  [19481, 27263, 30241, 32768, 0],
  [15458, 23631, 28137, 32768, 0],
  [12416, 20608, 25693, 32768, 0],
  [10261, 18011, 23261, 32768, 0],
  [8016, 14655, 19666, 32768, 0]],
  [[17616, 24586, 28112, 32768, 0],
  [15809, 23299, 27155, 32768, 0],
  [10767, 18890, 23793, 32768, 0],
  [7727, 14255, 18865, 32768, 0],
  [6129, 11926, 16882, 32768, 0],
  [4482, 9704, 14861, 32768, 0],
  [3277, 7452, 11522, 32768, 0],
  [22956, 28551, 30730, 32768, 0],
  [22724, 28937, 30961, 32768, 0],
  [18467, 26324, 29580, 32768, 0],
  [13234, 20713, 25649, 32768, 0],
  [11181, 17592, 22481, 32768, 0],
  [8291, 18358, 24576, 32768, 0],
  [7568, 11881, 14984, 32768, 0],
  [24948, 29001, 31147, 32768, 0],
  [25674, 30619, 32151, 32768, 0],
  [20841, 26793, 29603, 32768, 0],
  [14669, 24356, 28666, 32768, 0],
  [11334, 23593, 28219, 32768, 0],
  [8922, 14762, 22873, 32768, 0],
  [8301, 13544, 20535, 32768, 0]]],
  [[[17113, 23733, 27081, 32768, 0],
  [14139, 21406, 25452, 32768, 0],
  [8552, 15002, 19776, 32768, 0],
  [5871, 11120, 15378, 32768, 0],
  [4455, 8616, 12253, 32768, 0],
  [3469, 6910, 10386, 32768, 0],
  [2255, 4553, 6782, 32768, 0],
  [18224, 24376, 27053, 32768, 0],
  [19290, 26710, 29614, 32768, 0],
  [14936, 22991, 27184, 32768, 0],
  [11238, 18951, 23762, 32768, 0],
  [8786, 15617, 20588, 32768, 0],
  [7317, 13228, 18003, 32768, 0],
  [5101, 9512, 13493, 32768, 0],
  [22639, 28222, 30210, 32768, 0],
  [23216, 29331, 31307, 32768, 0],
  [19075, 26762, 29895, 32768, 0],
  [15014, 23113, 27457, 32768, 0],
  [11938, 19857, 24752, 32768, 0],
  [9942, 17280, 22282, 32768, 0],
  [7167, 13144, 17752, 32768, 0]],
  [[15820, 22738, 26488, 32768, 0],
  [13530, 20885, 25216, 32768, 0],
  [8395, 15530, 20452, 32768, 0],
  [6574, 12321, 16380, 32768, 0],
  [5353, 10419, 14568, 32768, 0],
  [4613, 8446, 12381, 32768, 0],
  [3440, 7158, 9903, 32768, 0],
  [24247, 29051, 31224, 32768, 0],
  [22118, 28058, 30369, 32768, 0],
  [16498, 24768, 28389, 32768, 0],
  [12920, 21175, 26137, 32768, 0],
  [10730, 18619, 25352, 32768, 0],
  [10187, 16279, 22791, 32768, 0],
  [9310, 14631, 22127, 32768, 0],
  [24970, 30558, 32057, 32768, 0],
  [24801, 29942, 31698, 32768, 0],
  [22432, 28453, 30855, 32768, 0],
  [19054, 25680, 29580, 32768, 0],
  [14392, 23036, 28109, 32768, 0],
  [12495, 20947, 26650, 32768, 0],
  [12442, 20326, 26214, 32768, 0]]],
  [[[12162, 18785, 22648, 32768, 0],
  [12749, 19697, 23806, 32768, 0],
  [8580, 15297, 20346, 32768, 0],
  [6169, 11749, 16543, 32768, 0],
  [4836, 9391, 13448, 32768, 0],
  [3821, 7711, 11613, 32768, 0],
  [2228, 4601, 7070, 32768, 0],
  [16319, 24725, 28280, 32768, 0],
  [15698, 23277, 27168, 32768, 0],
  [12726, 20368, 25047, 32768, 0],
  [9912, 17015, 21976, 32768, 0],
  [7888, 14220, 19179, 32768, 0],
  [6777, 12284, 17018, 32768, 0],
  [4492, 8590, 12252, 32768, 0],
  [23249, 28904, 30947, 32768, 0],
  [21050, 27908, 30512, 32768, 0],
  [17440, 25340, 28949, 32768, 0],
  [14059, 22018, 26541, 32768, 0],
  [11288, 18903, 23898, 32768, 0],
  [9411, 16342, 21428, 32768, 0],
  [6278, 11588, 15944, 32768, 0]],
  [[13981, 20067, 23226, 32768, 0],
  [16922, 23580, 26783, 32768, 0],
  [11005, 19039, 24487, 32768, 0],
  [7389, 14218, 19798, 32768, 0],
  [5598, 11505, 17206, 32768, 0],
  [6090, 11213, 15659, 32768, 0],
  [3820, 7371, 10119, 32768, 0],
  [21082, 26925, 29675, 32768, 0],
  [21262, 28627, 31128, 32768, 0],
  [18392, 26454, 30437, 32768, 0],
  [14870, 22910, 27096, 32768, 0],
  [12620, 19484, 24908, 32768, 0],
  [9290, 16553, 22802, 32768, 0],
  [6668, 14288, 20004, 32768, 0],
  [27704, 31055, 31949, 32768, 0],
  [24709, 29978, 31788, 32768, 0],
  [21668, 29264, 31657, 32768, 0],
  [18295, 26968, 30074, 32768, 0],
  [16399, 24422, 29313, 32768, 0],
  [14347, 23026, 28104, 32768, 0],
  [12370, 19806, 24477, 32768, 0]]],
  [[[8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0]],
  [[8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0],
  [8192, 16384, 24576, 32768, 0]]]]
];

export class OBU {
  seq_header: any;
  SeenFrameHeader: number;
  RefFrameType: any[];

  cur_frame: any;
  aom: any;

  TileYModeCdf: number[][] = [];
  TileUVModeCflNotAllowedCdf: number[][] = [];
  TileUVModeCflAllowedCdf: number[][] = [];
  TileAngleDeltaCdf: number[][] = [];
  TileSegmentIdPredictedCdf: number[][] = [];
  TileTx8x8Cdf: number[][] = [];
  TileTx16x16Cdf: number[][] = [];
  TileTx32x32Cdf: number[][] = [];
  TileTx64x64Cdf: number[][] = [];
  TileTxfmSplitCdf: number[][] = [];
  TileFilterIntraCdf: number[][] = [];
  TileInterpFilterCdf: number[][] = [];
  TileMotionModeCdf: number[][] = [];
  TileNewMvCdf: number[][] = [];
  TileZeroMvCdf: number[][] = [];
  TileRefMvCdf: number[][] = [];
  TileCompoundModeCdf: number[][] = [];
  TileDrlModeCdf: number[][] = [];
  TileIsInterCdf: number[][] = [];
  TileCompModeCdf: number[][] = [];
  TileSkipModeCdf: number[][] = [];
  TileCompRefCdf: number[][][] = [];
  TileCompBwdRefCdf: number[][][] = [];
  TileSingleRefCdf: number[][][] = [];
  TilePaletteYModeCdf: number[][][] = [];
  TilePaletteYSizeCdf: number[][] = [];
  TilePaletteUVSizeCdf: number[][] = [];
  TilePaletteSize2YColorCdf: number[][] = [];
  TilePaletteSize2UVColorCdf: number[][] = [];
  TilePaletteSize3YColorCdf: number[][] = [];
  TilePaletteSize3UVColorCdf: number[][] = [];
  TilePaletteSize4YColorCdf: number[][] = [];
  TilePaletteSize4UVColorCdf: number[][] = [];
  TilePaletteSize5YColorCdf: number[][] = [];
  TilePaletteSize5UVColorCdf: number[][] = [];
  TilePaletteSize6YColorCdf: number[][] = [];
  TilePaletteSize6UVColorCdf: number[][] = [];
  TilePaletteSize7YColorCdf: number[][] = [];
  TilePaletteSize7UVColorCdf: number[][] = [];
  TilePaletteSize8YColorCdf: number[][] = [];
  TilePaletteSize8UVColorCdf: number[][] = [];
  TileDeltaLFCdf: number[] = [];
  TileIntraTxTypeSet1Cdf: number[][][] = [];
  TileIntraTxTypeSet2Cdf: number[][][] = [];
  TileInterTxTypeSet1Cdf: number[][] = [];
  TileInterTxTypeSet2Cdf: number[] = [];
  TileInterTxTypeSet3Cdf: number[][] = [];
  TileUseObmcCdf: number[][] = [];
  TileInterIntraCdf: number[][] = [];
  TileCompRefTypeCdf: number[][] = [];
  TileCflSignCdf: number[] = [];
  TileUniCompRefCdf: number[][][] = [];
  TileWedgeInterIntraCdf: number[][] = [];
  TileCompGroupIdxCdf: number[][] = [];
  TileCompoundIdxCdf: number[][] = [];
  TileCompoundTypeCdf: number[][] = [];
  TileInterIntraModeCdf: number[][] = [];
  TileWedgeIndexCdf: number[][] = [];
  TileCflAlphaCdf: number[][] = [];
  TileMvJointCdf: number[] = [];
  TileMvClassCdf: number[][] = [];
  TileMvClass0BitCdf: number[] = [];
  TileMvFrCdf: number[][] = [];
  TileMvClass0FrCdf: number[][][] = [];
  TileMvClass0HpCdf: number[] = [];
  TileMvSignCdf: number[] = [];
  TileMvBitCdf: number[][] = [];
  TileMvHpCdf: number[] = [];
  TileDeltaLFMultiCdf: number[] = [];
  TileUseSgrprojCdf: number[] = [];
  TileUseWienerCdf: number[] = [];
  TilePartitionW8Cdf: number[][] = [];
  TilePartitionW16Cdf: number[][] = [];
  TilePartitionW32Cdf: number[][] = [];
  TilePartitionW64Cdf: number[][] = [];
  TilePartitionW128Cdf: number[][] = [];
  TileSkipCdf: number[][] = [];
  TileDeltaQCdf: number[] = [];
  TileIntraFrameYModeCdf: number[][][] = [];
  TileIntrabcCdf: number[] = [];
  TilePaletteUVModeCdf: number[][] = [];
  TileSegmentIdCdf: number[][] = [];
  TileRestorationTypeCdf: number[] = [];

  TxbSkipCdf: number[][][] = [];
  EobPt16Cdf: number[][][] = [];
  EobPt32Cdf: number[][][] = [];
  EobPt64Cdf: number[][][] = [];
  EobPt128Cdf: number[][][] = [];
  EobPt256Cdf: number[][][] = [];
  EobPt512Cdf: number[][] = [];
  EobPt1024Cdf: number[][] = [];
  EobExtraCdf: number[][][][] = [];
  DcSignCdf: number[][][] = [];
  CoeffBaseEobCdf: number[][][][] = [];
  CoeffBaseCdf: number[][][][] = [];
  CoeffBrCdf: number[][][][] = [];
  TileFilterIntraModeCdf: number[] = [];
  TileTxbSkipCdf: number[][][][] = [];
  TileEobPt16Cdf: number[][][][] = [];
  TileEobPt32Cdf: number[][][][] = [];
  TileEobPt64Cdf: number[][][][] = [];
  TileEobPt128Cdf: number[][][][] = [];
  TileEobPt256Cdf: number[][][][] = [];
  TileEobPt512Cdf: number[][][] = [];
  TileEobPt1024Cdf: number[][][] = [];
  TileEobExtraCdf: number[][][][][] = [];
  TileDcSignCdf: number[][][][] = [];
  TileCoeffBaseEobCdf: number[][][][][] = [];
  TileCoeffBaseCdf: number[][][][][] = [];
  TileCoeffBrCdf: number[][][][][] = [];


  // 在某些情况下，语法表可以使用从语法元素值派生的其他变量的值。这些变量出现在语法表或文本中，由小写和大写字母混合命名，没有任何下划线字符。
  // 以大写字母开头的变量被导出用于解码当前语法结构和所有依赖语法结构，这些变量可以用于之后的语法结构的解码过程中。
  // 以小写字母开头的变量仅在派生它们的过程中使用。

  constructor() {
    this.SeenFrameHeader = 0;
    this.RefFrameType = new Array(NUM_REF_FRAMES);
    this.cur_frame = {};
    this.aom = {};
  }

  parse(buffer: Uint8Array, offset: number) {
    let obu: any[] = [];
    let b = new BitReader(buffer);
    while (buffer.length > b.get_position() / 8) {
      let h: any = {};

      let bitOffset = b.get_position();
      let bitPos = this.open_bitstream_unit(buffer.length - bitOffset / 8, { b, h });

      if (h.obu_type == OBU_SEQUENCE_HEADER) {
        this.seq_header = h;
      }

      h['@offset'] = bitOffset / 8 + offset;
      h['@length'] = (bitPos - bitOffset) / 8 + h.obu_size;
      obu.push(h);
      this.update_frame_buffers({ h });
      b.seek(bitPos + h.obu_size * 8);
    }
    return obu;
  }


  S2({ b, h }: { b: BitReader, h: any }, icdf: number[]) {
    return this.read_symbol({ b, h }, icdf, icdf.length - 1);
  }

  static AOM_CDF(a: number[]) {
    return a.map((x) => {
      if (x == 0) {
        return 0;
      }
      return (1 << 15) - x;
    });
  }

  // 4.10.9 
  S_PartitionW({ b, h }: { b: BitReader, h: any }, r: number, c: number, bsize: number) {
    return 0;
  }

  // 8.3.2 Cdf selection process
  S({ b, h }: { b: BitReader, h: any }, data: any) {
    let this_ = this;
    let get_above_tx_width = function (row: number, col: number) {
      if (row == h.MiRow) {
        if (!h.AvailU) {
          return 64;
        } else if (h[`Skips[${row - 1}][${col}]`] && h[`IsInters[${row - 1}][${col}]`]) {
          return Block_Width[h[`MiSizes[${row - 1}][${col}]`]];
        }
      }
      return Tx_Width[h[`InterTxSizes[${row - 1}][${col}]`]];
    }
    let get_left_tx_height = function (row: number, col: number) {
      if (col == h.MiCol) {
        if (!h.AvailL) {
          return 64;
        } else if (h[`Skips[${row}][${col - 1}]`] && h[`IsInters[${row}][${col - 1}]`]) {
          return Block_Height[h[`MiSizes[${row}][${col - 1}]`]];
        }
      }
      return Tx_Height[h[`InterTxSizes[${row}][${col - 1}]`]];
    }
    let count_refs = function (frameType: number) {
      let c = 0;
      if (h.AvailU) {
        if (h[`AboveRefFrame[0]`] == frameType) c++;
        if (h[`AboveRefFrame[1]`] == frameType) c++;
      }
      if (h.AvailL) {
        if (h[`LeftRefFrame[0]`] == frameType) c++;
        if (h[`LeftRefFrame[1]`] == frameType) c++;
      }
      return c;
    }
    let ref_count_ctx = function (counts0: number, counts1: number) {
      if (counts0 < counts1)
        return 0;
      else if (counts0 == counts1)
        return 1;
      else
        return 2;
    }
    let get_coeff_base_ctx = function (txSz: number, plane: number, blockX: number, blockY: number, pos: number, c: number, isEob: number) {
      const Coeff_Base_Ctx_Offset = [
        [
          [0, 1, 6, 6, 0],
          [1, 6, 6, 21, 0],
          [6, 6, 21, 21, 0],
          [6, 21, 21, 21, 0],
          [0, 0, 0, 0, 0]
        ],
        [
          [0, 1, 6, 6, 21],
          [1, 6, 6, 21, 21],
          [6, 6, 21, 21, 21],
          [6, 21, 21, 21, 21],
          [21, 21, 21, 21, 21]
        ],
        [
          [0, 1, 6, 6, 21],
          [1, 6, 6, 21, 21],
          [6, 6, 21, 21, 21],
          [6, 21, 21, 21, 21],
          [21, 21, 21, 21, 21]
        ],
        [
          [0, 1, 6, 6, 21],
          [1, 6, 6, 21, 21],
          [6, 6, 21, 21, 21],
          [6, 21, 21, 21, 21],
          [21, 21, 21, 21, 21]
        ],
        [
          [0, 1, 6, 6, 21],
          [1, 6, 6, 21, 21],
          [6, 6, 21, 21, 21],
          [6, 21, 21, 21, 21],
          [21, 21, 21, 21, 21]
        ],
        [
          [0, 11, 11, 11, 0],
          [11, 11, 11, 11, 0],
          [6, 6, 21, 21, 0],
          [6, 21, 21, 21, 0],
          [21, 21, 21, 21, 0]
        ],
        [
          [0, 16, 6, 6, 21],
          [16, 16, 6, 21, 21],
          [16, 16, 21, 21, 21],
          [16, 16, 21, 21, 21],
          [0, 0, 0, 0, 0]
        ],
        [
          [0, 11, 11, 11, 11],
          [11, 11, 11, 11, 11],
          [6, 6, 21, 21, 21],
          [6, 21, 21, 21, 21],
          [21, 21, 21, 21, 21]
        ],
        [
          [0, 16, 6, 6, 21],
          [16, 16, 6, 21, 21],
          [16, 16, 21, 21, 21],
          [16, 16, 21, 21, 21],
          [16, 16, 21, 21, 21]
        ],
        [
          [0, 11, 11, 11, 11],
          [11, 11, 11, 11, 11],
          [6, 6, 21, 21, 21],
          [6, 21, 21, 21, 21],
          [21, 21, 21, 21, 21]
        ],
        [
          [0, 16, 6, 6, 21],
          [16, 16, 6, 21, 21],
          [16, 16, 21, 21, 21],
          [16, 16, 21, 21, 21],
          [16, 16, 21, 21, 21]
        ],
        [
          [0, 11, 11, 11, 11],
          [11, 11, 11, 11, 11],
          [6, 6, 21, 21, 21],
          [6, 21, 21, 21, 21],
          [21, 21, 21, 21, 21]
        ],
        [
          [0, 16, 6, 6, 21],
          [16, 16, 6, 21, 21],
          [16, 16, 21, 21, 21],
          [16, 16, 21, 21, 21],
          [16, 16, 21, 21, 21]
        ],
        [
          [0, 11, 11, 11, 0],
          [11, 11, 11, 11, 0],
          [6, 6, 21, 21, 0],
          [6, 21, 21, 21, 0],
          [21, 21, 21, 21, 0]
        ],
        [
          [0, 16, 6, 6, 21],
          [16, 16, 6, 21, 21],
          [16, 16, 21, 21, 21],
          [16, 16, 21, 21, 21],
          [0, 0, 0, 0, 0]
        ],
        [
          [0, 11, 11, 11, 11],
          [11, 11, 11, 11, 11],
          [6, 6, 21, 21, 21],
          [6, 21, 21, 21, 21],
          [21, 21, 21, 21, 21]
        ],
        [
          [0, 16, 6, 6, 21],
          [16, 16, 6, 21, 21],
          [16, 16, 21, 21, 21],
          [16, 16, 21, 21, 21],
          [16, 16, 21, 21, 21]
        ],
        [
          [0, 11, 11, 11, 11],
          [11, 11, 11, 11, 11],
          [6, 6, 21, 21, 21],
          [6, 21, 21, 21, 21],
          [21, 21, 21, 21, 21]
        ],
        [
          [0, 16, 6, 6, 21],
          [16, 16, 6, 21, 21],
          [16, 16, 21, 21, 21],
          [16, 16, 21, 21, 21],
          [16, 16, 21, 21, 21]
        ]
      ];
      const Coeff_Base_Pos_Ctx_Offset = [
        SIG_COEF_CONTEXTS_2D,
        SIG_COEF_CONTEXTS_2D + 5,
        SIG_COEF_CONTEXTS_2D + 10
      ];
      let adjTxSz = Adjusted_Tx_Size[txSz];
      let bwl = Tx_Width_Log2[adjTxSz];
      let width = 1 << bwl;
      let height = Tx_Height[adjTxSz];
      let txType = this_.compute_tx_type({ b, h }, plane, txSz, blockX, blockY);

      if (isEob) {
        if (c == 0) {
          return SIG_COEF_CONTEXTS - 4;
        }
        if (c <= (height << bwl) / 8) {
          return SIG_COEF_CONTEXTS - 3;
        }
        if (c <= (height << bwl) / 4) {
          return SIG_COEF_CONTEXTS - 2;
        }
        return SIG_COEF_CONTEXTS - 1;
      }

      let txClass = get_tx_class(txType);
      let row = pos >> bwl;
      let col = pos - (row << bwl);
      let mag = 0;

      for (let idx = 0; idx < SIG_REF_DIFF_OFFSET_NUM; idx++) {
        let refRow = row + Sig_Ref_Diff_Offset[txClass][idx][0];
        let refCol = col + Sig_Ref_Diff_Offset[txClass][idx][1];
        if (
          refRow >= 0 &&
          refCol >= 0 &&
          refRow < height &&
          refCol < width
        ) {
          mag += Math.min(Math.abs(h[`Quant[${(refRow << bwl) + refCol}]`]), 3);
        }
      }

      let ctx = Math.min((mag + 1) >> 1, 4);

      if (txClass == TX_CLASS_2D) {
        if (row == 0 && col == 0) {
          return 0;
        }
        return ctx + Coeff_Base_Ctx_Offset[txSz][Math.min(row, 4)][Math.min(col, 4)];
      }

      let idx = txClass == TX_CLASS_VERT ? row : col;
      return ctx + Coeff_Base_Pos_Ctx_Offset[Math.min(idx, 2)];
    }
    let get_tx_class = function (txType: number) {
      if (
        txType == V_DCT ||
        txType == V_ADST ||
        txType == V_FLIPADST
      ) {
        return TX_CLASS_VERT;
      } else if (
        txType == H_DCT ||
        txType == H_ADST ||
        txType == H_FLIPADST
      ) {
        return TX_CLASS_HORIZ;
      } else {
        return TX_CLASS_2D;
      }
    }

    switch (data.name) {
      case "use_intrabc": {
        return this.S2({ b, h }, this.TileIntrabcCdf);
      }
      case "intra_frame_y_mode": {
        const Intra_Mode_Context = [
          0, 1, 2, 3, 4, 4, 4, 4, 3, 0, 1, 2, 0
        ];
        let abovemode = Intra_Mode_Context[h.AvailU ? h[`YModes[${h.MiRow - 1}][${h.MiCol}]`] : DC_PRED];
        let leftmode = Intra_Mode_Context[h.AvailL ? h[`YModes[${h.MiRow}][${h.MiCol - 1}]`] : DC_PRED];
        return this.S2({ b, h }, this.TileIntraFrameYModeCdf[abovemode][leftmode]);
      }
      case "y_mode": {
        let ctx = h[`Size_Group[${h.MiSize}]`];
        return this.S2({ b, h }, this.TileYModeCdf[ctx]);
      }
      case "uv_mode": {
        if (h.Lossless == 1 && this.get_plane_residual_size({ b, h }, h.MiSize, 1) == BLOCK_4X4) {
          return this.S2({ b, h }, this.TileUVModeCflAllowedCdf[h.YMode]);
        } else if (h.Lossless == 0 && Math.max(Block_Width[h.MiSize], Block_Height[h.MiSize]) <= 32) {
          return this.S2({ b, h }, this.TileUVModeCflAllowedCdf[h.YMode]);
        }
        return this.S2({ b, h }, this.TileUVModeCflNotAllowedCdf[h.YMode]);
      }
      case "angle_delta_y": {
        return this.S2({ b, h }, this.TileAngleDeltaCdf[h.YMode - V_PRED]);
      }
      case "angle_delta_uv": {
        return this.S2({ b, h }, this.TileAngleDeltaCdf[h.UVMode - V_PRED]);
      }
      case "partition": {
        let bsl = Mi_Width_Log2[data.bsize];
        let above = h.AvailU && (Mi_Width_Log2[h[`MiSizes[${data.r - 1}][${data.c}]`]] < bsl);
        let left = h.AvailL && (Mi_Height_Log2[h[`MiSizes[${data.r}][${data.c - 1}]`]] < bsl);
        let ctx = left * 2 + above;
        switch (bsl) {
          case 1:
            return this.S2({ b, h }, this.TilePartitionW8Cdf[ctx]);
          case 2:
            return this.S2({ b, h }, this.TilePartitionW16Cdf[ctx]);
          case 3:
            return this.S2({ b, h }, this.TilePartitionW32Cdf[ctx]);
          case 4:
            return this.S2({ b, h }, this.TilePartitionW64Cdf[ctx]);
          default:
            return this.S2({ b, h }, this.TilePartitionW128Cdf[ctx]);
        }
      }
      case "split_or_horz": {
        let bsl = Mi_Width_Log2[data.bsize];
        let above = h.AvailU && (Mi_Width_Log2[h[`MiSizes[${data.r - 1}][${data.c}]`]] < bsl);
        let left = h.AvailL && (Mi_Height_Log2[h[`MiSizes[${data.r}][${data.c - 1}]`]] < bsl);
        let ctx = left * 2 + above;
        let partitionCdf: number[];
        switch (bsl) {
          case 1:
            partitionCdf = this.TilePartitionW8Cdf[ctx];
            break;
          case 2:
            partitionCdf = this.TilePartitionW16Cdf[ctx];
            break;
          case 3:
            partitionCdf = this.TilePartitionW32Cdf[ctx];
            break;
          case 4:
            partitionCdf = this.TilePartitionW64Cdf[ctx];
            break;
          default:
            partitionCdf = this.TilePartitionW128Cdf[ctx];
        }
        let psum = (partitionCdf[PARTITION_VERT] - partitionCdf[PARTITION_VERT - 1] +
          partitionCdf[PARTITION_SPLIT] - partitionCdf[PARTITION_SPLIT - 1] +
          partitionCdf[PARTITION_HORZ_A] - partitionCdf[PARTITION_HORZ_A - 1] +
          partitionCdf[PARTITION_VERT_A] - partitionCdf[PARTITION_VERT_A - 1] +
          partitionCdf[PARTITION_VERT_B] - partitionCdf[PARTITION_VERT_B - 1]);
        if (data.bsize != BLOCK_128X128)
          psum += partitionCdf[PARTITION_VERT_4] - partitionCdf[PARTITION_VERT_4 - 1];
        // libaom与av1文档不一致
        let cdf = [- psum, 0, 0];
        return this.S2({ b, h }, cdf);
      }
      case "split_or_vert": {
        let bsl = Mi_Width_Log2[data.bsize];
        let above = h.AvailU && (Mi_Width_Log2[h[`MiSizes[${data.r - 1}][${data.c}]`]] < bsl);
        let left = h.AvailL && (Mi_Height_Log2[h[`MiSizes[${data.r}][${data.c - 1}]`]] < bsl);
        let ctx = left * 2 + above;
        let partitionCdf: number[];
        switch (bsl) {
          case 1:
            partitionCdf = this.TilePartitionW8Cdf[ctx];
            break;
          case 2:
            partitionCdf = this.TilePartitionW16Cdf[ctx];
            break;
          case 3:
            partitionCdf = this.TilePartitionW32Cdf[ctx];
            break;
          case 4:
            partitionCdf = this.TilePartitionW64Cdf[ctx];
            break;
          default:
            partitionCdf = this.TilePartitionW128Cdf[ctx];
        }
        let psum = (partitionCdf[PARTITION_HORZ] - partitionCdf[PARTITION_HORZ - 1] +
          partitionCdf[PARTITION_SPLIT] - partitionCdf[PARTITION_SPLIT - 1] +
          partitionCdf[PARTITION_HORZ_A] - partitionCdf[PARTITION_HORZ_A - 1] +
          partitionCdf[PARTITION_HORZ_B] - partitionCdf[PARTITION_HORZ_B - 1] +
          partitionCdf[PARTITION_VERT_A] - partitionCdf[PARTITION_VERT_A - 1]);
        if (data.bsize != BLOCK_128X128)
          psum += partitionCdf[PARTITION_HORZ_4] - partitionCdf[PARTITION_HORZ_4 - 1];
        // libaom与av1文档不一致
        let cdf = [-psum, 0, 0];
        return this.S2({ b, h }, cdf);
      }
      case "tx_depth": {
        let maxTxWidth = Tx_Width[h.maxRectTxSize];
        let maxTxHeight = Tx_Height[h.maxRectTxSize];
        let aboveW = 0;
        if (h.AvailU && h[`IsInters[${h.MiRow - 1}][${h.MiCol}]`]) {
          aboveW = Block_Width[h[`MiSizes[${h.MiRow - 1}][${h.MiCol}]`]];
        } else if (h.AvailU) {
          aboveW = get_above_tx_width(h.MiRow, h.MiCol);
        }
        let leftH = 0;
        if (h.AvailL && h.IsInters[h.MiRow][h.MiCol - 1]) {
          leftH = Block_Height[h[`MiSizes[${h.MiRow}][${h.MiCol - 1}]`]];
        } else if (h.AvailL) {
          leftH = get_left_tx_height(h.MiRow, h.MiCol);
        }
        let ctx = Number(aboveW >= maxTxWidth) + Number(leftH >= maxTxHeight);
        return this.S2({ b, h }, this.TileTxfmSplitCdf[ctx]);
      }
      case "txfm_split": {
        let above = get_above_tx_width(h.row, h.col) < Tx_Width[h.txSz];
        let left = get_left_tx_height(h.row, h.col) < Tx_Height[h.txSz];
        let size = Math.min(64, Math.max(Block_Width[h.MiSize], Block_Height[h.MiSize]));
        let maxTxSz = this.find_tx_size(size, size);
        let txSzSqrUp = Tx_Size_Sqr_Up[h.txSz];
        let ctx = Number(txSzSqrUp != maxTxSz) * 3 +
          (TX_SIZES - 1 - maxTxSz) * 6 + Number(above) + Number(left);
        return this.S2({ b, h }, this.TileTxfmSplitCdf[ctx]);
      }
      case "segment_id": {
        let ctx = 0;
        if (h.prevUL < 0)
          ctx = 0;
        else if ((h.prevUL == h.prevU) && (h.prevUL == h.prevL))
          ctx = 2;
        else if ((h.prevUL == h.prevU) || (h.prevUL == h.prevL) || (h.prevU == h.prevL))
          ctx = 1;
        return this.S2({ b, h }, this.TileSegmentIdCdf[ctx]);
      }
      case "seg_id_predicted": {
        let ctx = h[`LeftSegPredContext[${h.MiRow}]`] + h[`AboveSegPredContext[${h.MiCol}]`];
        return this.S2({ b, h }, this.TileSegmentIdPredictedCdf[ctx]);
      }
      case "new_mv": {
        return this.S2({ b, h }, this.TileNewMvCdf[h.NewMvContext]);
      }
      case "Zero_mv": {
        return this.S2({ b, h }, this.TileZeroMvCdf[h.ZeroMvContext]);
      }
      case "ref_mv": {
        return this.S2({ b, h }, this.TileRefMvCdf[h.RefMvContext]);
      }
      case "drl_mode": {
        return this.S2({ b, h }, this.TileDrlModeCdf[h[`DrlCtxStack[${h.idx}]`]]);
      }
      case "is_inter": {
        let ctx = 0;
        if (h.AvailU && h.AvailL)
          ctx = (h.LeftIntra && h.AboveIntra) ? 3 : h.LeftIntra || h.AboveIntra;
        else if (h.AvailU || h.AvailL)
          ctx = 2 * (h.AvailU ? h.AboveIntra : h.LeftIntra);
        return this.S2({ b, h }, this.TileIsInterCdf[ctx]);
      }
      case "use_filter_intra": {
        return this.S2({ b, h }, this.TileFilterIntraCdf[h.MiSize]);
      }
      case "filter_intra_mode": {
        return this.S2({ b, h }, this.TileFilterIntraModeCdf);
      }
      case "comp_mode": {
        let check_backward = function (refFrame: number): number {
          return Number(refFrame >= BWDREF_FRAME && refFrame <= ALTREF_FRAME);
        }
        let ctx = 1;
        if (h.AvailU && h.AvailL) {
          if (h.AboveSingle && h.LeftSingle) {
            ctx = check_backward(h[`AboveRefFrame[0]`]) ^ check_backward(h[`LeftRefFrame[0]`]) ? 1 : 0;
          } else if (h.AboveSingle) {
            ctx = 2 + (check_backward(h[`AboveRefFrame[0]`]) || h.AboveIntra ? 1 : 0);
          } else if (h.LeftSingle) {
            ctx = 2 + (check_backward(h[`LeftRefFrame[0]`]) || h.LeftIntra ? 1 : 0);
          } else {
            ctx = 4;
          }
        } else if (h.AvailU) {
          if (h.AboveSingle) {
            ctx = check_backward(h.AboveRefFrame[0]) ? 1 : 0;
          } else {
            ctx = 3;
          }
        } else if (h.AvailL) {
          if (h.LeftSingle) {
            ctx = check_backward(h.LeftRefFrame[0]) ? 1 : 0;
          } else {
            ctx = 3;
          }
        }
        return this.S2({ b, h }, this.TileCompModeCdf[ctx]);
      }
      case "Skip_mode": {
        let ctx = 0;
        if (h.AvailU)
          ctx += h[`SkipModes[${h.MiRow - 1}][${h.MiCol}]`];
        if (h.AvailL)
          ctx += h[`SkipModes[${h.MiRow}][${h.MiCol - 1}]`];
        return this.S2({ b, h }, this.TileSkipModeCdf[ctx]);
      }
      case "Skip": {
        let ctx = 0;
        if (h.AvailU)
          ctx += h[`Skips[${h.MiRow - 1}][${h.MiCol}]`];
        if (h.AvailL)
          ctx += h[`Skips[${h.MiRow}][${h.MiCol - 1}]`];
        return this.S2({ b, h }, this.TileSkipCdf[ctx]);
      }
      case "comp_ref": {
        let last12Count = count_refs(LAST_FRAME) + count_refs(LAST2_FRAME)
        let last3GoldCount = count_refs(LAST3_FRAME) + count_refs(GOLDEN_FRAME)
        let ctx = ref_count_ctx(last12Count, last3GoldCount);
        return this.S2({ b, h }, this.TileCompRefCdf[ctx][0]);
      }
      case "comp_ref_p1": {
        let lastCount = count_refs(LAST_FRAME);
        let last2Count = count_refs(LAST2_FRAME);
        let ctx = ref_count_ctx(lastCount, last2Count);
        return this.S2({ b, h }, this.TileCompRefCdf[ctx][1]);
      }
      case "comp_ref_p2": {
        let last3Count = count_refs(LAST3_FRAME);
        let goldCount = count_refs(GOLDEN_FRAME);
        let ctx = ref_count_ctx(last3Count, goldCount);
        return this.S2({ b, h }, this.TileCompRefCdf[ctx][2]);
      }
      case "comp_bwdref": {
        let brfarf2Count = count_refs(BWDREF_FRAME) + count_refs(ALTREF2_FRAME);
        let arfCount = count_refs(ALTREF_FRAME);
        let ctx = ref_count_ctx(brfarf2Count, arfCount);
        return this.S2({ b, h }, this.TileCompBwdRefCdf[ctx][0]);
      }
      case "comp_bwdref_p1": {
        let brfCount = count_refs(BWDREF_FRAME);
        let arf2Count = count_refs(ALTREF2_FRAME);
        let ctx = ref_count_ctx(brfCount, arf2Count);
        return this.S2({ b, h }, this.TileCompBwdRefCdf[ctx][1]);
      }
      case "single_ref_p1": {
        let fwdCount = count_refs(LAST_FRAME);
        fwdCount += count_refs(LAST2_FRAME);
        fwdCount += count_refs(LAST3_FRAME);
        fwdCount += count_refs(GOLDEN_FRAME);
        let bwdCount = count_refs(BWDREF_FRAME);
        bwdCount += count_refs(ALTREF2_FRAME);
        bwdCount += count_refs(ALTREF_FRAME);
        let ctx = ref_count_ctx(fwdCount, bwdCount);
        return this.S2({ b, h }, this.TileSingleRefCdf[ctx][0]);
      }
      case "single_ref_p2": {
        let fwdCount = count_refs(LAST_FRAME);
        fwdCount += count_refs(LAST2_FRAME);
        fwdCount += count_refs(LAST3_FRAME);
        fwdCount += count_refs(GOLDEN_FRAME);
        let bwdCount = count_refs(BWDREF_FRAME);
        bwdCount += count_refs(ALTREF2_FRAME);
        bwdCount += count_refs(ALTREF_FRAME);
        let ctx = ref_count_ctx(fwdCount, bwdCount);
        return this.S2({ b, h }, this.TileSingleRefCdf[ctx][1]);
      }
      case "single_ref_p3": {
        let fwdCount = count_refs(LAST_FRAME);
        fwdCount += count_refs(LAST2_FRAME);
        fwdCount += count_refs(LAST3_FRAME);
        fwdCount += count_refs(GOLDEN_FRAME);
        let bwdCount = count_refs(BWDREF_FRAME);
        bwdCount += count_refs(ALTREF2_FRAME);
        bwdCount += count_refs(ALTREF_FRAME);
        let ctx = ref_count_ctx(fwdCount, bwdCount);
        return this.S2({ b, h }, this.TileSingleRefCdf[ctx][2]);
      }
      case "single_ref_p4": {
        let fwdCount = count_refs(LAST_FRAME);
        fwdCount += count_refs(LAST2_FRAME);
        fwdCount += count_refs(LAST3_FRAME);
        fwdCount += count_refs(GOLDEN_FRAME);
        let bwdCount = count_refs(BWDREF_FRAME);
        bwdCount += count_refs(ALTREF2_FRAME);
        bwdCount += count_refs(ALTREF_FRAME);
        let ctx = ref_count_ctx(fwdCount, bwdCount);
        return this.S2({ b, h }, this.TileSingleRefCdf[ctx][3]);
      }
      case "single_ref_p5": {
        let fwdCount = count_refs(LAST_FRAME);
        fwdCount += count_refs(LAST2_FRAME);
        fwdCount += count_refs(LAST3_FRAME);
        fwdCount += count_refs(GOLDEN_FRAME);
        let bwdCount = count_refs(BWDREF_FRAME);
        bwdCount += count_refs(ALTREF2_FRAME);
        bwdCount += count_refs(ALTREF_FRAME);
        let ctx = ref_count_ctx(fwdCount, bwdCount);
        return this.S2({ b, h }, this.TileSingleRefCdf[ctx][4]);
      }
      case "single_ref_p6": {
        let fwdCount = count_refs(LAST_FRAME);
        fwdCount += count_refs(LAST2_FRAME);
        fwdCount += count_refs(LAST3_FRAME);
        fwdCount += count_refs(GOLDEN_FRAME);
        let bwdCount = count_refs(BWDREF_FRAME);
        bwdCount += count_refs(ALTREF2_FRAME);
        bwdCount += count_refs(ALTREF_FRAME);
        let ctx = ref_count_ctx(fwdCount, bwdCount);
        return this.S2({ b, h }, this.TileSingleRefCdf[ctx][5]);
      }
      case "compound_mode": {
        const Compound_Mode_Ctx_Map = [
          [0, 1, 1, 1, 1],
          [1, 2, 3, 4, 4],
          [4, 4, 5, 6, 7]
        ];
        let ctx = Compound_Mode_Ctx_Map[h.RefMvContext >> 1][Math.min(h.NewMvContext, COMP_NEWMV_CTXS - 1)];
        return this.S2({ b, h }, this.TileCompoundModeCdf[ctx]);
      }
      case "interp_filter": {
        let ctx = ((h.dir & 1) * 2 + Number(h[`RefFrame[1]`] > INTRA_FRAME)) * 4;
        let leftType = 3;
        let aboveType = 3;

        if (h.AvailL) {
          if (
            h[`RefFrames[${h.MiRow}][${h.MiCol - 1}][0]`] == h[`RefFrame[0]`] ||
            h[`RefFrames[${h.MiRow}][${h.MiCol - 1}][1]`] == h[`RefFrame[0]`]
          ) {
            leftType = h[`InterpFilters[${h.MiRow}][${h.MiCol - 1}][${h.dir}]`];
          }
        }

        if (h.AvailU) {
          if (
            h[`RefFrames[${h.MiRow - 1}][${h.MiCol}][0]`] == h[`RefFrame[0]`] ||
            h[`RefFrames[${h.MiRow - 1}][${h.MiCol}][1]`] == h[`RefFrame[0]]`]
          ) {
            aboveType = h[`InterpFilters[${h.MiRow - 1}][${h.MiCol}][${h.dir}]`];
          }
        }

        if (leftType == aboveType) {
          ctx += leftType;
        } else if (leftType == 3) {
          ctx += aboveType;
        } else if (aboveType == 3) {
          ctx += leftType;
        } else {
          ctx += 3;
        }
        return this.S2({ b, h }, this.TileInterpFilterCdf[ctx]);
      }
      case "motion_mode": {
        return this.S2({ b, h }, this.TileMotionModeCdf[h.MiSize]);
      }
      case "mv_joint": {
        return this.S2({ b, h }, this.TileMvJointCdf);
        // return this.S2({ b, h }, this.TileMvJointCdf[h.MvCtx]);
      }
      case "mv_sign": {
        return this.S2({ b, h }, this.TileMvSignCdf);
        // return this.S2({ b, h }, this.TileMvSignCdf[h.MvCtx][h.comp]);
      }
      case "mv_class": {
        return this.S2({ b, h }, this.TileMvClassCdf[h.MvCtx]);
        // return this.S2({ b, h }, this.TileMvClassCdf[h.MvCtx][h.comp]);
      }
      case "mv_class0_bit": {
        return this.S2({ b, h }, this.TileMvClass0BitCdf);
        // return this.S2({ b, h }, this.TileMvClass0BitCdf[h.MvCtx][h.comp]);
      }
      case "mv_class0_fr": {
        return this.S2({ b, h }, this.TileMvClass0FrCdf[h.MvCtx][h.mv_class0_bit]);
        // return this.S2({ b, h }, this.TileMvClass0FrCdf[h.MvCtx][h.comp][h.mv_class0_bit]);
      }
      case "mv_class0_hp": {
        return this.S2({ b, h }, this.TileMvClass0HpCdf);
        // return this.S2({ b, h }, this.TileMvClass0HpCdf[h.MvCtx][h.comp]);
      }
      case "mv_fr": {
        return this.S2({ b, h }, this.TileMvFrCdf[h.MvCtx]);
        // return this.S2({ b, h }, this.TileMvFrCdf[h.MvCtx][h.comp]);
      }
      case "mv_hp": {
        return this.S2({ b, h }, this.TileMvHpCdf);
        // return this.S2({ b, h }, this.TileMvHpCdf[MvCtx][comp]);
      }
      case "mv_bit": {
        return this.S2({ b, h }, this.TileMvBitCdf[h.MvCtx]);
        // return this.S2({ b, h }, this.TileMvBitCdf[MvCtx][comp][i]);
      }
      case "all_zero": {
        let maxX4 = h.MiCols;
        let maxY4 = h.MiRows;

        if (data.plane > 0) {
          maxX4 = maxX4 >> this.seq_header.subsampling_x;
          maxY4 = maxY4 >> this.seq_header.subsampling_y;
        }

        let width = Tx_Width[data.txSz];
        let height = Tx_Height[data.txSz];

        let bsize = this.get_plane_residual_size({ b, h }, h.MiSize, data.plane);
        let bw = Block_Width[bsize];
        let bh = Block_Height[bsize];
        let ctx = 0;

        if (data.plane == 0) {
          let top = 0;
          let left = 0;

          for (let k = 0; k < data.w4; k++) {
            if (data.x4 + k < maxX4) {
              top = Math.max(top, h[`AboveLevelContext[${data.plane}][${data.x4 + k}]`]);
              if (top == undefined) {
                console.error("top is undefined, from AboveLevelContext");
              }
            }
          }

          for (let k = 0; k < data.h4; k++) {
            if (data.y4 + k < maxY4) {
              left = Math.max(left, h[`LeftLevelContext[${data.plane}][${data.y4 + k}]`]);
              if (left == undefined) {
                console.error("left is undefined, from LeftLevelContext");
              }
            }
          }

          top = Math.min(top, 255);
          left = Math.min(left, 255);

          if (bw == width && bh == height) {
            ctx = 0;
          } else if (top == 0 && left == 0) {
            ctx = 1;
          } else if (top == 0 || left == 0) {
            ctx = 2 + Number(Math.max(top, left) > 3);
          } else if (Math.max(top, left) <= 3) {
            ctx = 4;
          } else if (Math.min(top, left) <= 3) {
            ctx = 5;
          } else {
            ctx = 6;
          }
        } else {
          let above = 0;
          let left = 0;

          for (let i = 0; i < data.w4; i++) {
            if (data.x4 + i < maxX4) {
              if (h[`AboveLevelContext[${data.plane}][${data.x4 + i}]`] == undefined) {
                console.error("above is undefined, from AboveLevelContext");
              }
              if (h[`AboveDcContext[${data.plane}][${data.x4 + i}]`] == undefined) {
                console.error("above is undefined, from AboveDcContext");
              }
              above |= h[`AboveLevelContext[${data.plane}][${data.x4 + i}]`];
              above |= h[`AboveDcContext[${data.plane}][${data.x4 + i}]`];
            }
          }

          for (let i = 0; i < data.h4; i++) {
            if (data.y4 + i < maxY4) {
              if (h[`LeftLevelContext[${data.plane}][${data.y4 + i}]`] == undefined) {
                console.error("left is undefined, from LeftLevelContext");
              }
              if (h[`LeftDcContext[${data.plane}][${data.y4 + i}]`] == undefined) {
                console.error("left is undefined, from LeftDcContext");
              }
              left |= h[`LeftLevelContext[${data.plane}][${data.y4 + i}]`];
              left |= h[`LeftDcContext[${data.plane}][${data.y4 + i}]`];
            }
          }

          ctx = Number(above != 0) + Number(left != 0);
          ctx += 7;

          if (bw * bh > width * height) {
            ctx += 3;
          }
        }
        return this.S2({ b, h }, this.TxbSkipCdf[data.txSzCtx][ctx]);
        // return this.S2({ b, h }, this.TileTxbSkipCdf[txSzCtx][ctx]);
      }
      case "eob_pt_16": {
        let txType = this.compute_tx_type({ b, h }, data.plane, data.txSz, data.x4, data.y4);
        let ctx = (get_tx_class(txType) == TX_CLASS_2D) ? 0 : 1;
        return this.S2({ b, h }, this.EobPt16Cdf[data.ptype][ctx]);
      }
      case "eob_pt_32": {
        let txType = this.compute_tx_type({ b, h }, data.plane, data.txSz, data.x4, data.y4);
        let ctx = (get_tx_class(txType) == TX_CLASS_2D) ? 0 : 1;
        return this.S2({ b, h }, this.EobPt32Cdf[data.ptype][ctx]);
      }
      case "eob_pt_64": {
        let txType = this.compute_tx_type({ b, h }, data.plane, data.txSz, data.x4, data.y4);
        let ctx = (get_tx_class(txType) == TX_CLASS_2D) ? 0 : 1;
        return this.S2({ b, h }, this.EobPt64Cdf[data.ptype][ctx]);
      }
      case "eob_pt_128": {
        let txType = this.compute_tx_type({ b, h }, data.plane, data.txSz, data.x4, data.y4);
        let ctx = (get_tx_class(txType) == TX_CLASS_2D) ? 0 : 1;
        return this.S2({ b, h }, this.EobPt128Cdf[data.ptype][ctx]);
      }
      case "eob_pt_256": {
        let txType = this.compute_tx_type({ b, h }, data.plane, data.txSz, data.x4, data.y4);
        let ctx = (get_tx_class(txType) == TX_CLASS_2D) ? 0 : 1;
        return this.S2({ b, h }, this.EobPt256Cdf[data.ptype][ctx]);
      }
      case "eob_pt_512": {
        return this.S2({ b, h }, this.EobPt512Cdf[data.ptype]);
      }
      case "eob_pt_1024": {
        return this.S2({ b, h }, this.EobPt1024Cdf[data.ptype]);
      }
      case "eob_extra": {
        return this.S2({ b, h }, this.EobExtraCdf[data.txSzCtx][data.ptype][data.eobPt - 3]);
      }
      case "coeff_base": {
        let ctx = get_coeff_base_ctx(data.txSz, data.plane, data.x4, data.y4, data.scan[data.c], data.c, 0);
        return this.S2({ b, h }, this.CoeffBaseCdf[data.txSzCtx][data.ptype][ctx]);
      }
      case "coeff_base_eob": {
        let ctx = get_coeff_base_ctx(data.txSz, data.plane, data.x4, data.y4, data.scan[data.c], data.c, 1) - SIG_COEF_CONTEXTS + SIG_COEF_CONTEXTS_EOB;
        return this.S2({ b, h }, this.CoeffBaseEobCdf[data.txSzCtx][data.ptype][ctx]);
      }
      case "dc_sign": {
        let maxX4 = h.MiCols;
        let maxY4 = h.MiRows;

        if (data.plane > 0) {
          maxX4 = maxX4 >> this.seq_header.subsampling_x;
          maxY4 = maxY4 >> this.seq_header.subsampling_y;
        }

        let dcSign = 0;

        for (let k = 0; k < data.w4; k++) {
          if (data.x4 + k < maxX4) {
            let sign = h[`AboveDcContext[${data.plane}][${data.x4 + k}]`];
            if (sign == undefined) {
              console.error("sign is undefined, from AboveDcContext");
            }
            if (sign == 1) {
              dcSign--;
            } else if (sign == 2) {
              dcSign++;
            }
          }
        }

        for (let k = 0; k < data.h4; k++) {
          if (data.y4 + k < maxY4) {
            let sign = h[`LeftDcContext[${data.plane}][${data.y4 + k}]`];
            if (sign == undefined) {
              console.error("sign is undefined, from LeftDcContext");
            }
            if (sign == 1) {
              dcSign--;
            } else if (sign == 2) {
              dcSign++;
            }
          }
        }

        let ctx = 0;
        if (dcSign < 0) {
          ctx = 1;
        } else if (dcSign > 0) {
          ctx = 2;
        }
        return this.S2({ b, h }, this.DcSignCdf[data.ptype][ctx]);
      }
      case "coeff_br": {
        const Mag_Ref_Offset_With_Tx_Class = [
          [[0, 1], [1, 0], [1, 1]],
          [[0, 1], [1, 0], [0, 2]],
          [[0, 1], [1, 0], [2, 0]]
        ];
        let adjTxSz = Adjusted_Tx_Size[data.txSz];
        let bwl = Tx_Width_Log2[adjTxSz];
        let txw = Tx_Width[adjTxSz];
        let txh = Tx_Height[adjTxSz];
        let row = data.pos >> bwl;
        let col = data.pos - (row << bwl);
        let mag = 0;

        let txType = this.compute_tx_type({ b, h }, data.plane, data.txSz, data.x4, data.y4);
        let txClass = get_tx_class(txType);

        for (let idx = 0; idx < 3; idx++) {
          let refRow = row + Mag_Ref_Offset_With_Tx_Class[txClass][idx][0];
          let refCol = col + Mag_Ref_Offset_With_Tx_Class[txClass][idx][1];
          if (
            refRow >= 0 &&
            refCol >= 0 &&
            refRow < txh &&
            refCol < (1 << bwl)
          ) {
            mag += Math.min(h[`Quant[${refRow * txw + refCol}]`], COEFF_BASE_RANGE + NUM_BASE_LEVELS + 1);
          }
        }

        mag = Math.min((mag + 1) >> 1, 6);

        let ctx = 0;
        if (data.pos == 0) {
          ctx = mag;
        } else if (txClass == 0) {
          if (row < 2 && col < 2) {
            ctx = mag + 7;
          } else {
            ctx = mag + 14;
          }
        } else {
          if (txClass == 1) {
            if (col == 0) {
              ctx = mag + 7;
            } else {
              ctx = mag + 14;
            }
          } else {
            if (row == 0) {
              ctx = mag + 7;
            } else {
              ctx = mag + 14;
            }
          }
        }
        return this.S2({ b, h }, this.CoeffBrCdf[Math.min(data.txSzCtx, TX_32X32)][data.ptype][ctx]);
      }
      case "has_palette_y": {
        let ctx = 0;
        if (h.AvailU && h[`PaletteSizes[0][${h.MiRow - 1}][${h.MiCol}]`] > 0)
          ctx += 1;
        if (h.AvailL && h[`PaletteSizes[0][${h.MiRow}][${h.MiCol - 1}]`] > 0)
          ctx += 1;
        return this.S2({ b, h }, this.TilePaletteYModeCdf[h.bsizeCtx][ctx]);
      }
      case "has_palette_uv": {
        let ctx = (h.PaletteSizeY > 0) ? 1 : 0;
        return this.S2({ b, h }, this.TilePaletteUVModeCdf[ctx]);
      }
      case "Palette_size_y_minus_2": {
        return this.S2({ b, h }, this.TilePaletteYSizeCdf[h.bsizeCtx]);
      }
      case "Palette_size_uv_minus_2": {
        return this.S2({ b, h }, this.TilePaletteUVSizeCdf[h.bsizeCtx]);
      }
      case "palette_color_idx_y": {
        let ctx = Palette_Color_Context[h.ColorContextHash];
        if (h.PaletteSizeY == 2) {
          return this.S2({ b, h }, this.TilePaletteSize2YColorCdf[ctx]);
        } else if (h.PaletteSizeY == 3) {
          return this.S2({ b, h }, this.TilePaletteSize3YColorCdf[ctx]);
        } else if (h.PaletteSizeY == 4) {
          return this.S2({ b, h }, this.TilePaletteSize4YColorCdf[ctx]);
        } else if (h.PaletteSizeY == 5) {
          return this.S2({ b, h }, this.TilePaletteSize5YColorCdf[ctx]);
        } else if (h.PaletteSizeY == 6) {
          return this.S2({ b, h }, this.TilePaletteSize6YColorCdf[ctx]);
        } else if (h.PaletteSizeY == 7) {
          return this.S2({ b, h }, this.TilePaletteSize7YColorCdf[ctx]);
        } else if (h.PaletteSizeY == 8) {
          return this.S2({ b, h }, this.TilePaletteSize8YColorCdf[ctx]);
        }
        return 0;
      }
      case "Palette_color_idx_uv": {
        let ctx = Palette_Color_Context[h.ColorContextHash];
        if (h.PaletteSizeUV == 2) {
          return this.S2({ b, h }, this.TilePaletteSize2UVColorCdf[ctx]);
        } else if (h.PaletteSizeUV == 3) {
          return this.S2({ b, h }, this.TilePaletteSize3UVColorCdf[ctx]);
        } else if (h.PaletteSizeUV == 4) {
          return this.S2({ b, h }, this.TilePaletteSize4UVColorCdf[ctx]);
        } else if (h.PaletteSizeUV == 5) {
          return this.S2({ b, h }, this.TilePaletteSize5UVColorCdf[ctx]);
        } else if (h.PaletteSizeUV == 6) {
          return this.S2({ b, h }, this.TilePaletteSize6UVColorCdf[ctx]);
        } else if (h.PaletteSizeUV == 7) {
          return this.S2({ b, h }, this.TilePaletteSize7UVColorCdf[ctx]);
        } else if (h.PaletteSizeUV == 8) {
          return this.S2({ b, h }, this.TilePaletteSize8UVColorCdf[ctx]);
        }
        return 0;
      }
      case "delta_q_abs": {
        return this.S2({ b, h }, this.TileDeltaQCdf);
      }
      case "delta_lf_ab": {
        if (h.delta_lf_multi == 0) {
          return this.S2({ b, h }, this.TileDeltaLFCdf);
        } else if (h.delta_lf_multi == 1) {
          return this.S2({ b, h }, this.TileDeltaLFMultiCdf);
        }
        return 0;
      }
      case "intra_tx_type": {
        const Filter_Intra_Mode_To_Intra_Dir = [
          DC_PRED,
          V_PRED,
          H_PRED,
          D157_PRED,
          DC_PRED
        ];
        let intraDir = 0;
        if (h.use_filter_intra === 1) {
          intraDir = Filter_Intra_Mode_To_Intra_Dir[h.filter_intra_mode];
        } else if (h.use_filter_intra === 0) {
          intraDir = h.YMode;
        }

        let cdf: number[] = [];
        if (data.set === TX_SET_INTRA_1) {
          cdf = this.TileIntraTxTypeSet1Cdf[Tx_Size_Sqr[data.txSz]][intraDir];
        } else if (data.set === TX_SET_INTRA_2) {
          cdf = this.TileIntraTxTypeSet2Cdf[Tx_Size_Sqr[data.txSz]][intraDir];
        }
        return this.S2({ b, h }, cdf);
      }
      case "inter_tx_type": {
        let cdf: number[] = [];
        if (h.set === TX_SET_INTER_1) {
          cdf = this.TileInterTxTypeSet1Cdf[Tx_Size_Sqr[h.txSz]];
        } else if (h.set === TX_SET_INTER_2) {
          cdf = this.TileInterTxTypeSet2Cdf;
        } else if (h.set === TX_SET_INTER_3) {
          cdf = this.TileInterTxTypeSet3Cdf[Tx_Size_Sqr[h.txSz]];
        }
        return this.S2({ b, h }, cdf);
      }
      case "comp_ref_type": {
        let is_samedir_ref_pair = function (ref0: number, ref1: number) {
          return Number((ref0 >= BWDREF_FRAME) === (ref1 >= BWDREF_FRAME));
        }
        let above0 = h[`AboveRefFrame[0]`];
        let above1 = h[`AboveRefFrame[1]`];
        let left0 = h[`LeftRefFrame[0]`];
        let left1 = h[`LeftRefFrame[1]`];
        let aboveCompInter = h.AvailU && !h.AboveIntra && !h.AboveSingle;
        let leftCompInter = h.AvailL && !h.LeftIntra && !h.LeftSingle;
        let aboveUniComp = aboveCompInter && is_samedir_ref_pair(above0, above1);
        let leftUniComp = leftCompInter && is_samedir_ref_pair(left0, left1);
        let ctx = 2;

        if (h.AvailU && !h.AboveIntra && h.AvailL && !h.LeftIntra) {
          let samedir = is_samedir_ref_pair(above0, left0);

          if (!aboveCompInter && !leftCompInter) {
            ctx = 1 + 2 * samedir;
          } else if (!aboveCompInter) {
            if (!leftUniComp) {
              ctx = 1;
            } else {
              ctx = 3 + samedir;
            }
          } else if (!leftCompInter) {
            if (!aboveUniComp) {
              ctx = 1;
            } else {
              ctx = 3 + samedir;
            }
          } else {
            if (!aboveUniComp && !leftUniComp) {
              ctx = 0;
            } else if (!aboveUniComp || !leftUniComp) {
              ctx = 2;
            } else {
              ctx = 3 + Number((above0 == BWDREF_FRAME) == (left0 == BWDREF_FRAME));
            }
          }
        } else if (h.AvailU && h.AvailL) {
          if (aboveCompInter) {
            ctx = 1 + 2 * aboveUniComp;
          } else if (leftCompInter) {
            ctx = 1 + 2 * leftUniComp;
          } else {
            ctx = 2;
          }
        } else if (aboveCompInter) {
          ctx = 4 * aboveUniComp;
        } else if (leftCompInter) {
          ctx = 4 * leftUniComp;
        }
        return this.S2({ b, h }, this.TileCompRefTypeCdf[ctx]);
      }
      case "uni_comp_ref": {
        let fwdCount = count_refs(LAST_FRAME);
        fwdCount += count_refs(LAST2_FRAME);
        fwdCount += count_refs(LAST3_FRAME);
        fwdCount += count_refs(GOLDEN_FRAME);
        let bwdCount = count_refs(BWDREF_FRAME);
        bwdCount += count_refs(ALTREF2_FRAME);
        bwdCount += count_refs(ALTREF_FRAME);
        let ctx = ref_count_ctx(fwdCount, bwdCount);
        return this.S2({ b, h }, this.TileUniCompRefCdf[ctx][0]);
      }
      case "uni_comp_ref_p1": {
        let last2Count = count_refs(LAST2_FRAME);
        let last3GoldCount = count_refs(LAST3_FRAME) + count_refs(GOLDEN_FRAME);
        let ctx = ref_count_ctx(last2Count, last3GoldCount);
        return this.S2({ b, h }, this.TileUniCompRefCdf[ctx][1]);
      }
      case "uni_comp_ref_p2": {
        let last3Count = count_refs(LAST3_FRAME);
        let goldCount = count_refs(GOLDEN_FRAME);
        let ctx = ref_count_ctx(last3Count, goldCount);
        return this.S2({ b, h }, this.TileUniCompRefCdf[ctx][2]);
      }
      case "comp_group_idx": {
        let ctx = 0;
        if (h.AvailU) {
          if (!h.AboveSingle) {
            ctx += h[`CompGroupIdxs[${h.MiRow - 1}][${h.MiCol}]`];
          } else if (h[`AboveRefFrame[0]`] === ALTREF_FRAME) {
            ctx += 3;
          }
        }

        if (h.AvailL) {
          if (!h.LeftSingle) {
            ctx += h[`CompGroupIdxs[${h.MiRow}][${h.MiCol - 1}]`];
          } else if (h[`LeftRefFrame[0]`] === ALTREF_FRAME) {
            ctx += 3;
          }
        }

        ctx = Math.min(5, ctx);
        return this.S2({ b, h }, this.TileCompGroupIdxCdf[ctx]);
      }
      case "compound_idx": {
        let fwd = Math.abs(this.get_relative_dist(h[`OrderHints[${h['RefFrame[0]']}]`], h.OrderHint));
        let bck = Math.abs(this.get_relative_dist(h[`OrderHints[${h['RefFrame[1]']}]`], h.OrderHint));
        let ctx = (fwd === bck) ? 3 : 0;

        if (h.AvailU) {
          if (!h.AboveSingle) {
            ctx += h[`CompoundIdxs[${h.MiRow - 1}][${h.MiCol}]`];
          } else if (h[`AboveRefFrame[0]`] === ALTREF_FRAME) {
            ctx++;
          }
        }

        if (h.AvailL) {
          if (!h.LeftSingle) {
            ctx += h[`CompoundIdxs[${h.MiRow}][${h.MiCol - 1}]`];
          } else if (h[`LeftRefFrame[0]`] === ALTREF_FRAME) {
            ctx++;
          }
        }
        return this.S2({ b, h }, this.TileCompoundIdxCdf[ctx]);
      }
      case "compound_type": {
        return this.S2({ b, h }, this.TileCompoundTypeCdf[h.MiSize]);
      }
      case "interintra": {
        let ctx = Size_Group[h.MiSize] - 1;
        return this.S2({ b, h }, this.TileInterIntraCdf[ctx]);
      }
      case "interintra_mode": {
        let ctx = Size_Group[h.MiSize] - 1;
        return this.S2({ b, h }, this.TileInterIntraModeCdf[ctx]);
      }
      case "wedge_index": {
        return this.S2({ b, h }, this.TileWedgeIndexCdf[h.MiSize]);
      }
      case "wedge_interintra": {
        return this.S2({ b, h }, this.TileWedgeInterIntraCdf[h.MiSize]);
      }
      case "use_obmc": {
        return this.S2({ b, h }, this.TileUseObmcCdf[h.MiSize]);
      }
      case "cfl_alpha_signs": {
        return this.S2({ b, h }, this.TileCflSignCdf);
      }
      case "cfl_alpha_u": {
        let ctx = (data.signU - 1) * 3 + data.signV;
        return this.S2({ b, h }, this.TileCflAlphaCdf[ctx]);
      }
      case "cfl_alpha_v": {
        let ctx = (data.signV - 1) * 3 + data.signU;
        return this.S2({ b, h }, this.TileCflAlphaCdf[ctx]);
      }
      case "use_wiener": {
        return this.S2({ b, h }, this.TileUseWienerCdf);
      }
      case "use_sgrproj": {
        return this.S2({ b, h }, this.TileUseSgrprojCdf);
      }
      case "restoration_type": {
        return this.S2({ b, h }, this.TileRestorationTypeCdf);
      }
    }
  }

  aom_read_bit({ b, h }: { b: BitReader, h: any }) {
    const prob = 128;
    const f = (0x7FFFFF - (prob << 15) + prob) >>> 8;

    let dif = h.SymbolValue;
    let r = h.SymbolRange;
    let v = ((r >>> 8) * (f >>> EC_PROB_SHIFT) >>> (7 - EC_PROB_SHIFT));
    v += EC_MIN_PROB;
    let vw = v << (32 - 16);
    let ret = 1;
    let r_new = v;
    if (dif >= vw) {
      r_new = r - v;
      dif -= vw;
      ret = 0;
    }
    h.SymbolValue = dif;
    h.SymbolRange = r_new;
    this.renormalized_symbol({ b, h });
    return ret;
  }

  L({ b, h }: { b: BitReader, h: any }, n: number): number {
    let literal = 0;
    for (let bit = n - 1; bit >= 0; bit--) {
      let ret = this.aom_read_bit({ b, h });
      literal |= ret << bit;
    }
    return literal;
  }

  L2({ b, h }: { b: BitReader, h: any }, n: number) {
    let x = 1;
    let length = 0;
    let i = 0;

    while (!i) {
      i = this.aom_read_bit({ b, h });

      ++length;
      if (length > 20) {
        console.error("Invalid length in read_golomb");
        break;
      }
    }

    for (i = 0; i < length - 1; ++i) {
      x <<= 1;
      x += this.aom_read_bit({ b, h });
    }
    return x - 1;
  }

  NS({ b, h }: { b: BitReader, h: any }, n: number) {
    let w = b.FloorLog2(n) + 1;
    let m = (1 << w) - n;
    let v = this.L({ b, h }, w - 1);
    if (v < m)
      return v;
    let extra_bit = this.L({ b, h }, 1);
    return (v << 1) - m + extra_bit;
  }

  // 5.3.1. General OBU syntax
  open_bitstream_unit(sz: number, { b, h }: { b: BitReader, h: any }) {
    this.obu_header({ b, h });
    if (h.obu_has_size_field) {
      h.obu_size = b.leb128();
    } else {
      h.obu_size = sz - 1 - h.obu_extension_flag;
    }
    let startPosition = b.get_position();

    if (h.obu_type == OBU_SEQUENCE_HEADER) {
      this.sequence_header_obu({ b, h });
      h['@type'] = "OBU_SEQUENCE_HEADER";
    } else if (h.obu_type == OBU_TEMPORAL_DELIMITER) {
      h['@type'] = "OBU_TEMPORAL_DELIMITER";
    } else if (h.obu_type == OBU_FRAME_HEADER) {
      this.frame_header_obu({ b, h });
      h['@type'] = "OBU_FRAME_HEADER";
    } else if (h.obu_type == OBU_TILE_GROUP) {
      this.tile_group_obu(h.obu_size, { b, h });
      h['@type'] = "OBU_TILE_GROUP";
    } else if (h.obu_type == OBU_METADATA) {
      h['@type'] = "OBU_METADATA";
    } else if (h.obu_type == OBU_FRAME) {
      this.frame_obu(h.obu_size, { b, h });
      h['@type'] = "OBU_FRAME";
    } else if (h.obu_type == OBU_REDUNDANT_FRAME_HEADER) {
      this.frame_header_obu({ b, h });
      h['@type'] = "OBU_REDUNDANT_FRAME_HEADER";
    } else if (h.obu_type == OBU_TILE_LIST) {
      this.tile_list_obu({ b, h });
      h['@type'] = "OBU_TILE_LIST";
    } else if (h.obu_type == OBU_PADDING) {
      h['@type'] = "OBU_PADDING";
    } else {
      h['@type'] = "Reserved";
    }

    return startPosition;
  }

  // 5.3.2. OBU header syntax
  obu_header({ b, h }: { b: BitReader, h: any }) {
    h.obu_forbidden_bit = b.u(1);
    if (h.obu_forbidden_bit) {
      throw Error("obu_forbidden_bit Must not be set");
    }
    h.obu_type = b.u(4);
    h.obu_extension_flag = b.u(1);  // 扩展头标志
    h.obu_has_size_field = b.u(1);  // obu大小字段
    h.obu_reserved_1bit = b.u(1);
    if (h.obu_extension_flag) {
      this.obu_extension_header({ b, h });
    } else {
      h.temporal_id = 0;  // 时间层
      h.spatial_id = 0;   // 空间层
    }
  };

  // 5.3.3. OBU extension header syntax
  obu_extension_header({ b, h }: { b: BitReader, h: any }) {
    h.temporal_id = b.u(3); // 时间层
    h.spatial_id = b.u(2);  // 空间层
    h.extension_header_reserved_3bits = b.u(3);
  }

  // 5.3.4. Trailing bits syntax
  trailing_bits({ b, h }: { b: BitReader, h: any }, nbBits: number) {
    let trailing_one_bit = b.f(1);
    nbBits--;
    while (nbBits > 0) {
      let trailing_zero_bit = b.f(1);
      nbBits--;
    }
  }

  // 5.3.5. Byte alignment syntax
  byte_alignment({ b, h }: { b: BitReader, h: any }) {
    while (b.get_position() & 7) {
      let zero_bit = b.f(1);
    }
  }

  // 5.4. Reserved OBU syntax
  reserved_obu({ b, h }: { b: BitReader, h: any }) {
  }

  // 5.5.1. General sequence header OBU syntax
  sequence_header_obu({ b, h }: { b: BitReader, h: any }) {
    /** +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     *  | seq_profile | BitDepth  | Monochrome support|        Chroma subsampling       |
     *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     *  |      0      |  8 or 10  |        yes        |            YUV 4:2:0            |
     *  |      1      |  8 or 10  |        no         |            YUV 4:4:4            |
     *  |      2      |  8 or 10  |        yes        |            YUV 4:2:2            |
     *  |      2      |    12     |        yes        | YUV 4:2:0, YUV 4:2:2, YUV 4:4:4 |
     *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     */
    h.seq_profile = b.u(3); // seq_params->profile
    if (h.seq_profile > 2) {
      throw Error("The given bitstream is not supported");
    }

    // 如果reduced_still_picture_header=1，则still_picture=1是比特流一致性的要求。
    h.still_picture = b.u(1); // =1表示编码视频序列只包含一个编码帧；=0指定编码视频序列包含一个或多个编码帧。seq_params->still_picture
    h.reduced_still_picture_header = b.u(1); // 指定省略静态图片不需要的语法元素。seq_params->reduced_still_picture_hdr
    if (!h.still_picture && h.reduced_still_picture_hdr) {
      throw Error("The given bitstream is not supported");
    }

    if (h.reduced_still_picture_header) {
      h.timing_info_present_flag = 0;           // 指定编码视频序列中是否存在定时信息。seq_params->timing_info_present
      h.decoder_model_info_present_flag = 0;    // 表示编码视频序列中是否存在解码器模型信息。seq_params->decoder_model_info_present_flag
      h.initial_display_delay_present_flag = 0; // 指定初始显示延迟信息是否出现在编码视频序列中。seq_params->display_model_info_present_flag
      h.operating_points_cnt_minus_1 = 0;       // 表示编码视频序列中存在的工作点数；操作点指定应该解码哪些空间层和时间层。seq_params->operating_points_cnt_minus_1
      h['operating_point_idc[0]'] = 0;          // 表示操作点i需要解码的空间层和时间层，时间层0~7，空间层(0~3)+8。seq_params->operating_point_idc
      h['seq_level_idx[0]'] = b.u(5);           // 选择工作点i时编码视频序列所符合的级别。seq_params->seq_level_idx
      this.is_valid_seq_level_idx(h['seq_level_idx[0]']);
      h['seq_tier[0]'] = 0;                     // 选择工作点i时，编码视频序列所遵从的层数。seq_params->tier
      h['decoder_model_present_for_this_op[0]'] = 0;  // =1表示存在与操作点i关联的解码器模型。seq_params->op_params[i].decoder_model_param_present_flag
      h['initial_display_delay_present_for_this_op[0]'] = 0;  // =1表示指定了initial_display_delay_minus_1。seq_params->op_params[i].display_model_param_present_flag
    } else {
      h.timing_info_present_flag = b.u(1);
      if (h.timing_info_present_flag) {
        this.timing_info({ b, h });
        h.decoder_model_info_present_flag = b.u(1);
        if (h.decoder_model_info_present_flag) {
          this.decoder_model_info({ b, h });
        }
      } else {
        h.decoder_model_info_present_flag = 0;
      }
      h.initial_display_delay_present_flag = b.u(1);
      h.operating_points_cnt_minus_1 = b.u(5);
      for (let i = 0; i <= h.operating_points_cnt_minus_1; i++) {
        h[`operating_point_idc[${i}]`] = b.u(12);
        h[`seq_level_idx[${i}]`] = b.u(5);
        this.is_valid_seq_level_idx(h[`seq_level_idx[${i}]`]);
        if (h[`seq_level_idx[${i}]`] > 7) {
          h[`seq_tier[${i}]`] = b.u(1);
        } else {
          h[`seq_tier[${i}]`] = 0;
        }
        if (h.decoder_model_info_present_flag) {
          h[`decoder_model_present_for_this_op[${i}]`] = b.u(1);
          if (h[`decoder_model_present_for_this_op[${i}]`]) {
            this.operating_parameters_info(i, { b, h });
          }
        } else {
          h[`decoder_model_present_for_this_op[${i}]`] = 0;
        }

        if (h.initial_display_delay_present_flag) {
          h[`initial_display_delay_present_for_this_op[${i}]`] = b.u(1);
          if (h[`initial_display_delay_present_for_this_op[${i}]`]) {
            h[`initial_display_delay_minus_1[${i}]`] = b.u(4); // 对于操作点i，在显示第一个可呈现的帧之前，缓冲池中应该出现的解码帧的数量。seq_params->op_params[i].initial_display_delay
            if (h[`initial_display_delay_minus_1[${i}]`] > 9) {
              console.error("AV1 does not support more than 10 decoded frames delay");
            }
          }
        } else {
          h[`initial_display_delay_minus_1[${i}]`] = 9;
        }
      }
    }
    h.frame_width_bits_minus_1 = b.u(4);
    h.frame_height_bits_minus_1 = b.u(4);
    h.max_frame_width_minus_1 = b.u(h.frame_width_bits_minus_1 + 1);    // 指定该seq报头表示的帧的最大帧宽。seq_params->max_frame_width
    h.max_frame_height_minus_1 = b.u(h.frame_height_bits_minus_1 + 1);  // 指定该seq报头表示的帧的最大帧高。seq_params->max_frame_height
    if (h.reduced_still_picture_header) {
      h.frame_id_numbers_present_flag = 0;      // 指定帧id号是否出现在编码视频序列中。seq_params->frame_id_numbers_present_flag
    } else {
      h.frame_id_numbers_present_flag = b.u(1);
    }
    if (h.frame_id_numbers_present_flag) {
      h.delta_frame_id_length_minus_2 = b.u(4);       // 用于编码delta_frame_id语法元素的位数。seq_params->delta_frame_id_length
      h.additional_frame_id_length_minus_1 = b.u(3);  // 计算用于编码frame_id语法元素的位数。seq_params->frame_id_length
      if (h.additional_frame_id_length_minus_1 + h.delta_frame_id_length_minus_2 > 13) {
        console.error("Invalid frame_id_length");
      }
    }
    h.use_128x128_superblock = b.u(1);  // =1时，表示超级块包含128x128个luma样本。seq_params->sb_size

    /** libaom */
    h.aom_mib_size_log2 = Mi_Width_Log2[h.use_128x128_superblock ? 15 : 12];

    h.enable_filter_intra = b.u(1);     // =1指定可以存在use_filter_intra语法元素。seq_params->enable_filter_intra
    h.enable_intra_edge_filter = b.u(1);  // 是否开启内部边缘过滤。seq_params->enable_intra_edge_filter
    if (h.reduced_still_picture_header) {
      h.enable_interintra_compound = 0; // =1指定inter blocks的模式信息可以包含语法元素interintra。seq_params->enable_interintra_compound
      h.enable_masked_compound = 0;     // =1指定块间的模式信息可以包含语法元素compound_type。seq_params->enable_masked_compound
      h.enable_warped_motion = 0;       // =1表示可能存在allow_warped_motion语法元素。seq_params->enable_warped_motion
      h.enable_dual_filter = 0;         // =1表示可以在水平方向和垂直方向独立指定内部预测过滤器类型；如果标志等于0，则只能指定一种过滤器类型，然后在两个方向上使用。seq_params->enable_dual_filter
      h.enable_order_hint = 0;          // =1表示可以使用基于订单提示值的工具。seq_params->order_hint_info.enable_order_hint
      h.enable_jnt_comp = 0;            // =1表示可以使用距离权重过程进行内部预测。seq_params->order_hint_info.enable_dist_wtd_comp
      h.enable_ref_frame_mvs = 0;       // =1表示可能存在use_ref_frame_mvs语法元素。seq_params->order_hint_info.enable_ref_frame_mvs
      h.seq_force_screen_content_tools = SELECT_SCREEN_CONTENT_TOOLS; // =SELECT_SCREEN_CONTENT_TOOLS表示allow_screen_content_tools语法元素将出现在帧头中；否则包含allow_screen_content_tools的值。seq_params->force_screen_content_tools
      h.seq_force_integer_mv = SELECT_INTEGER_MV; // =SELECT_INTEGER_MV表示force_integer_mv语法元素将出现在帧头中；否则包含force_integer_mv的值。seq_params->force_integer_mv
      h['OrderHintBits'] = 0;
    } else {
      h.enable_interintra_compound = b.u(1);
      h.enable_masked_compound = b.u(1);
      h.enable_warped_motion = b.u(1);
      h.enable_dual_filter = b.u(1);
      h.enable_order_hint = b.u(1);
      if (h.enable_order_hint) {
        h.enable_jnt_comp = b.u(1);
        h.enable_ref_frame_mvs = b.u(1);
      } else {
        h.enable_jnt_comp = 0;
        h.enable_ref_frame_mvs = 0;
      }
      h.seq_choose_screen_content_tools = b.u(1); // temp
      if (h.seq_choose_screen_content_tools) {
        h.seq_force_screen_content_tools = SELECT_SCREEN_CONTENT_TOOLS;
      } else {
        h.seq_force_screen_content_tools = b.u(1);
      }
      if (h.seq_force_screen_content_tools > 0) {
        h.seq_choose_integer_mv = b.u(1); // temp
        if (h.seq_choose_integer_mv) {
          h.seq_force_integer_mv = SELECT_INTEGER_MV;
        } else {
          h.seq_force_integer_mv = b.u(1);
        }
      } else {
        h.seq_force_integer_mv = SELECT_INTEGER_MV;
      }
      if (h.enable_order_hint) {
        h.order_hint_bits_minus_1 = b.u(3);
        h['OrderHintBits'] = h.order_hint_bits_minus_1 + 1; // 指定用于order_hint语法元素的位数。seq_params->order_hint_info.order_hint_bits_minus_1
      } else {
        h['OrderHintBits'] = 0;
      }
    }
    h.enable_superres = b.u(1);     // =1指定use_superres语法元素将出现在未压缩的头文件中。seq_params->enable_superres
    h.enable_cdef = b.u(1);         // =1指定可以启用cdef过滤。seq_params->enable_cdef
    h.enable_restoration = b.u(1);  // =1表示可以启用环路恢复过滤。seq_params->enable_restoration

    this.color_config({ b, h });
    h.film_grain_params_present = b.u(1); // 指定胶片颗粒参数是否出现在编码视频序列中。seq_params->film_grain_params_present
    return h;
  };

  // 5.5.2. Color config syntax
  color_config({ b, h }: { b: BitReader, h: any }) {
    h.high_bitdepth = b.u(1); // high_bitdepth和twelve_bit是语法元素，它们与seq_profile一起决定位深度。
    if (h.seq_profile == 2 && h.high_bitdepth) {
      h.twelve_bit = b.u(1);
      h['BitDepth'] = h.twelve_bit ? 12 : 10; // seq_params->bit_depth
    } else if (h.seq_profile <= 2) {
      h['BitDepth'] = h.high_bitdepth ? 10 : 8;
    } else {
      console.error("Unsupported profile/bit-depth combination");
    }
    if (h.seq_profile == 1) {
      h.mono_chrome = 0;  // =1表示视频不包含U和V色平面。seq_params->monochrome
    } else {
      h.mono_chrome = b.u(1);
    }
    h['NumPlanes'] = h.mono_chrome ? 1 : 3;
    h.color_description_present_flag = b.u(1);  // temp
    if (h.color_description_present_flag) {
      h.color_primaries = b.u(8);           // 6.4.2. ISO/IEC 23091-4/ITU-T H.273。seq_params->color_primaries
      h.transfer_characteristics = b.u(8);  // 6.4.2. ISO/IEC 23091-4/ITU-T H.273。seq_params->transfer_characteristics
      h.matrix_coefficients = b.u(8);       // 6.4.2. ISO/IEC 23091-4/ITU-T H.273。seq_params->matrix_coefficients
    } else {
      h.color_primaries = CP_UNSPECIFIED;
      h.transfer_characteristics = TC_UNSPECIFIED;
      h.matrix_coefficients = MC_UNSPECIFIED;
    }
    if (h.mono_chrome) {
      h.color_range = b.u(1); // 6.4.2. ISO/IEC 23091-4/ITU-T H.273。seq_params->color_range
      /** +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       *  | subsampling_x | subsampling_y | mono_chrome |   Description   |
       *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       *  |       0       |       0       |      0      |    YUV 4:4:4    |
       *  |       1       |       0       |      0      |    YUV 4:2:2    |
       *  |       1       |       1       |      0      |    YUV 4:2:0    |
       *  |       1       |       1       |      1      | Monochrome 4:0:0|
       *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       */
      h.subsampling_x = 1;  // seq_params->subsampling_x
      h.subsampling_y = 1;  // seq_params->subsampling_y
      h.chroma_sample_position = CSP_UNKNOWN; // CSP_VERTICAL水平位置与(0,0)亮度样本同处，垂直位置在两个亮度样本中间；CSP_COLOCATED与(0,0)亮度样本共定位。seq_params->chroma_sample_position
      h.separate_uv_delta_q = 0;  // // =1表示U和V平面可以有单独的增量量化器值；=0表示U和V平面将共享相同的增量量化器值。seq_params->separate_uv_delta_q
      return;
    } else if (
      h.color_primaries == CP_BT_709 && h.transfer_characteristics == TC_SRGB &&
      h.matrix_coefficients == MC_IDENTITY) {
      h.color_range = 1;
      h.subsampling_x = 0;
      h.subsampling_y = 0;
      if (!(h.seq_profile == 1 ||
        (h.seq_profile == 2 && h['BitDepth'] == 12))) {
        console.error("sRGB colorspace not compatible with specified profile");
      }
    } else {
      h.color_range = b.u(1);
      if (h.seq_profile == 0) {
        h.subsampling_x = 1;
        h.subsampling_y = 1;
      } else if (h.seq_profile == 1) {
        h.subsampling_x = 0;
        h.subsampling_y = 0;
      } else {
        if (h['BitDepth'] == 12) {
          h.subsampling_x = b.u(1);
          if (h.subsampling_x)
            h.subsampling_y = b.u(1);
          else
            h.subsampling_y = 0;
        } else {
          h.subsampling_x = 1;
          h.subsampling_y = 0;
        }
      }
      if (h.matrix_coefficients == MC_IDENTITY &&
        (h.subsampling_x || h.subsampling_y)) {
        console.error("Identity CICP Matrix incompatible with non 4:4:4 color sampling");
      }
      if (h.subsampling_x && h.subsampling_y) {
        h.chroma_sample_position = b.u(2);
      }
    }
    h.separate_uv_delta_q = b.u(1);
  };

  // 5.5.3. Timing info syntax
  timing_info({ b, h }: { b: BitReader, h: any }) {
    h.num_units_in_display_tick = b.u(32);  // num_units_in_display_tic/time_scale以秒为单位。timing_info->num_units_in_display_tick
    h.time_scale = b.u(32);                 // 一秒钟的滴答数。timing_info->time_scale
    if (h.num_units_in_display_tick == 0 || h.time_scale == 0) {
      console.error("num_units_in_display_tick and time_scale must be greater than 0.");
    }
    h.equal_picture_interval = b.u(1);  // =1表示图片应该按照它们的输出顺序显示，两个连续图片之间的滴答数(不掉帧)由num_ticks_per_picture_minus_1指定。timing_info->equal_picture_interval
    if (h.equal_picture_interval) {
      h.num_ticks_per_picture_minus_1 = b.uvlc(); // 指定输出顺序中两个连续图片之间的输出时间对应的时钟滴答数。timing_info->num_ticks_per_picture
      if (h.num_ticks_per_picture_minus_1 == 4294967295) {
        console.error("num_ticks_per_picture_minus_1 cannot be (1 << 32) - 1.");
      }
    }
  }

  // 5.5.4. Decoder model info syntax
  decoder_model_info({ b, h }: { b: BitReader, h: any }) {
    h.buffer_delay_length_minus_1 = b.u(5); // 指定decoder_buffer_delay和encoder_buffer_delay语法元素的长度。decoder_model_info->encoder_decoder_buffer_delay_length
    h.num_units_in_decoding_tick = b.u(32); // 解码时间在频率，num_units_in_decoding_tick/time_scale以秒为单位。decoder_model_info->num_units_in_decoding_tick
    h.buffer_removal_time_length_minus_1 = b.u(5);  // 指定buffer_removal_time语法元素的长度。decoder_model_info->buffer_removal_time_length
    h.frame_presentation_time_length_minus_1 = b.u(5);  // 指定frame_presentation_time语法元素的长度。decoder_model_info->frame_presentation_time_length
  }

  // 5.5.5. Operating parameters info syntax
  operating_parameters_info(op: number, { b, h }: { b: BitReader, h: any }) {
    let n = h.buffer_delay_length_minus_1 + 1;
    h[`decoder_buffer_delay[${op}]`] = b.u(n);  // 指定平滑缓冲区中的第一个比特到达和随后属于第一个编码帧的数据的移除之间的时间间隔，用于操作点op，以1/90000秒为单位。op_params->decoder_buffer_delay
    h[`encoder_buffer_delay[${op}]`] = b.u(n);  // 指定要解码到平滑缓冲区的帧的第一个比特到达时间，以1/90000秒为单位。op_params->encoder_buffer_delay
    h[`low_delay_mode_flag[${op}]`] = b.u(1);   // =1表示平滑缓冲区对操作点op以低延迟模式运行，在低延迟模式下，允许延迟解码时间和缓冲区底流；=0表示平滑缓冲区在严格模式下运行，不允许缓冲区下溢。op_params->low_delay_mode_flag
  }

  // 5.6. Temporal delimiter obu syntax
  temporal_delimiter_obu({ b, h }: { b: BitReader, h: any }) {
    this.SeenFrameHeader = 0; // 用于标记当前帧的帧头是否已被接收。
  }

  // 5.7. Padding OBU syntax
  padding_obu({ b, h }: { b: BitReader, h: any }) {
    for (let i = 0; i < h.obu_padding_length; i++) {
      let obu_padding_byte = b.f(8);
    }
  }

  // 5.9.1. General frame header OBU syntax
  frame_header_obu({ b, h }: { b: BitReader, h: any }) {
    if (h.SeenFrameHeader == 1) {

    } else {
      h.SeenFrameHeader = 1;
      this.uncompressed_header({ b, h });
      if (h.show_existing_frame) {
        this.decode_frame_wrapup({ b, h });
        h.SeenFrameHeader = 0;
      } else {
        h['TileNum'] = 0;
        h.SeenFrameHeader = 1;
      }
    }
  };

  // 5.9.2. Uncompressed header syntax  
  uncompressed_header({ b, h }: { b: BitReader, h: any }) {
    let idLen;
    if (this.seq_header.frame_id_numbers_present_flag) {
      idLen =
        this.seq_header.additional_frame_id_length_minus_1 +
        this.seq_header.delta_frame_id_length_minus_2 + 3;
    }
    let allFrames = (1 << NUM_REF_FRAMES) - 1;
    if (this.seq_header.reduced_still_picture_header) {
      h.show_existing_frame = 0;  // =1，表示输出由frame_to_show_map_idx索引的帧；=0表示需要进一步处理。cm->show_existing_frame
      h.frame_type = KEY_FRAME;   // current_frame->frame_type
      h['FrameIsIntra'] = 1;
      h.show_frame = 1;           // =1指定解码后立即输出该帧。cm->show_frame
      h.showable_frame = 0;       // =1指定可以使用show_existing_frame机制输出帧。cm->showable_frame
    } else {
      h.show_existing_frame = b.u(1);
      if (h.show_existing_frame == 1) {
        h.frame_to_show_map_idx = b.u(3); // 指定要输出的帧。temp
        if (this.seq_header.decoder_model_info_present_flag &&
          !this.seq_header.equal_picture_interval) {
          this.temporal_point_info({ b, h });
        }
        h.refresh_frame_flags = 0;  // current_frame->refresh_frame_flags
        if (this.seq_header.frame_id_numbers_present_flag) {
          h.display_frame_id = b.u(idLen);  // 要输出的帧提供帧id号。temp
        }

        let ref_frame = this.RefFrameType[h.frame_to_show_map_idx];
        if (!ref_frame) {
          throw Error("Buffer does not contain a decoded frame");
        }
        h.frame_type = ref_frame.frame_type;  // frame_to_show->frame_type

        if (h.frame_type == KEY_FRAME) {
          h.refresh_frame_flags = allFrames;
        }
        if (this.seq_header.film_grain_params_present) {
          this.load_grain_params(h.frame_to_show_map_idx, { b, h });
        }
        return;
      }
      h.frame_type = b.u(2);
      h['FrameIsIntra'] =
        (h.frame_type == INTRA_ONLY_FRAME ||
          h.frame_type == KEY_FRAME)
      h.show_frame = b.u(1);
      if (this.seq_header.still_picture &&
        (h.frame_type != KEY_FRAME || !h.show_frame)) {
        console.error("Still pictures must be coded as shown keyframes");
      }
      if (h.show_frame && this.seq_header.decoder_model_info_present_flag &&
        !this.seq_header.equal_picture_interval) {
        this.temporal_point_info({ b, h });
      }
      if (h.show_frame) {
        h.showable_frame = Number(h.frame_type != KEY_FRAME);
      } else {
        h.showable_frame = b.u(1);
      }
      this.cur_frame.showable_frame = h.showable_frame;
      if (h.frame_type == SWITCH_FRAME ||
        (h.frame_type == KEY_FRAME && h.show_frame))
        h.error_resilient_mode = 1;     // =1表示启用错误弹性模式。features->error_resilient_mode
      else
        h.error_resilient_mode = b.u(1);
    }
    if (h.frame_type == KEY_FRAME && h.show_frame) {
      for (let i = 0; i < NUM_REF_FRAMES; i++) {
        h[`RefValid[${i}]`] = 0;
        h[`RefOrderHint[${i}]`] = 0;
      }
      for (let i = 0; i < REFS_PER_FRAME; i++) {
        h[`OrderHints[${LAST_FRAME + i}]`] = 0;
      }
    }

    h.disable_cdf_update = b.u(1);  // 指定是否禁用符号解码过程中的CDF更新。features->disable_cdf_update
    if (this.seq_header.seq_force_screen_content_tools == SELECT_SCREEN_CONTENT_TOOLS) {
      h.allow_screen_content_tools = b.u(1);  // =1表示内部块可以使用调色板编码。features->allow_screen_content_tools
    } else {
      h.allow_screen_content_tools = this.seq_header.seq_force_screen_content_tools;
    }
    if (h.allow_screen_content_tools) {
      if (this.seq_header.seq_force_integer_mv == SELECT_INTEGER_MV) {
        h.force_integer_mv = b.u(1);  // = 1指定运动向量将始终是整数；=0指定运动向量可以包含小数位。features->cur_frame_force_integer_mv
      } else {
        h.force_integer_mv = this.seq_header.seq_force_integer_mv;
      }
    } else {
      h.force_integer_mv = 0;
    }
    if (h['FrameIsIntra']) {
      h.force_integer_mv = 1;
    }
    if (this.seq_header.frame_id_numbers_present_flag) {
      h['PrevFrameID'] = h.current_frame_id;
      h.current_frame_id = b.u(idLen);  // 指定当前帧的帧id号。cm->current_frame_id
      this.mark_ref_frames(idLen, { b, h });
    } else {
      h.current_frame_id = 0;
    }
    if (h.frame_type == SWITCH_FRAME)
      h.frame_size_override_flag = 1; // =0指定帧大小等于序列报头中的大小；=1指定帧大小将指定为其中一个参考帧的大小，或者从frame_width_minus_1和frame_height_minus_1语法元素计算。frame_size_override_flag
    else if (this.seq_header.reduced_still_picture_header)
      h.frame_size_override_flag = 0;
    else
      h.frame_size_override_flag = b.u(1);
    h.order_hint = b.u(this.seq_header['OrderHintBits']);
    h['OrderHint'] = h.order_hint;  // 此帧预期输出顺序的最低有效位。current_frame->order_hint
    if (h['FrameIsIntra'] || h.error_resilient_mode) {
      h.primary_ref_frame = PRIMARY_REF_NONE; // 指定哪个参考帧包含CDF值和其他应该在帧开始时加载的状态。features->primary_ref_frame
    } else {
      h.primary_ref_frame = b.u(3);
    }
    if (this.seq_header.decoder_model_info_present_flag) {
      h.buffer_removal_time_present_flag = b.u(1);  // =1表示存在buffer_removal_time。pbi->buffer_removal_time_present
      if (h.buffer_removal_time_present_flag) {
        for (let opNum = 0; opNum <= this.seq_header.operating_points_cnt_minus_1; opNum++) {
          if (this.seq_header[`decoder_model_present_for_this_op[${opNum}]`]) {
            let opPtIdc = this.seq_header[`operating_point_idc[${opNum} ]`];
            let inTemporalLayer = (opPtIdc >> h.temporal_id) & 1;
            let inSpatialLayer = (opPtIdc >> (h.spatial_id + 8)) & 1;
            if (opPtIdc == 0 || (inTemporalLayer && inSpatialLayer)) {
              let n = this.seq_header.buffer_removal_time_length_minus_1 + 1;
              h[`buffer_removal_time[${opNum}]`] = b.u(n);  // 指定帧移除时间，单位为从操作点opNum的最后一个随机接入点移除时间开始计算的DecCT时钟节拍。cm->buffer_removal_times
            }
          }
        }
      }
    }
    h.allow_high_precision_mv = 0;  // =0指定运动矢量指定为四分之一精度；=1指定运动向量被指定为8像素精度。features->allow_high_precision_mv
    h.use_ref_frame_mvs = 0;
    h.allow_intrabc = 0;  // =1表示可以在该帧中使用intra块复制。features->allow_intrabc
    if (h.frame_type == SWITCH_FRAME ||
      (h.frame_type == KEY_FRAME && h.show_frame)) {
      h.refresh_frame_flags = allFrames;  // 包含一个位掩码，该位掩码指定在解码后哪些参考帧槽将使用当前帧更新。current_frame->refresh_frame_flags
    } else {
      h.refresh_frame_flags = b.u(8);
    }
    if (!h['FrameIsIntra'] || h.refresh_frame_flags != allFrames) {
      if (h.error_resilient_mode &&
        this.seq_header.enable_order_hint) {
        for (let i = 0; i < NUM_REF_FRAMES; i++) {
          h[`ref_order_hint[${i}]`] = b.u(this.seq_header['OrderHintBits']); // 指定每个参考帧的预期输出顺序提示。buf->order_hint
          if (h[`ref_order_hint[${i}]`])
            h[`RefValid[${i}]`] = 0;
        }
      }
    }

    if (h['FrameIsIntra']) {
      this.frame_size({ b, h });
      this.render_size({ b, h });
      if (this.seq_header.allow_screen_content_tools &&
        h['UpscaledWidth'] == h['FrameWidth']) {
        h.allow_intrabc = b.u(1);
      }
    } else {
      if (!this.seq_header.enable_order_hint) {
        h.frame_refs_short_signaling = 0; // =1表示只有两个参考帧显式地发出信号；=0表示所有参考帧都显式地发出信号。frame_refs_short_signaling
      } else {
        h.frame_refs_short_signaling = b.u(1);
        if (h.frame_refs_short_signaling) {
          h.last_frame_idx = b.u(3);  // 指定要用于LAST_FRAME的参考帧。lst_ref
          h.gold_frame_idx = b.u(3);  // 指定GOLDEN_FRAME使用的参考帧。gld_ref
          this.set_frame_refs({ b, h });
        }
      }
      for (let i = 0; i < REFS_PER_FRAME; i++) {
        if (!h.frame_refs_short_signaling)
          h[`ref_frame_idx[${i}]`] = b.u(3);  // 指定帧间使用哪些参考帧。
        if (this.seq_header.frame_id_numbers_present_flag) {
          let n = this.seq_header.delta_frame_id_length_minus_2 + 2;
          h.delta_frame_id_minus_1 = b.u(n);
          h['DeltaFrameId'] = h.delta_frame_id_minus_1 + 1; // 指定参考帧到帧id的距离。
        }
      }

      if (this.seq_header.frame_size_override_flag &&
        !this.seq_header.error_resilient_mode) {
        this.frame_size_with_refs({ b, h });
      } else {
        this.frame_size({ b, h });
        this.render_size({ b, h });
      }

      if (h.force_integer_mv) {
        h.allow_high_precision_mv = 0;
      } else {
        h.allow_high_precision_mv = b.u(1);
      }
      this.read_interpolation_filter({ b, h });
      h.is_motion_mode_switchable = b.u(1); // =0指定只使用SIMPLE运动模式。features->switchable_motion_mode
      if (this.seq_header.error_resilient_mode ||
        !this.seq_header.enable_ref_frame_mvs) {
        h.use_ref_frame_mvs = 0;  // = 1指定在解码当前帧时可以使用前一帧的运动矢量信息。features->allow_ref_frame_mvs
      } else {
        h.use_ref_frame_mvs = b.u(1);
      }
      for (let i = 0; i < REFS_PER_FRAME; i++) {
        let refFrame = LAST_FRAME + i;
        let refFrameIdx = h[`ref_frame_idx[${i}]`];
        let hint = h[`RefOrderHint[${refFrameIdx}]`];
        h[`OrderHints[${refFrame}]`] = hint;  // 指定每个参考帧的预期输出顺序。
        if (!this.seq_header.enable_order_hint) {
          h[`RefFrameSignBias[${refFrame}]`] = 0; // 指定每个参考帧的运动矢量在时间上的预期方向。符号偏差等于0表示参考帧是向前参考(即参考帧预计在当前帧之前输出)；符号偏差等于1表示参考系是向后参考系。
        } else {
          h[`RefFrameSignBias[${refFrame}]`] = this.get_relative_dist(hint, h['OrderHint']) > 0;
        }
      }
    }

    if (this.seq_header.reduced_still_picture_header ||
      h.disable_cdf_update)
      h.disable_frame_end_update_cdf = 1; // =0表示启用帧结束CDF更新。features->refresh_frame_context
    else
      h.disable_frame_end_update_cdf = b.u(1);

    if (h.primary_ref_frame == PRIMARY_REF_NONE) {
      this.init_non_coeff_cdfs({ b, h });
      this.setup_past_independence({ b, h });
    } else {
      this.load_cdfs(h[`ref_frame_idx[${h.primary_ref_frame}]`], { b, h });
      this.load_previous();
    }
    if (h.use_ref_frame_mvs == 1)
      this.motion_field_estimation({ b, h });
    this.tile_info({ b, h });

    ////????????????
    this.quantization_params({ b, h });
    this.segmentation_params({ b, h });
    this.delta_q_params({ b, h });
    this.delta_lf_params({ b, h });
    if (h.primary_ref_frame == PRIMARY_REF_NONE) {
      this.init_coeff_cdfs({ b, h });
    } else {
      this.load_previous_segment_ids({ b, h });
    }
    h['CodedLossless'] = 1; // 是一个变量，当所有片段都使用无损编码时，该变量等于1；在这种情况下，循环过滤器和CDEF过滤器被禁用。
    for (let segmentId = 0; segmentId < MAX_SEGMENTS; segmentId++) {
      let qindex = this.get_qindex({ h }, 1, segmentId);
      h[`LosslessArray[${segmentId}]`] = qindex == 0 && h['DeltaQYDc'] == 0 &&
        h['DeltaQUAc'] == 0 && h['DeltaQUDc'] == 0 &&
        h['DeltaQVAc'] == 0 && h['DeltaQVDc'] == 0;
      if (!h[`LosslessArray[${segmentId}]`]) {
        h['CodedLossless'] = 0;
      }
      if (h.using_qmatrix) {
        if (h[`LosslessArray[${segmentId}]`]) {
          h[`SegQMLevel[0][${segmentId}]`] = 15;
          h[`SegQMLevel[1][${segmentId}]`] = 15;
          h[`SegQMLevel[2][${segmentId}]`] = 15;
        } else {
          h[`SegQMLevel[0][${segmentId}]`] = h.qm_y;
          h[`SegQMLevel[1][${segmentId}]`] = h.qm_u;
          h[`SegQMLevel[2][${segmentId}]`] = h.qm_v;
        }
      }
      h[`qindex[${segmentId}]`] = qindex; // xd->qindex
    }
    h['AllLossless'] = h['CodedLossless'] && (h['FrameWidth'] == h['UpscaledWidth']);
    this.loop_filter_params({ b, h });
    this.cdef_params({ b, h });
    this.lr_params({ b, h });
    this.read_tx_mode({ b, h });
    this.frame_reference_mode({ b, h });
    this.skip_mode_params({ b, h });
    if (h['FrameIsIntra'] || h.error_resilient_mode ||
      !this.seq_header.enable_warped_motion)
      h.allow_warped_motion = 0;  // =1表示可能存在语法元素motion_mode。features->allow_warped_motion
    else
      h.allow_warped_motion = b.u(1);
    h.reduced_tx_set = b.u(1);  //  =1指定帧被限制为转换类型的完整集合的简化子集。features->reduced_tx_set_used
    if (h.use_ref_frame_mvs &&
      !(!h.error_resilient_mode &&
        this.seq_header.enable_ref_frame_mvs &&
        this.seq_header.enable_order_hint &&
        !(h.frame_type == KEY_FRAME || h.frame_type == INTRA_ONLY_FRAME))) {
      console.error("Frame wrongly requests reference frame MVs");
    }
    this.global_motion_params({ b, h });
    this.film_grain_params({ b, h });
  };

  // 5.9.3. Get relative distance function
  get_relative_dist(a: number, b: number) {
    if (!this.seq_header.enable_order_hint)
      return 0;
    let diff = a - b;
    let m = 1 << (this.seq_header['OrderHintBits'] - 1);
    diff = (diff & (m - 1)) - (diff & m);
    return diff;
  };

  // 5.9.4. Reference frame marking function
  mark_ref_frames(idLen: number, { b, h }: { b: BitReader, h: any }) {
    let diffLen = h.delta_frame_id_length_minus_2 + 2;
    for (let i = 0; i < NUM_REF_FRAMES; i++) {
      if (h.current_frame_id > (1 << diffLen)) {
        if (h[`RefFrameId[${i}]`] > h.current_frame_id ||
          h[`RefFrameId[${i}]`] < (h.current_frame_id - (1 << diffLen)))
          h[`RefValid[${i}]`] = 0;  // 数组中的值为1表示对应的参考图片槽可以作为参考图片使用。pbi->valid_for_referencing
      } else {
        if (h[`RefFrameId[${i}]`] > h.current_frame_id &&
          h[`RefFrameId[${i}]`] < ((1 << idLen) +
            h.current_frame_id -
            (1 << diffLen)))
          h[`RefValid[${i}]`] = 0;
      }
    }
  }

  // 5.9.5. Frame size syntax
  frame_size({ b, h }: { b: BitReader, h: any }) {
    if (h.frame_size_override_flag) {
      let n = this.seq_header.frame_width_bits_minus_1 + 1;
      h.frame_width_minus_1 = b.u(n);
      n = this.seq_header.frame_height_bits_minus_1 + 1;
      h.frame_height_minus_1 = b.u(n);
      h['FrameWidth'] = h.frame_width_minus_1 + 1;    // 亮度样本中帧的宽。cm->superres_upscaled_width
      h['FrameHeight'] = h.frame_height_minus_1 + 1;  // 亮度样本中帧的高。cm->superres_upscaled_height
      if (h.frame_width_minus_1 > this.seq_header.max_frame_width_minus_1 ||
        h.frame_height_minus_1 > this.seq_header.max_frame_height_minus_1) {
        console.error("Frame dimensions are larger than the maximum values");
      }
    } else {
      h['FrameWidth'] = this.seq_header.max_frame_width_minus_1 + 1;
      h['FrameHeight'] = this.seq_header.max_frame_height_minus_1 + 1;
    }

    this.superres_params({ b, h });
    this.compute_image_size({ b, h });
  };

  // 5.9.6. Render size syntax
  // 呈现大小作为提示提供给应用程序关于所需的显示大小。它对解码过程没有影响。
  render_size({ b, h }: { b: BitReader, h: any }) {
    h.render_and_frame_size_different = b.u(1);         //  =0意味着渲染宽度和高度是从帧宽度和高度推断出来的。temp
    if (h.render_and_frame_size_different == 1) {
      h.render_width_minus_1 = b.u(16);
      h.render_height_minus_1 = b.u(16);
      h['RenderWidth'] = h.render_width_minus_1 + 1;    // 亮度样本中帧的渲染宽度。cm->render_width
      h['RenderHeight'] = h.render_height_minus_1 + 1;  // 亮度样本中帧的渲染高度。cm->render_height
    } else {
      h['RenderWidth'] = h['UpscaledWidth'];
      h['RenderHeight'] = h['FrameHeight'];
    }
  };

  // 5.9.7. Frame size with refs syntax
  // 对于帧间，帧大小要么被设置为等于参考帧的大小，要么可以显式发送。
  frame_size_with_refs({ b, h }: { b: BitReader, h: any }) {
    for (let i = 0; i < REFS_PER_FRAME; i++) {
      h.found_ref = b.u(1); // = 1表示可以从参考帧I推断出帧的尺寸。temp
      if (h.found_ref == 1) {
        let ref_frame_idx = h[`ref_frame_idx[${i}]`];
        h['UpscaledWidth'] = h[`RefUpscaledWidth[${ref_frame_idx}]`];
        h['FrameWidth'] = h['UpscaledWidth'];
        h['FrameHeight'] = h[`RefFrameHeight[${ref_frame_idx}]`];
        h['RenderWidth'] = h[`RefRenderWidth[${ref_frame_idx}]`];
        h['RenderHeight'] = h[`RefRenderHeight[${ref_frame_idx}]`];
        break;
      }
    }
    if (h.found_ref == 0) {
      this.frame_size({ b, h });
      this.render_size({ b, h });
    } else {
      this.superres_params({ b, h });
      this.compute_image_size({ b, h });
    }
  }

  // 5.9.8. Superres params syntax
  superres_params({ b, h }: { b: BitReader, h: any }) {
    if (this.seq_header.enable_superres)
      h.use_superres = b.u(1);  // =0表示不需要升级。temp
    else
      h.use_superres = 0;
    if (h.use_superres) {
      h.coded_denom = b.u(SUPERRES_DENOM_BITS); // 用于计算升级的数量。
      h['SuperresDenom'] = h.coded_denom + SUPERRES_DENOM_MIN;
    } else {
      h['SuperresDenom'] = SUPERRES_NUM;  // 是一个分数的分母，它指定了升级前后超级块宽度之间的比率。这个分数的分子等于常量SUPERRES_NUM。cm->superres_scale_denominator
    }
    h['UpscaledWidth'] = h['FrameWidth'];
    h['FrameWidth'] = ((h['UpscaledWidth'] * SUPERRES_NUM +
      (h['SuperresDenom'] / 2)) / h['SuperresDenom']);
  };

  // 5.9.9. Compute image size function
  compute_image_size({ b, h }: { b: BitReader, h: any }) {
    h['MiCols'] = 2 * ((h['FrameWidth'] + 7) >> 3);   // 是框架中4x4块列的数量。
    h['MiRows'] = 2 * ((h['FrameHeight'] + 7) >> 3);  // 是框架中4x4块行的数量

    function ALIGN_POWER_OF_TWO(value: number, n: number) {
      return ((value + ((1 << n) - 1)) & ~((1 << n) - 1));
    }
    function ROUND_POWER_OF_TWO(value: number, n: number) {
      return ((value + (((1 << n) >> 1))) >> n);
    }
    function calc_mi_size(len: number) {
      return ALIGN_POWER_OF_TWO(len, 7 - MI_SIZE_LOG2);
    }
    function aom_calc_y_stride(aligned_width: number, border: number) {
      return ((aligned_width + 2 * border) + 31) & ~31;
    }

    const aligned_width = (h['FrameWidth'] + 7) & ~7;
    const aligned_height = (h['FrameHeight'] + 7) & ~7;
    let mi_params: any = {};
    mi_params.mi_cols = aligned_width >> MI_SIZE_LOG2;
    mi_params.mi_rows = aligned_height >> MI_SIZE_LOG2;
    mi_params.mi_stride = calc_mi_size(mi_params.mi_cols);

    mi_params.mb_cols = ROUND_POWER_OF_TWO(mi_params.mi_cols, 2);
    mi_params.mb_rows = ROUND_POWER_OF_TWO(mi_params.mi_rows, 2);
    mi_params.MBs = mi_params.mb_rows * mi_params.mb_cols;

    mi_params.mi_alloc_bsize = BLOCK_4X4;
    mi_params.mi_alloc_stride = mi_params.mi_stride;

    let uv_width = aligned_width >> this.seq_header.subsampling_x;
    let uv_height = aligned_height >> this.seq_header.subsampling_y;
    let border = 64;
    let uv_border_w = border >> this.seq_header.subsampling_x;
    let uv_border_h = border >> this.seq_header.subsampling_y;
    let y_stride = aom_calc_y_stride(aligned_width, border);
    let uv_stride = y_stride >> this.seq_header.subsampling_x;
    let yplane_size = (aligned_height + 2 * border) * y_stride + h.byte_alignment;
    let uvplane_size = (uv_height + 2 * (border >> this.seq_header.subsampling_y)) * uv_stride + h.byte_alignment;
    this.cur_frame.buf = {
      buffer_alloc: new ArrayBuffer(32),
      y_crop_width: h['FrameWidth'],
      y_crop_height: h['FrameHeight'],
      y_width: aligned_width,
      y_height: aligned_height,
      y_stride,
      uv_crop_width: (h['FrameWidth'] + this.seq_header.subsampling_x) >> this.seq_header.subsampling_x,
      uv_crop_height: (h['FrameHeight'] + this.seq_header.subsampling_y) >> this.seq_header.subsampling_y,
      uv_width: aligned_width >> this.seq_header.subsampling_x,
      uv_height: aligned_height >> this.seq_header.subsampling_y,
      uv_stride: y_stride >> this.seq_header.subsampling_x,
      border,
      frame_size: (1 + h.use_highbitdepth) * (yplane_size + 2 * uvplane_size),
      subsampling_x: this.seq_header.subsampling_x,
      subsampling_y: this.seq_header.subsampling_y,
      flags: (h.use_highbitdepth ? 8 : 0),
      y_buffer: border * y_stride + border,
      u_buffer: yplane_size + (uv_border_h * uv_stride) + uv_border_w,
      v_buffer: yplane_size + uvplane_size + (uv_border_h * uv_stride) + uv_border_w,
      use_external_reference_buffers: 0,
      y_pyramid: undefined,
      corners: undefined,
      corrupted: 0,
    };
    this.cur_frame.mi_rows = mi_params.mi_rows;
    this.cur_frame.mi_cols = mi_params.mi_cols;
    this.cur_frame.mvs = undefined;
    this.cur_frame.seg_map = undefined;
    this.cur_frame.width = h['FrameWidth'];
    this.cur_frame.height = h['FrameHeight'];
    this.cur_frame.buf.bit_depth = this.seq_header.bit_depth;
    this.cur_frame.buf.color_primaries = this.seq_header.color_primaries;
    this.cur_frame.buf.transfer_characteristics = this.seq_header.transfer_characteristics;
    this.cur_frame.buf.matrix_coefficients = this.seq_header.matrix_coefficients;
    this.cur_frame.buf.monochrome = this.seq_header.monochrome;
    this.cur_frame.buf.chroma_sample_position = this.seq_header.chroma_sample_position;
    this.cur_frame.buf.color_range = this.seq_header.color_range;
    this.cur_frame.buf.render_width = this.seq_header.render_width;
    this.cur_frame.buf.render_height = this.seq_header.render_height;

    let av1_setup_block_planes = function (xd: any, ss_x: number, ss_y: number, num_planes: number) {
      let get_plane_type = function (plane: number) {
        const PLANE_TYPE_Y = 0;
        const PLANE_TYPE_UV = 1;
        return (plane == 0) ? PLANE_TYPE_Y : PLANE_TYPE_UV;
      }
      for (let i = 0; i < num_planes; i++) {
        xd.plane[i].plane_type = get_plane_type(i);
        xd.plane[i].subsampling_x = i ? ss_x : 0;
        xd.plane[i].subsampling_y = i ? ss_y : 0;
      }
      const MAX_MB_PLANE = 3;
      for (let i = num_planes; i < MAX_MB_PLANE; i++) {
        xd.plane[i].subsampling_x = 1;
        xd.plane[i].subsampling_y = 1;
      }
    }
  }

  // 5.9.10. Interpolation filter syntax
  read_interpolation_filter({ b, h }: { b: BitReader, h: any }) {
    h.is_filter_switchable = b.u(1);  // =1表示过滤器选择在块级发出信号；=0表示在帧级发出过滤器选择的信号。temp
    if (h.is_filter_switchable == 1) {
      h.interpolation_filter = SWITCHABLE;  // features->interp_filter
    } else {
      h.interpolation_filter = b.u(2);
    }
  }

  // 5.9.11. Loop filter params syntax
  loop_filter_params({ b, h }: { b: BitReader, h: any }) {
    if (h['CodedLossless'] || h.allow_intrabc) {
      h['loop_filter_level[0]'] = 0;                    // 包含循环过滤器强度值的数组；根据要过滤的图像平面和要过滤的边缘方向(垂直或水平)，使用来自阵列的不同环路滤波器强度值。lf->filter_level[0]
      h['loop_filter_level[1]'] = 0;                    // lf->filter_level[1]
      h[`loop_filter_ref_deltas[${INTRA_FRAME}]`] = 1;
      h[`loop_filter_ref_deltas[${LAST_FRAME}]`] = 0;
      h[`loop_filter_ref_deltas[${LAST2_FRAME}]`] = 0;
      h[`loop_filter_ref_deltas[${LAST3_FRAME}]`] = 0;
      h[`loop_filter_ref_deltas[${BWDREF_FRAME}]`] = 0;
      h[`loop_filter_ref_deltas[${GOLDEN_FRAME}]`] = -1;
      h[`loop_filter_ref_deltas[${ALTREF_FRAME}]`] = -1;
      h[`loop_filter_ref_deltas[${ALTREF2_FRAME}]`] = -1;
      for (let i = 0; i < 2; i++) {
        h[`loop_filter_mode_deltas[${i}]`] = 0;
      }
      return;
    }
    h['loop_filter_level[0]'] = b.u(6);
    h['loop_filter_level[1]'] = b.u(6);
    if (this.seq_header['NumPlanes'] > 1) {
      if (h['loop_filter_level[0]'] || h['loop_filter_level[1]']) {
        h['loop_filter_level[2]'] = b.u(6); // lf->filter_level_u
        h['loop_filter_level[3]'] = b.u(6); // lf->filter_level_v
      }
    }
    h.loop_filter_sharpness = b.u(3);       // 表示锐度级别。loop_filter_level和loop_filter_sharpness一起决定何时对块边缘进行过滤，以及过滤可以改变采样值的程度。lf->sharpness_level
    h.loop_filter_delta_enabled = b.u(1);   // =1意味着过滤器级别取决于用于预测块的模式和参考帧。lf->mode_ref_delta_enabled
    if (h.loop_filter_delta_enabled) {
      h.loop_filter_delta_update = b.u(1);  // =1意味着存在额外的语法元素，指定要更新哪个模式和参考框架增量。lf->mode_ref_delta_update
      if (h.loop_filter_delta_update) {
        for (let i = 0; i < TOTAL_REFS_PER_FRAME; i++) {
          let update_ref_delta = b.u(1);  // temp
          if (update_ref_delta) {
            h[`loop_filter_ref_deltas[${i}]`] = b.su(1 + 6);  // 包含基于所选参考框架的过滤器级别所需的调整；如果此语法元素不存在，则保持其先前的值。lf->ref_deltas
          }
          h[`update_ref_delta[${i}]`] = update_ref_delta;
        }
        for (let i = 0; i < 2; i++) {
          let update_mode_delta = b.u(1); // temp
          if (update_mode_delta) {
            h[`loop_filter_mode_deltas[${i}]`] = b.su(1 + 6); // 包含基于所选模式的过滤器级别所需的调整；如果此语法元素不存在，则保持其先前的值。lf->mode_deltas
          }
          h[`update_mode_delta[${i}]`] = update_mode_delta;
        }
      }
    }
  };

  // 5.9.12. Quantization params syntax
  // 残差是通过解码系数来确定的，这些解码系数在应用逆变换之前由四个量化参数之一进行调整。选择取决于平面(Y或UV)和系数位置(DC/AC系数)。第7.12节规定了去量化过程。
  quantization_params({ b, h }: { b: BitReader, h: any }) {
    h.base_q_idx = b.u(8);                        // 表示基帧qindex；这用于Y AC系数，并作为其他量化器的基值。quant_params->base_qindex
    h['DeltaQYDc'] = this.read_delta_q({ b, h }); // 表示相对于base_q_idx的Y DC量化器。quant_params->y_dc_delta_q
    if (this.seq_header['NumPlanes'] > 1) {
      if (this.seq_header.separate_uv_delta_q)
        h.diff_uv_delta = b.u(1); // =1表示U和V增量量化器值分别编码。=0表示U和V增量量化器值共享一个公共值。temp
      else
        h.diff_uv_delta = 0;
      h['DeltaQUDc'] = this.read_delta_q({ b, h }); // 表示相对于base_q_idx的U DC量化器。quant_params->u_dc_delta_q
      h['DeltaQUAc'] = this.read_delta_q({ b, h }); // 表示相对于base_q_idx的U AC量化器。quant_params->u_ac_delta_q
      if (h.diff_uv_delta) {
        h['DeltaQVDc'] = this.read_delta_q({ b, h }); // 表示相对于base_q_idx的V DC量化器。quant_params->v_dc_delta_q
        h['DeltaQVAc'] = this.read_delta_q({ b, h }); // 表示相对于base_q_idx的V AC量化器。quant_params->v_ac_delta_q
      } else {
        h['DeltaQVDc'] = h['DeltaQUDc'];
        h['DeltaQVAc'] = h['DeltaQUAc'];
      }
    } else {
      h['DeltaQUDc'] = 0;
      h['DeltaQUAc'] = 0;
      h['DeltaQVDc'] = 0;
      h['DeltaQVAc'] = 0;
    }
    h.using_qmatrix = b.u(1); // 指定量化器矩阵将用于计算量化器。quant_params->using_qmatrix
    if (h.using_qmatrix) {
      h.qm_y = b.u(4);    // 指定量化器矩阵中应该用于亮度平面解码的级别。quant_params->qmatrix_level_y
      h.qm_u = b.u(4);    // 指定量化器矩阵中应该用于色度U平面解码的级别。quant_params->qmatrix_level_u
      if (!this.seq_header.separate_uv_delta_q)
        h.qm_v = h.qm_u;  // 指定量化器矩阵中应该用于色度V平面解码的级别。quant_params->qmatrix_level_v
      else
        h.qm_v = b.u(4);
    }
  };

  // 5.9.13. Delta quantizer syntax
  read_delta_q({ b, h }: { b: BitReader, h: any }) {
    let delta_q = 0;
    let delta_coded = b.u(1);
    if (delta_coded) delta_q = b.su(1 + 6);
    return delta_q;
  };

  // 5.9.14. Segmentation params syntax
  /* AV1提供了一种分割图像的方法，然后在分割级别应用各种调整。
    对于任何给定的帧，最多可以指定8个片段。对于这些部分，可以指定:
      1.量化器(绝对值或增量)。
      2.环路滤波器强度(绝对值或增量)。
      3.预测参考系。
      4.一种块跳过模式，意味着使用(0,0)运动向量，并且没有残差将被编码。
    每个片段的这些数据值都可以在帧级单独更新。如果一个值在给定的帧中没有更新，那么前一帧的值将保持不变。例外情况是关键帧、内部帧或其他需要独立于过去帧值的帧(例如，启用错误恢复能力)。在这种情况下，所有值都按照setup_past_independence语义中的描述进行重置。
    段关联(分段映射)以4x4块的分辨率存储。如果没有为块的段关联编码显式更新，那么它将从一帧持续到另一帧(直到通过调用setup_past_independence重置)。
   */
  segmentation_params({ b, h }: { b: BitReader, h: any }) {
    const Segmentation_Feature_Bits = [8, 6, 6, 6, 6, 3, 0, 0];
    const Segmentation_Feature_Signed = [1, 1, 1, 1, 1, 0, 0, 0];
    const Segmentation_Feature_Max = [255, MAX_LOOP_FILTER, MAX_LOOP_FILTER, MAX_LOOP_FILTER, MAX_LOOP_FILTER, 7, 0, 0];

    h.segmentation_enabled = b.u(1);  // =1表示此帧使用分段。seg->enabled
    if (h.segmentation_enabled == 1) {
      if (h.primary_ref_frame == PRIMARY_REF_NONE) {
        h.segmentation_update_map = 1;      // =1表示在该帧的解码过程中更新了分段映射；=0表示使用前一帧的分段映射。seg->update_map
        h.segmentation_temporal_update = 0; // =1表示对分段映射的更新是相对于现有分段映射进行编码的；=0表示在不引用现有分段映射的情况下对新的分段映射进行编码。seg->temporal_update
        h.segmentation_update_data = 1;     // =1表示即将为每个段指定新参数；=0表示分割参数应保持其现有值。seg->update_data
      } else {
        h.segmentation_update_map = b.u(1);
        if (h.segmentation_update_map == 1)
          h.segmentation_temporal_update = b.u(1);
        h.segmentation_update_data = b.u(1);
      }
      if (h.segmentation_update_data == 1) {
        for (let i = 0; i < MAX_SEGMENTS; i++) {
          for (let j = 0; j < SEG_LVL_MAX; j++) {
            let feature_value = 0;  // 指定段特征的特征数据
            let feature_enabled = b.u(1); // temp
            h[`FeatureEnabled[${i}][${j}]`] = feature_enabled;
            let clippedValue = 0;
            if (feature_enabled) {
              let bitsToRead = Segmentation_Feature_Bits[j];
              let limit = Segmentation_Feature_Max[j];
              if (Segmentation_Feature_Signed[j] == 1) {
                feature_value = b.su(1 + bitsToRead);
                clippedValue = this.Clip3(-limit, limit, feature_value);
              } else {
                feature_value = b.u(bitsToRead);
                clippedValue = this.Clip3(0, limit, feature_value);
              }
            }
            h[`FeatureData[${i}][${j}]`] = clippedValue;  // seg->feature_data
            h[`feature_value[${i}][${j}]`] = feature_value;
            h[`feature_enabled[${i}][${j}]`] = feature_enabled;
          }
        }
      }
    } else {
      for (let i = 0; i < MAX_SEGMENTS; i++) {
        for (let j = 0; j < SEG_LVL_MAX; j++) {
          h[`FeatureEnabled[${i}][${j}]`] = 0;
          h[`FeatureData[${i}][${j}]`] = 0;
        }
      }
    }
    h['SegIdPreSkip'] = 0;    // =1表示将在跳过语法元素之前读取段id。=0表示将首先读取跳过语法元素。
    h['LastActiveSegId'] = 0; // 表示已启用某些特性的最高编号段id。这在解码段id时使用，只解码与使用的段对应的选择。
    for (let i = 0; i < MAX_SEGMENTS; i++) {
      for (let j = 0; j < SEG_LVL_MAX; j++) {
        if (h[`FeatureEnabled[${i}][${j}]`]) {
          h['LastActiveSegId'] = i;
          if (j >= SEG_LVL_REF_FRAME) {
            h['SegIdPreSkip'] = 1;
          }
        }
      }
    }
  };

  // 5.9.15. Tile info syntax
  tile_info({ b, h }: { b: BitReader, h: any }) {
    let this_ = this;
    let sbCols = this.seq_header.use_128x128_superblock ? ((h['MiCols'] + 31) >> 5) : ((h['MiCols'] + 15) >> 4);
    let sbRows = this.seq_header.use_128x128_superblock ? ((h['MiRows'] + 31) >> 5) : ((h['MiRows'] + 15) >> 4);
    let sbShift = this.seq_header.use_128x128_superblock ? 5 : 4
    let sbSize = sbShift + 2;
    let maxTileWidthSb = MAX_TILE_WIDTH >> sbSize;
    let maxTileAreaSb = MAX_TILE_AREA >> (2 * sbSize);
    let minLog2TileCols = this.tile_log2(maxTileWidthSb, sbCols);             // tiles->min_log2_cols
    let maxLog2TileCols = this.tile_log2(1, Math.min(sbCols, MAX_TILE_COLS)); // tiles->max_log2_cols
    let maxLog2TileRows = this.tile_log2(1, Math.min(sbRows, MAX_TILE_ROWS)); // tiles->max_log2_rows
    let minLog2Tiles =
      Math.max(minLog2TileCols, this.tile_log2(maxTileAreaSb, sbRows * sbCols))

    h.uniform_tile_spacing_flag = b.u(1); // =1表示贴图在整个框架中均匀间隔(换句话说，所有的贴图都是相同的大小，除了右边和底部边缘的那些可以更小)；=0意味着贴图的大小是编码的。tiles->uniform_spacing
    if (h.uniform_tile_spacing_flag) {
      h['TileColsLog2'] = minLog2TileCols;
      while (h['TileColsLog2'] < maxLog2TileCols) {
        let increment_tile_cols_log2 = b.u(1);  // temp
        if (increment_tile_cols_log2 == 1)
          h['TileColsLog2']++;  // 指定整个框架所需的贴图数的以2为底的对数。tiles->log2_cols
        else
          break;
      }
      let tileWidthSb = (sbCols + (1 << h['TileColsLog2']) - 1) >> h['TileColsLog2']; // 用于以超级块为单位指定每个块的宽度。小于maxTileWidthSb是位流一致性的要求。
      let i = 0;
      for (let startSb = 0; startSb < sbCols; startSb += tileWidthSb) {
        h[`MiColStarts[${i}]`] = startSb << sbShift;  // 指定图像上每个贴图的开始列(以4x4亮度样本为单位)。
        i += 1;
      }
      h[`MiColStarts[${i}]`] = h['MiCols'];
      h['TileCols'] = i;  // 指定整个框架的贴图数量；比特流一致性的要求是TileCols小于或等于MAX_TILE_COLS。

      let minLog2TileRows = Math.max(minLog2Tiles - h['TileColsLog2'], 0);  // tiles->min_log2_rows
      h['TileRowsLog2'] = minLog2TileRows;
      while (h['TileRowsLog2'] < maxLog2TileRows) {
        let increment_tile_rows_log2 = b.u(1);  // temp
        if (increment_tile_rows_log2 == 1)
          h['TileRowsLog2']++;  // 指定在框架中所需的贴图数的以2为底的对数。tiles->log2_rows
        else
          break;
      }
      let tileHeightSb = (sbRows + (1 << h['TileRowsLog2']) - 1) >> h['TileRowsLog2'];  // 用于以超级块为单位指定每个贴图的高度。tileWidthSb*tileHeightSb小于maxTileAreaSb是位流一致性的要求。
      i = 0;
      for (let startSb = 0; startSb < sbRows; startSb += tileHeightSb) {
        h[`MiRowStarts[${i}]`] = startSb << sbShift;  // 指定图像中每个贴图的起始行(以4x4亮度样本为单位)。
        i += 1;
      }
      h[`MiRowStarts[${i}]`] = h['MiRows'];
      h['TileRows'] = i;  // 指定了整个框架的瓷砖数量。bitstream一致性要求TileRows小于或等于MAX_TILE_ROWS。
    } else {
      let widestTileSb = 0;
      let startSb = 0;
      let sizeSb = 0;
      let i;
      for (i = 0; startSb < sbCols; i++) {
        h[`MiColStarts[${i}]`] = startSb << sbShift;
        let maxWidth = Math.min(sbCols - startSb, maxTileWidthSb);
        h.width_in_sbs_minus_1 = b.ns(maxWidth);  // 指定贴图的宽度，以超级块为单位。
        let sizeSb = h.width_in_sbs_minus_1 + 1;
        widestTileSb = Math.max(sizeSb, widestTileSb);
        startSb += sizeSb;
      }
      h[`MiColStarts[${i}]`] = h['MiCols'];
      h['TileCols'] = i;
      h['TileColsLog2'] = this.tile_log2(1, h['TileCols']);

      let maxTileAreaSb = 0;
      if (minLog2Tiles > 0)
        maxTileAreaSb = (sbRows * sbCols) >> (minLog2Tiles + 1);
      else
        maxTileAreaSb = sbRows * sbCols;
      let maxTileHeightSb = Math.max(maxTileAreaSb / widestTileSb, 1);  // 指定可用于瓷砖的最大高度(以超级块为单位)(以避免制作面积过大的瓷砖)。

      startSb = 0;
      for (i = 0; startSb < sbRows; i++) {
        h[`MiRowStarts[${i}]`] = startSb << sbShift;
        let maxHeight = Math.min(sbRows - startSb, maxTileHeightSb);
        h.height_in_sbs_minus_1 = b.ns(maxHeight);  // 指定贴图的高度，以超级块为单位。
        sizeSb = h.height_in_sbs_minus_1 + 1;
        startSb += sizeSb;
      }
      h[`MiRowStarts[${i}]`] = h['MiRows'];
      h['TileRows'] = i;
      h['TileRowsLog2'] = this.tile_log2(1, h['TileRows']);
    }
    if (h['TileColsLog2'] > 0 || h['TileRowsLog2'] > 0) {
      h.context_update_tile_id = b.u(h['TileRowsLog2'] + h['TileColsLog2']);  // 指定要为CDF更新使用哪个tile
      h.tile_size_bytes_minus_1 = b.u(2);
      h['TileSizeBytes'] = h.tile_size_bytes_minus_1 + 1; // 指定编码每个贴图大小所需的字节数。
    } else {
      h.context_update_tile_id = 0;
    }

    // libaom
    let ALIGN_POWER_OF_TWO = function (value: number, n: number) {
      return (((value) + ((1 << (n)) - 1)) & ~((1 << (n)) - 1));
    }
    let AOMMIN = function (x: number, y: number) {
      return (((x) < (y)) ? (x) : (y));
    }
    // let tile_log2 = function (blk_size: number, target: number) {
    //   let k;
    //   for (k = 0; (blk_size << k) < target; k++) {
    //   }
    //   return k;
    // }
    let av1_calculate_tile_rows = function (seq_params: any, cm_mi_rows: number, tiles: any) {
      let mi_rows = ALIGN_POWER_OF_TWO(cm_mi_rows, seq_params.aom_mib_size_log2);
      let sb_rows = mi_rows >> seq_params.aom_mib_size_log2;
      let start_sb, size_sb, i;
      if (h.uniform_tile_spacing_flag) {
        size_sb = ALIGN_POWER_OF_TWO(sb_rows, tiles.log2_rows);
        size_sb >>= tiles.log2_rows;
        for (i = 0, start_sb = 0; start_sb < sb_rows; i++) {
          tiles[`aom_row_start_sb[${i}]`] = start_sb;
          start_sb += size_sb;
        }
        tiles.aom_rows = i;
        tiles[`aom_row_start_sb[${i}]`] = sb_rows;

        tiles.height = size_sb << seq_params.aom_mib_size_log2;
        tiles.height = AOMMIN(tiles.height, cm_mi_rows);
      } else {
        tiles.log2_rows = this_.tile_log2(1, tiles.rows);
      }
    }
    // av1_calculate_tile_rows(this.seq_header, 72, h);
  };

  // 5.9.16. Tile size calculation function
  tile_log2(blkSize: number, target: number) {
    let k = 0;
    for (k = 0; (blkSize << k) < target; k++) {
    }
    return k;
  };

  // 5.9.17. Quantizer index delta parameters syntax
  delta_q_params({ b, h }: { b: BitReader, h: any }) {
    h.delta_q_res = 0;
    h.delta_q_present = 0;  // 指定量化器索引增量值是否存在。cm->delta_q_info.delta_q_present_flag
    if (h.base_q_idx > 0) {
      h.delta_q_present = b.u(1);
    }
    if (h.delta_q_present) {
      h.delta_q_res = b.u(2);     // 指定应应用于解码量化器索引增量值的左移。cm->delta_q_info.delta_q_res
    }
  };

  // 5.9.18. Loop filter delta parameters syntax
  delta_lf_params({ b, h }: { b: BitReader, h: any }) {
    h.delta_lf_present = 0; // 指定是否存在循环过滤器的增量值。
    h.delta_lf_res = 0;     // 指定应应用于解码循环滤波器增量值的左移。
    h.delta_lf_multi = 0;   // =1指定为水平亮度边缘、垂直亮度边缘、U边缘和V边缘发送单独的环路滤波器；=0指定对所有边使用相同的环路滤波器delta。
    if (h.delta_q_present) {
      if (!h.allow_intrabc) {
        h.delta_lf_present = b.u(1);  // cm->delta_q_info.delta_lf_present_flag
      }
      if (h.delta_lf_present) {
        h.delta_lf_res = b.u(2);    // cm->delta_q_info.delta_lf_res
        h.delta_lf_multi = b.u(1);  // cm->delta_q_info.delta_lf_multi
      }
    }
  };

  // 5.9.19. CDEF params syntax
  cdef_params({ b, h }: { b: BitReader, h: any }) {
    if (h['CodedLossless'] || h.allow_intrabc ||
      !this.seq_header.enable_cdef) {
      h.cdef_bits = 0;
      h['cdef_y_pri_strength[0]'] = 0;  // 指定主过滤器的强度。
      h['cdef_y_sec_strength[0]'] = 0;  // 指定二级过滤器的强度。
      h['cdef_uv_pri_strength[0]'] = 0; // 指定主过滤器的强度。
      h['cdef_uv_sec_strength[0]'] = 0; // 指定二级过滤器的强度。
      h['CdefDamping'] = 3;
      return;
    }
    h.cdef_damping_minus_3 = b.u(2);
    h['CdefDamping'] = h.cdef_damping_minus_3 + 3;  // 控制衰减滤波器中的阻尼量。cdef_info->cdef_damping
    h.cdef_bits = b.u(2); // 定指定应用哪个CDEF过滤器所需的位数。cdef_info->cdef_bits
    for (let i = 0; i < (1 << h.cdef_bits); i++) {
      h[`cdef_y_pri_strength[${i}]`] = b.u(4);  // cdef_info->cdef_strengths
      h[`cdef_y_sec_strength[${i}]`] = b.u(2);  // cdef_info->cdef_strengths
      if (h[`cdef_y_sec_strength[${i}]`] == 3) {
        h[`cdef_y_sec_strength[${i}]`] += 1;
      }
      if (this.seq_header['NumPlanes'] > 1) {
        h[`cdef_uv_pri_strength[${i}]`] = b.u(4); // cdef_info->cdef_uv_strengths
        h[`cdef_uv_sec_strength[${i}]`] = b.u(2); // cdef_info->cdef_uv_strengths
        if (h[`cdef_uv_sec_strength[${i}]`] == 3) {
          h[`cdef_uv_sec_strength[${i}]`] += 1;
        }
      }
    }
  };

  // 5.9.20. Loop restoration params syntax
  lr_params({ b, h }: { b: BitReader, h: any }) {
    if (h['AllLossless'] || h.allow_intrabc ||
      !this.seq_header.enable_restoration) {
      h['FrameRestorationType[0]'] = RESTORE_NONE;
      h['FrameRestorationType[1]'] = RESTORE_NONE;
      h['FrameRestorationType[2]'] = RESTORE_NONE;
      h['UsesLr'] = 0;
      return;
    }
    const Remap_Lr_Type = [RESTORE_NONE, RESTORE_SWITCHABLE, RESTORE_WIENER, RESTORE_SGRPROJ];
    h['UsesLr'] = 0;  // 表示是否有平面使用环路恢复。
    let usesChromaLr = 0;
    for (let i = 0; i < this.seq_header['NumPlanes']; i++) {
      /** +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       *  | lr_type | FrameRestorationType| Name of FrameRestorationType|
       *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       *  |    0    |          0          |      RESTORE_NONE           |
       *  |    1    |          3          |      RESTORE_SWITCHABLE     |
       *  |    2    |          1          |      RESTORE_WIENER         |
       *  |    3    |          2          |      RESTORE_SGRPROJ        |
       *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       */
      let lr_type = b.u(2);
      h[`FrameRestorationType[${i}]`] = Remap_Lr_Type[lr_type]; // rsi->frame_restoration_type
      if (h[`FrameRestorationType[${i}]`] != RESTORE_NONE) {
        h['UsesLr'] = 1;
        if (i > 0) {
          usesChromaLr = 1
        }
      }
      h[`lr_type[${i}]`] = lr_type;
    }
    if (h['UsesLr']) {
      if (this.seq_header.use_128x128_superblock) {
        h.lr_unit_shift = b.u(1); // rsi->restoration_unit_size
        h.lr_unit_shift++;
      } else {
        h.lr_unit_shift = b.u(1);
        if (h.lr_unit_shift) {
          h.lr_unit_extra_shift = b.u(1); // 指定亮度恢复大小是否应该再次减半。
          h.lr_unit_shift += h.lr_unit_extra_shift;
        }
      }
      h['LoopRestorationSize[0]'] = RESTORATION_TILESIZE_MAX >> (2 - h.lr_unit_shift);
      if (this.seq_header.subsampling_x && this.seq_header.subsampling_y && usesChromaLr) {
        h.lr_uv_shift = b.u(1); // 仅适用于4:2:0格式，并指定色度大小是否应该是亮度大小的一半。
      } else {
        h.lr_uv_shift = 0;
      }
      h['LoopRestorationSize[1]'] = h['LoopRestorationSize[0]'] >> h.lr_uv_shift; // 指定当前平面中以样本为单位的环路恢复单元的大小。
      h['LoopRestorationSize[2]'] = h['LoopRestorationSize[0]'] >> h.lr_uv_shift;
    }
  };

  // 5.9.21. TX mode syntax
  read_tx_mode({ b, h }: { b: BitReader, h: any }) {
    if (h['CodedLossless'] == 1) {
      h['TxMode'] = ONLY_4X4; // eatures->tx_mode
    } else {
      h.tx_mode_select = b.u(1);  // temp
      if (h.tx_mode_select) {
        h['TxMode'] = TX_MODE_SELECT;
      } else {
        h['TxMode'] = TX_MODE_LARGEST;
      }
    }
  }

  // 5.9.22. Skip mode params syntax
  skip_mode_params({ b, h }: { b: BitReader, h: any }) {
    let skipModeAllowed;
    if (h['FrameIsIntra'] || !h.reference_select || !this.seq_header.enable_order_hint) {
      skipModeAllowed = 0;
    } else {
      let forwardIdx = -1;
      let backwardIdx = -1;
      let forwardHint = -1;
      let backwardHint = 0;
      for (let i = 0; i < REFS_PER_FRAME; i++) {
        let refFrameIdx = h[`ref_frame_idx[${i}`];
        let refHint = h[`RefOrderHint[${refFrameIdx}]`];
        if (this.get_relative_dist(refHint, h['OrderHint']) < 0) {
          if (forwardIdx < 0 ||
            this.get_relative_dist(refHint, forwardHint) > 0) {
            forwardIdx = i;
            forwardHint = refHint;
          }
        } else if (this.get_relative_dist(refHint, h['OrderHint']) > 0) {
          if (backwardIdx < 0 ||
            this.get_relative_dist(refHint, backwardHint) < 0) {
            backwardIdx = i;
            backwardHint = refHint;
          }
        }
      }
      if (forwardIdx < 0) {
        skipModeAllowed = 0;
      } else if (backwardIdx >= 0) {
        skipModeAllowed = 1;
        h['SkipModeFrame[0]'] = LAST_FRAME + Math.min(forwardIdx, backwardIdx); // 指定了当skip_mode等于1时用于复合预测的帧。
        h['SkipModeFrame[1]'] = LAST_FRAME + Math.max(forwardIdx, backwardIdx)
      } else {
        let secondForwardIdx = -1;
        let secondForwardHint = -1;
        for (let i = 0; i < REFS_PER_FRAME; i++) {
          let refFrameIdx = h[`ref_frame_idx${i}`];
          let refHint = h[`RefOrderHint[${refFrameIdx}]`];
          if (this.get_relative_dist(refHint, forwardHint) < 0) {
            if (secondForwardIdx < 0 ||
              this.get_relative_dist(refHint, secondForwardHint) > 0) {
              secondForwardIdx = i;
              secondForwardHint = refHint;
            }
          }
        }
        if (secondForwardIdx < 0) {
          skipModeAllowed = 0;
        } else {
          skipModeAllowed = 1;
          h['SkipModeFrame[0]'] = LAST_FRAME + Math.min(forwardIdx, secondForwardIdx);
          h['SkipModeFrame[1]'] = LAST_FRAME + Math.max(forwardIdx, secondForwardIdx);
        }
      }
    }
    if (skipModeAllowed) {
      h.skip_mode_present = b.u(1); // =1指定语法元素skip_mode将出现；=0指定skip_mode不用于此帧。current_frame->skip_mode_info.skip_mode_flag
    } else {
      h.skip_mode_present = 0;
    }
  };

  // 5.9.23. Frame reference mode syntax
  frame_reference_mode({ b, h }: { b: BitReader, h: any }) {
    if (h['FrameIsIntra']) {
      h.reference_select = 0; // =1指定块间的模式信息包含语法元素comp_mode，该元素指示是使用单个引用预测还是复合引用预测。=0指定所有inter block将使用单个预测。
    } else {
      h.reference_select = b.u(1);  // current_frame->reference_mode
    }
  }

  // 5.9.24. Global motion params syntax
  global_motion_params({ b, h }: { b: BitReader, h: any }) {
    for (let ref = LAST_FRAME; ref <= ALTREF_FRAME; ref++) {
      h[`GmType[${ref}]`] = IDENTITY;
      for (let i = 0; i < 6; i++) {
        h[`gm_params[${ref}][${i}]`] = ((i % 3 == 2) ? 1 << WARPEDMODEL_PREC_BITS : 0);
      }
    }
    if (h['FrameIsIntra']) {
      return;
    }
    for (let ref = LAST_FRAME; ref <= ALTREF_FRAME; ref++) {
      h[`is_global[${ref}]`] = b.u(1);  // 指定是否存在特定参考帧的全局运动参数。
      let type; // params->wmtype
      if (h[`is_global[${ref}]`]) {
        h[`is_rot_zoom[${ref}]`] = b.u(1);  // 指定特定参考帧是否使用旋转和缩放全局运动。temp
        if (h[`is_rot_zoom[${ref}]`]) {
          type = ROTZOOM;
        } else {
          h[`is_translation[${ref}]`] = b.u(1); // 指定一个特定的参考系是否使用平移全局运动。temp
          type = h[`is_translation[${ref}]`] ? TRANSLATION : AFFINE;
        }
      } else {
        type = IDENTITY;
      }
      h[`GmType[${ref}]`] = type;
      if (type >= ROTZOOM) {
        this.read_global_param(type, ref, 2, { b, h });
        this.read_global_param(type, ref, 3, { b, h });
        if (type == AFFINE) {
          this.read_global_param(type, ref, 4, { b, h });
          this.read_global_param(type, ref, 5, { b, h });
        } else {
          h[`gm_params[${ref}][4]`] = -h[`gm_params[${ref}][3]`];
          h[`gm_params[${ref}][5]`] = h[`gm_params[${ref}][2]`];
        }
      }
      if (type >= TRANSLATION) {
        this.read_global_param(type, ref, 0, { b, h });
        this.read_global_param(type, ref, 1, { b, h });
      }
    }
  };

  // 5.9.25. Global param syntax
  read_global_param(type: number, ref: number, idx: number, { b, h }: { b: BitReader, h: any }) {
    let absBits = GM_ABS_ALPHA_BITS;    // 用来计算gm_params[ref][idx]的取值范围。
    let precBits = GM_ALPHA_PREC_BITS;  // 指定用于表示gm_params[ref][idx]的小数位数。所有全局运动参数都以WARPEDMODEL_PREC_BITS小数位数存储在模型中，但是参数的编码精度较低。
    if (idx < 2) {
      if (type == TRANSLATION) {
        absBits = GM_ABS_TRANS_ONLY_BITS - (1 - h.allow_high_precision_mv);
        precBits = GM_TRANS_ONLY_PREC_BITS - (1 - h.allow_high_precision_mv);
      } else {
        absBits = GM_ABS_TRANS_BITS;
        precBits = GM_TRANS_PREC_BITS;
      }
    }
    let precDiff = WARPEDMODEL_PREC_BITS - precBits;
    let round = (idx % 3) == 2 ? (1 << WARPEDMODEL_PREC_BITS) : 0;
    let sub = (idx % 3) == 2 ? (1 << precBits) : 0;
    let mx = (1 << absBits);
    let r = (h[`PrevGmParams[${ref}][${idx}]`] >> precDiff) - sub;
    h[`gm_params[${ref}][${idx}]`] =
      (this.decode_signed_subexp_with_ref(-mx, mx + 1, r, { b, h }) << precDiff) + round;
  };

  // 5.9.26. Decode signed subexp with ref syntax
  decode_signed_subexp_with_ref(low: number, high: number, r: number, { b, h }: { b: BitReader, h: any }) {
    let x = this.decode_unsigned_subexp_with_ref(high - low, r - low, { b, h });
    return x + low;
  };

  // 5.9.27. Decode unsigned subexp with ref syntax
  decode_unsigned_subexp_with_ref(mx: number, r: number, { b, h }: { b: BitReader, h: any }) {
    let v = this.decode_subexp(mx, { b, h });
    if ((r << 1) <= mx) {
      return this.inverse_recenter(r, v);
    } else {
      return mx - 1 - this.inverse_recenter(mx - 1 - r, v);
    }
  };

  // 5.9.28. Decode subexp syntax
  decode_subexp(numSyms: number, { b, h }: { b: BitReader, h: any }) {
    let i = 0;
    let mk = 0;
    let k = 3;
    let n = 0;
    while (1) {
      let b2 = i ? k + i - 1 : k;
      let a = 1 << b2;
      if (numSyms <= mk + 3 * a) {
        h[`subexp_final_bits[${n}]`] = b.ns(numSyms - mk);  // 提供一旦确定了适当的范围就读取的最终位。
        return h[`subexp_final_bits[${n}]`] + mk;
      } else {
        h[`subexp_more_bits[${n}]`] = b.u(1); // =0表示参数范围在mk到mk+a-1之间。=1表示该参数大于mk+a-1。
        if (h[`subexp_more_bits[${n}]`]) {
          i++;
          mk += a;
        } else {
          h[`subexp_bits[${n}]`] = b.u(b2); // 指定参数减去mk的值。
          return h[`subexp_bits[${n}]`] + mk;
        }
      }
      ++n;
    }
  };

  // 5.9.29. Inverse recenter function
  inverse_recenter(r: number, v: number) {
    if (v > 2 * r)
      return v;
    else if (v & 1)
      return r - ((v + 1) >> 1);
    else
      return r + (v >> 1);
  };

  // 5.9.30. Film grain params syntax
  film_grain_params({ b, h }: { b: BitReader, h: any }) {
    if (!this.seq_header.film_grain_params_present ||
      (!h.show_frame && !h.showable_frame)) {
      this.reset_grain_params({ b, h });
      return;
    }
    h.apply_grain = b.u(1); // =1指定应该将胶片颗粒添加到该帧。pars->apply_grain
    if (!h.apply_grain) {
      this.reset_grain_params({ b, h });
      return;
    }
    h.grain_seed = b.u(16); // 指定在胶片颗粒合成过程中使用的伪随机数的起始值。pars->random_seed
    if (h.frame_type == INTER_FRAME)
      h.update_grain = b.u(1);  // =1表示应该发送一组新的参数；=0意味着应该使用前一组参数。pars->update_parameters
    else
      h.update_grain = 1;
    if (!h.update_grain) {
      h.film_grain_params_ref_idx = b.u(3); // 表示哪个参考帧包含用于该帧的电影颗粒参数；等于ref_frame_idx[j]是位流一致性的要求。film_grain_params_ref_idx
      let tempGrainSeed = h.grain_seed;
      this.load_grain_params(h.film_grain_params_ref_idx, { b, h });
      h.grain_seed = tempGrainSeed;
      return;
    }
    h.num_y_points = b.u(4);  // 指定luma组件的逐块线性缩放函数的点数。pars->num_y_points
    if (h.num_y_points > 14) {
      console.error("Number of points for film grain luma scaling function exceeds the maximum value.");
    }
    for (let i = 0; i < h.num_y_points; i++) {
      h[`point_y_value[${i}]`] = b.u(8);    // 表示亮度分量分段线性缩放函数第I点的x(亮度值)坐标。这些值以0..255的范围表示。(如果是10位视频，这些值对应于亮度值除以4。如果是12位视频，这些值对应于亮度值除以16。)pars->scaling_points_y[i][0]
      if (i && h[`point_y_value[${i - 1}]`] >= h[`point_y_value[${i}]`]) {
        console.error("First coordinate of the scaling function points shall be increasing.");
      }
      h[`point_y_scaling[${i}]`] = b.u(8);  // 表示亮度分量分段线性缩放函数第I点的缩放(输出)值。pars->scaling_points_y[i][1]
    }
    if (this.seq_header.mono_chrome) {
      h.chroma_scaling_from_luma = 0; // 指定从亮度缩放推断色度缩放。pars->chroma_scaling_from_luma
    } else {
      h.chroma_scaling_from_luma = b.u(1);
    }
    if (this.seq_header.mono_chrome || this.seq_header.chroma_scaling_from_luma ||
      (this.seq_header.subsampling_x == 1 && this.seq_header.subsampling_y == 1 &&
        h.num_y_points == 0)) {
      h.num_cb_points = 0;  // 指定cb组件的分段线性缩放函数的点数。pars->num_cb_points
      h.num_cr_points = 0;  // pars->num_cr_points
    } else {
      h.num_cb_points = b.u(4);
      if (h.num_cb_points > 10) {
        console.error("Number of points for film grain cb scaling function exceeds the maximum value.");
      }
      for (let i = 0; i < h.num_cb_points; i++) {
        h[`point_cb_value[${i}]`] = b.u(8); // 表示cb分量分段线性缩放函数第I点的x坐标。这些值以0..255的范围表示。
        if (i && h[`point_cb_value[${i - 1}]`] >= h[`point_cb_value[${i}]`]) {
          console.error("First coordinate of the scaling function points shall be increasing.");
        }
        h[`point_cb_scaling[${i}]`] = b.u(8); // 表示cb分量分段线性缩放函数第I点的缩放(输出)值。
      }
      h.num_cr_points = b.u(4); // 指定表示cr组件的逐块线性缩放函数的点数。pars->num_cr_points
      if (h.num_cr_points > 10) {
        console.error("Number of points for film grain cr scaling function exceeds the maximum value.");
      }
      for (let i = 0; i < h.num_cr_points; i++) {
        h[`point_cr_value[${i}]`] = b.u(8); // 表示cr分量分段线性缩放函数第I点的x坐标。这些值以0..255的范围表示
        if (i && h[`point_cr_value[${i - 1}]`] >= h[`point_cr_value[${i}]`]) {
          console.error("First coordinate of the scaling function points shall be increasing.");
        }
        h[`point_cr_scaling[${i}]`] = b.u(8); // 表示cr分量分段线性缩放函数第I点的缩放(输出)值。
      }
      if ((this.seq_header.subsampling_x == 1) && (this.seq_header.subsampling_y == 1) &&
        (((h.num_cb_points == 0) && (h.num_cr_points != 0)) ||
          ((h.num_cb_points != 0) && (h.num_cr_points == 0)))) {
        console.error("In YCbCr 4:2:0, film grain shall be applied to both chroma components or neither.");
      }
    }
    h.grain_scaling_minus_8 = b.u(2); // 应用于色度组件的值；可以取0..3、确定膜粒标准差的范围和量化步骤。pars->scaling_shift
    h.ar_coeff_lag = b.u(2);          // 指定亮度和色度的自回归系数的数量。pars->ar_coeff_lag
    let numPosLuma = 2 * h.ar_coeff_lag * (h.ar_coeff_lag + 1);
    let numPosChroma;
    if (h.num_y_points) {
      numPosChroma = numPosLuma + 1;
      for (let i = 0; i < numPosLuma; i++)
        h[`ar_coeffs_y_plus_128[${i}]`] = b.u(8); // 指定用于Y平面的自回归系数。pars->ar_coeffs_y
    } else {
      numPosChroma = numPosLuma;
    }
    if (h.chroma_scaling_from_luma || h.num_cb_points) {
      for (let i = 0; i < numPosChroma; i++)
        h[`ar_coeffs_cb_plus_128[${i}]`] = b.u(8);  // 指定用于U平面的自回归系数。pars->ar_coeffs_cb
    }
    if (h.chroma_scaling_from_luma || h.num_cr_points) {
      for (let i = 0; i < numPosChroma; i++)
        h[`ar_coeffs_cr_plus_128[${i}]`] = b.u(8);  // 指定用于V平面的自回归系数。pars->ar_coeffs_cr
    }
    h.ar_coeff_shift_minus_6 = b.u(2);  // 指定自回归系数的范围。0、1、2和3的值分别对应于自回归系数[-2,2)、[-1,1)、[-0.5,0.5)和[-0.25,0.25)的范围。pars->ar_coeff_shift
    h.grain_scale_shift = b.u(2);       // 指定在颗粒合成过程中高斯随机数应该按比例缩小多少。pars->grain_scale_shift
    if (h.num_cb_points) {
      h.cb_mult = b.u(8);       // 表示cb分量的乘法器，用于推导cb分量标度函数的输入索引。pars->cb_mult
      h.cb_luma_mult = b.u(8);  // 表示用于推导cb分量缩放函数的输入索引的平均luma分量的乘法器。pars->cb_luma_mult
      h.cb_offset = b.u(9);     // 表示在推导cb分量缩放函数的输入索引时使用的偏移量。pars->cb_offset
    }
    if (h.num_cr_points) {
      h.cr_mult = b.u(8);       // 表示cr分量的乘法器，用于推导cr分量缩放函数的输入索引。pars->cr_mult
      h.cr_luma_mult = b.u(8);  // 表示用于推导cr分量缩放函数的输入索引的平均luma分量的乘法器。pars->cr_luma_mult 
      h.cr_offset = b.u(9);     // 表示在推导cr分量缩放函数的输入索引时使用的偏移量。pars->cr_offset 
    }
    h.overlap_flag = b.u(1);              // =1表示膜粒块之间需要重叠；=0表示膜粒块之间不能重叠。pars->overlap_flag
    h.clip_to_restricted_range = b.u(1);  // =1表示在加入胶片颗粒后，对采样值进行限制(studio)范围的裁剪(studio swing的解释参见color_range的语义)；=0表示加入膜粒后对采样值进行全范围裁剪。pars->clip_to_restricted_range
  };

  // 5.9.31. Temporal point info syntax
  temporal_point_info({ b, h }: { b: BitReader, h: any }) {
    let n = h.frame_presentation_time_length_minus_1 + 1;
    h.frame_presentation_time = b.u(n); // 指定帧的表示时间(以时钟节拍为单位)。DispCT从正在解码的操作点的最后一个随机接入点的移除时间开始计数。语法元素被标记为一个固定长度的无符号整数，其长度由Frame_presentation_time_length_minus_1 + 1。frame_presentation_time是模数1 <<的余数。(frame_presentation_time_length_minus_1 + 1)计数器。
  }

  // 5.10. Frame OBU syntax
  frame_obu(sz: number, { b, h }: { b: BitReader, h: any }) {
    let startBitPos = b.get_position();
    this.frame_header_obu({ b, h });
    b.byte_alignment();
    let endBitPos = b.get_position();
    let headerBytes = (endBitPos - startBitPos) / 8;
    sz = sz - headerBytes;
    this.tile_group_obu(sz, { b, h });
  };

  // 5.11.1. General tile group OBU syntax
  tile_group_obu(sz: number, { b, h }: { b: BitReader, h: any }) {
    h['NumTiles'] = h['TileCols'] * h['TileRows'];  // 指定帧中tile的总数。
    let startBitPos = b.get_position();
    h.tile_start_and_end_present_flag = 0;
    if (h['NumTiles'] > 1)
      h.tile_start_and_end_present_flag = b.u(1);
    if (h['NumTiles'] == 1 || !h.tile_start_and_end_present_flag) {
      h.tg_start = 0; // 指定当前tile组中第一个tile的从零开始的索引。
      h.tg_end = h['NumTiles'] - 1; // 指定当前tile组中最后一个tile的从零开始的索引。
    } else {
      let tileBits = h['TileColsLog2'] + h['TileRowsLog2'];
      h.tg_start = b.u(tileBits);
      h.tg_end = b.u(tileBits);
    }
    b.byte_alignment();
    let endBitPos = b.get_position();
    let headerBytes = (endBitPos - startBitPos) / 8;
    sz -= headerBytes;
    let tileSize = 0; // 以字节为单位指定下一个编码贴图的大小。
    for (h['TileNum'] = h.tg_start; h['TileNum'] <= h.tg_end; h['TileNum']++) {
      let tileRow = h['TileNum'] / h['TileCols'];
      let tileCol = h['TileNum'] % h['TileCols'];
      let lastTile = h['TileNum'] == h.tg_end;
      if (lastTile) {
        tileSize = sz;
      } else {
        h.tile_size_minus_1 = b.le(h['TileSizeBytes']);
        tileSize = h.tile_size_minus_1 + 1;
        sz -= tileSize + h['TileSizeBytes'];
      }
      h['MiRowStart'] = h[`MiRowStarts[${tileRow}]`];
      h['MiRowEnd'] = h[`MiRowStarts[${tileRow + 1}]`];
      h['MiColStart'] = h[`MiColStarts[${tileCol}]`];
      h['MiColEnd'] = h[`MiColStarts[${tileCol + 1}]`];
      h['CurrentQIndex'] = h.base_q_idx;
      this.init_symbol(tileSize, { b, h });
      this.decode_tile({ b, h });
      this.exit_symbol({ b, h });
    }
    if (h.tg_end == h['NumTiles'] - 1) {
      if (!h.disable_frame_end_update_cdf) {
        this.frame_end_update_cdf({ b, h });
      }
      this.decode_frame_wrapup({ b, h });
      h.SeenFrameHeader = 0;
    }

  };

  // 5.11.2. Decode tile syntax
  decode_tile({ b, h }: { b: BitReader, h: any }) {
    /********************** libaom start **********************/
    let tile_info: any = {};
    let num_planes = this.seq_header['NumPlanes'];


    // let av1_tile_set_row = function (tile: any, cm: any, row: number) {

    // }
    // let av1_tile_set_col = function (tile: any, cm: any, col: number) {

    // }
    // let av1_zero_above_context = function (cm: any, xd: any, mi_col_start: number, mi_col_end: number, tile_row: number) {

    // }
    // let av1_reset_loop_filter_delta = function (xd: any, num_planes: number) {

    // }
    // let av1_reset_loop_restoration = function (xd: any, num_planes: number) {

    // }
    // let decode_tile2 = function() {
    //   for (let mi_row = tile_info.mi_row_start; mi_row < tile_info.mi_row_end;
    //     mi_row += h.mib_size) {
    //       for (let mi_col = tile_info.mi_col_start; mi_col < tile_info.mi_col_end;
    //         mi_col += h.mib_size) {

    //         }
    //       }
    // }

    // /********************** libaom end **********************/

    const Wiener_Taps_Mid = [3, -7, 15];
    const Sgrproj_Xqd_Mid = [-32, 31];

    this.clear_above_context({ b, h });
    for (let i = 0; i < FRAME_LF_COUNT; i++)
      h[`DeltaLF[${i}]`] = 0;
    for (let plane = 0; plane < this.seq_header['NumPlanes']; plane++) {
      for (let pass = 0; pass < 2; pass++) {
        h[`RefSgrXqd[${plane}][${pass}]`] = Sgrproj_Xqd_Mid[pass];
        for (let i = 0; i < WIENER_COEFFS; i++) {
          h[`RefLrWiener[${plane}][${pass}][${i}]`] = Wiener_Taps_Mid[i];
        }
      }
    }
    let sbSize = this.seq_header.use_128x128_superblock ? BLOCK_128X128 : BLOCK_64X64;
    let sbSize4 = Num_4x4_Blocks_Wide[sbSize];
    for (let r = h['MiRowStart']; r < h['MiRowEnd']; r += sbSize4) {
      this.clear_left_context({ b, h });
      for (let c = h['MiColStart']; c < h['MiColEnd']; c += sbSize4) {
        h['ReadDeltas'] = h.delta_q_present;
        this.clear_cdef({ b, h }, r, c);
        this.clear_block_decoded_flags({ b, h }, r, c, sbSize4);
        this.read_lr({ b, h }, r, c, sbSize);
        this.decode_partition({ b, h }, r, c, sbSize);
      }
    }

    // libaom
    // let this_ = this;
    // let get_tile_buffer = function (is_last: boolean) {
    //   let size = 0;
    //   if (!is_last) {
    //     size = 0;
    //   } else {
    //     size = b.byteLength() - b.get_position() / 8;
    //   }
    //   return size;
    // }
    // this.cur_frame.tile_buffers = {};
    // let get_tile_buffers = function () {
    //   let tc = 0;
    //   for (let r = 0; r < h['TileRows']; ++r) {
    //     for (let c = 0; c < h['TileCols']; ++c, ++tc) {
    //       const is_last = (tc == h.tg_end);
    //       if (tc < h.tg_start || tc > h.tg_end) continue;
    //       let size = get_tile_buffer(is_last);
    //       let buf = b.readBuffer(size);
    //       this_.cur_frame.tile_buffers[`[${r}][${c}]`] = buf;
    //     }
    //   }
    // }
    // let tile_rows_start = 0;
    // let tile_rows_end = h['TileRows'];
    // let tile_cols_start = 0;
    // let tile_cols_end = h['TileCols'];
    // let inv_col_order = 0;
    // let inv_row_order = 0;
    // let tile_cols = h['TileCols'];
    // let tile_rows = h['TileRows'];

    // for (let tile_row = tile_rows_start; tile_row < tile_rows_end; ++tile_row) {
    //   const row = inv_row_order ? tile_rows - 1 - tile_row : tile_row;
    //   for (let tile_col = tile_cols_start; tile_col < tile_cols_end; ++tile_col) {
    //     const col = inv_col_order ? tile_cols - 1 - tile_col : tile_col;

    //   }
    // }

    // let tile_rows_start = 0;
    // let tile_rows_end = h['TileRows'];
    // let tile_cols_start = 0;
    // let tile_cols_end = h['TileCols'];
    // for (let tile_row = tile_rows_start; tile_row < tile_rows_end; ++tile_row) {
    //   for (let tile_col = tile_cols_start; tile_col < tile_cols_end; ++tile_col) {
    //     this._7_3_2({ b, h });
    //   }
    // }
  }

  // 5.11.3. Clear block decoded flags function
  clear_block_decoded_flags({ b, h }: { b: BitReader, h: any }, r: number, c: number, sbSize4: number) {
    for (let plane = 0; plane < h['NumPlanes']; plane++) {
      let subX = (plane > 0) ? this.seq_header.subsampling_x : 0;
      let subY = (plane > 0) ? this.seq_header.subsampling_y : 0;
      let sbWidth4 = (h['MiColEnd'] - c) >> subX;
      let sbHeight4 = (h['MiRowEnd'] - r) >> subY;
      for (let y = -1; y <= (sbSize4 >> subY); y++)
        for (let x = -1; x <= (sbSize4 >> subX); x++) {
          if (y < 0 && x < sbWidth4)
            h[`BlockDecoded[${plane}][${y}][${x}]`] = 1;
          else if (x < 0 && y < sbHeight4)
            h[`BlockDecoded[${plane}][${y}][${x}]`] = 1;
          else
            h[`BlockDecoded[${plane}][${y}][${x}]`] = 0;
        }
      h[`BlockDecoded[${plane}][${sbSize4 >> subY}][-1]`] = 0;
    }
  }

  // 5.11.4. Decode partition syntax
  decode_partition({ b, h }: { b: BitReader, h: any }, r: number, c: number, bSize: number) {
    if (r >= h['MiRows'] || c >= h['MiCols'])
      return 0;
    h['AvailU'] = this.is_inside({ b, h }, r - 1, c);
    h['AvailL'] = this.is_inside({ b, h }, r, c - 1);
    let num4x4 = Num_4x4_Blocks_Wide[bSize];
    let halfBlock4x4 = num4x4 >> 1;
    let quarterBlock4x4 = halfBlock4x4 >> 1;
    let hasRows = (r + halfBlock4x4) < h['MiRows'];
    let hasCols = (c + halfBlock4x4) < h['MiCols'];
    if (bSize < BLOCK_8X8) {
      h.partition = PARTITION_NONE;
    } else if (hasRows && hasCols) {
      h.partition = this.S({ b, h }, { name: "partition", r, c, bsize: bSize });
    } else if (hasCols) {
      h.split_or_horz = this.S({ b, h }, { name: "split_or_horz", r, c, bsize: bSize });
      h.partition = h.split_or_horz ? PARTITION_SPLIT : PARTITION_HORZ;
    } else if (hasRows) {
      h.split_or_vert = this.S({ b, h }, { name: "split_or_vert", r, c, bsize: bSize });
      h.partition = h.split_or_vert ? PARTITION_SPLIT : PARTITION_VERT;
    } else {
      h.partition = PARTITION_SPLIT;
    }
    let subSize = Partition_Subsize[h.partition][bSize];
    let splitSize = Partition_Subsize[PARTITION_SPLIT][bSize];
    if (h.partition == PARTITION_NONE) {
      this.decode_block({ b, h }, r, c, subSize);
    } else if (h.partition == PARTITION_HORZ) {
      this.decode_block({ b, h }, r, c, subSize);
      if (hasRows)
        this.decode_block({ b, h }, r + halfBlock4x4, c, subSize);
    } else if (h.partition == PARTITION_VERT) {
      this.decode_block({ b, h }, r, c, subSize);
      if (hasCols)
        this.decode_block({ b, h }, r, c + halfBlock4x4, subSize);
    } else if (h.partition == PARTITION_SPLIT) {
      this.decode_partition({ b, h }, r, c, subSize);
      this.decode_partition({ b, h }, r, c + halfBlock4x4, subSize);
      this.decode_partition({ b, h }, r + halfBlock4x4, c, subSize);
      this.decode_partition({ b, h }, r + halfBlock4x4, c + halfBlock4x4, subSize);
    } else if (h.partition == PARTITION_HORZ_A) {
      this.decode_block({ b, h }, r, c, splitSize);
      this.decode_block({ b, h }, r, c + halfBlock4x4, splitSize);
      this.decode_block({ b, h }, r + halfBlock4x4, c, subSize);
    } else if (h.partition == PARTITION_HORZ_B) {
      this.decode_block({ b, h }, r, c, subSize);
      this.decode_block({ b, h }, r + halfBlock4x4, c, splitSize);
      this.decode_block({ b, h }, r + halfBlock4x4, c + halfBlock4x4, splitSize);
    } else if (h.partition == PARTITION_VERT_A) {
      this.decode_block({ b, h }, r, c, splitSize);
      this.decode_block({ b, h }, r + halfBlock4x4, c, splitSize);
      this.decode_block({ b, h }, r, c + halfBlock4x4, subSize);
    } else if (h.partition == PARTITION_VERT_B) {
      this.decode_block({ b, h }, r, c, subSize);
      this.decode_block({ b, h }, r, c + halfBlock4x4, splitSize);
      this.decode_block({ b, h }, r + halfBlock4x4, c + halfBlock4x4, splitSize);
    } else if (h.partition == PARTITION_HORZ_4) {
      this.decode_block({ b, h }, r + quarterBlock4x4 * 0, c, subSize);
      this.decode_block({ b, h }, r + quarterBlock4x4 * 1, c, subSize);
      this.decode_block({ b, h }, r + quarterBlock4x4 * 2, c, subSize);
      if (r + quarterBlock4x4 * 3 < h['MiRows'])
        this.decode_block({ b, h }, r + quarterBlock4x4 * 3, c, subSize);
    } else {
      this.decode_block({ b, h }, r, c + quarterBlock4x4 * 0, subSize);
      this.decode_block({ b, h }, r, c + quarterBlock4x4 * 1, subSize);
      this.decode_block({ b, h }, r, c + quarterBlock4x4 * 2, subSize);
      if (c + quarterBlock4x4 * 3 < h['MiCols'])
        this.decode_block({ b, h }, r, c + quarterBlock4x4 * 3, subSize);
    }
  }


  // 5.11.5. Decode block syntax
  decode_block({ b, h }: { b: BitReader, h: any }, r: number, c: number, subSize: number) {
    let reset_block_context = function (bw4: number, bh4: number, seq_header: any) {
      for (let plane = 0; plane < 1 + 2 * h['HasChroma']; plane++) {
        let subX = (plane > 0) ? seq_header.subsampling_x : 0;
        let subY = (plane > 0) ? seq_header.subsampling_y : 0;
        for (let i = h['MiCol'] >> subX; i < ((h['MiCol'] + bw4) >> subX); i++) {
          h[`AboveLevelContext[${plane}][${i}]`] = 0;
          h[`AboveDcContext[${plane}][${i}]`] = 0;
        }
        for (let i = h['MiRow'] >> subY; i < ((h['MiRow'] + bh4) >> subY); i++) {
          h[`LeftLevelContext[${plane}][${i}]`] = 0;
          h[`LeftDcContext[${plane}][${i}]`] = 0;
        }
      }
    }

    h['MiRow'] = r;
    h['MiCol'] = c;
    h['MiSize'] = subSize;
    let bw4 = Num_4x4_Blocks_Wide[subSize];
    let bh4 = Num_4x4_Blocks_High[subSize];
    if (bh4 == 1 && this.seq_header.subsampling_y && (h['MiRow'] & 1) == 0)
      h['HasChroma'] = 0;
    else if (bw4 == 1 && this.seq_header.subsampling_x && (h['MiCol'] & 1) == 0)
      h['HasChroma'] = 0;
    else
      h['HasChroma'] = this.seq_header['NumPlanes'] > 1;
    h['AvailU'] = this.is_inside({ b, h }, r - 1, c);
    h['AvailL'] = this.is_inside({ b, h }, r, c - 1);
    h['AvailUChroma'] = h['AvailU'];
    h['AvailLChroma'] = h['AvailL'];
    if (h['HasChroma']) {
      if (this.seq_header.subsampling_y && bh4 == 1)
        h['AvailUChroma'] = this.is_inside({ b, h }, r - 2, c);
      if (this.seq_header.subsampling_x && bw4 == 1)
        h['AvailLChroma'] = this.is_inside({ b, h }, r, c - 2);
    } else {
      h['AvailUChroma'] = 0;
      h['AvailLChroma'] = 0;
    }
    this.mode_info({ b, h });
    this.palette_tokens({ b, h });
    this.read_block_tx_size({ b, h });
    if (h.skip)
      reset_block_context(bw4, bh4, this.seq_header);
    let isCompound = Number(h['RefFrame[1]'] > INTRA_FRAME);
    for (let y = 0; y < bh4; y++) {
      for (let x = 0; x < bw4; x++) {
        h[`YModes[${r + y}][${c + x}]`] = h['YMode'];
        if (h['RefFrame[0]'] == INTRA_FRAME && h['HasChroma'])
          h[`UVModes[${r + y}][${c + x}]`] = h['UVMode'];
        for (let refList = 0; refList < 2; refList++)
          h[`RefFrames[${r + y}][${c + x}][${refList}]`] = h[`RefFrame[${refList}]`];
        if (h.is_inter) {
          if (!h.use_intrabc) {
            h[`CompGroupIdxs[${r + y}][${c + x}]`] = h.comp_group_idx;
            h[`CompoundIdxs[${r + y}][${c + x}]`] = h.compound_idx;
          }
          for (let dir = 0; dir < 2; dir++) {
            h[`InterpFilters[${r + y}][${c + x}][${dir}]`] = h[`interp_filter[${dir}]`];
          }
          for (let refList = 0; refList < 1 + isCompound; refList++) {
            h[`Mvs[${r + y}][${c + x}][${refList}]`] = h[`Mv[${refList}]`];
          }
        }
      }
    }
    this.compute_prediction({ b, h });
    this.residual({ b, h });
    for (let y = 0; y < bh4; y++) {
      for (let x = 0; x < bw4; x++) {
        h[`IsInters[${r + y}][${c + x}]`] = h.is_inter;
        h[`SkipModes[${r + y}][${c + x}]`] = h.skip_mode;
        h[`Skips[${r + y}][${c + x}]`] = h.skip;
        h[`TxSizes[${r + y}][${c + x}]`] = h['TxSize'];
        h[`MiSizes[${r + y}][${c + x}]`] = h['MiSize'];
        h[`SegmentIds[${r + y}][${c + x}]`] = h.segment_id;
        h[`PaletteSizes[0][${r + y}][${c + x}]`] = h['PaletteSizeY'];
        h[`PaletteSizes[1][${r + y}][${c + x}]`] = h['PaletteSizeUV'];
        for (let i = 0; i < h['PaletteSizeY']; i++)
          h[`PaletteColors[0][${r + y}][${c + x}][${i}]`] = h[`palette_colors_y[${i}]`];
        for (let i = 0; i < h['PaletteSizeUV']; i++)
          h[`PaletteColors[1][${r + y}][${c + x}][${i}]`] = h[`palette_colors_u[${i}]`];
        for (let i = 0; i < FRAME_LF_COUNT; i++)
          h[`DeltaLFs[r + y][c + x][i]`] = h[`DeltaLF[${i}]`];
      }
    }
  }

  // 5.11.6. Mode info syntax
  mode_info({ b, h }: { b: BitReader, h: any }) {
    if (h['FrameIsIntra'])
      this.intra_frame_mode_info({ b, h });
    else
      this.inter_frame_mode_info({ b, h });
  }

  // 5.11.7. Intra frame mode info syntax
  intra_frame_mode_info({ b, h }: { b: BitReader, h: any }) {
    h.skip = 0;
    if (h['SegIdPreSkip'])
      this.intra_segment_id({ b, h });
    h.skip_mode = 0;
    this.read_skip({ b, h });
    if (!h['SegIdPreSkip'])
      this.intra_segment_id({ b, h });
    this.read_cdef({ b, h });
    this.read_delta_qindex({ b, h });
    this.read_delta_lf({ b, h });
    h['ReadDeltas'] = 0;
    h[`RefFrame[0]`] = INTRA_FRAME;
    h[`RefFrame[1]`] = NONE;
    if (h.allow_intrabc) {
      h.use_intrabc = this.S({ b, h }, { name: "use_intrabc" });
    } else {
      h.use_intrabc = 0;
    }
    if (h.use_intrabc) {
      h.is_inter = 1;
      h['YMode'] = DC_PRED;
      h['UVMode'] = DC_PRED
      h.motion_mode = SIMPLE;
      h.compound_type = COMPOUND_AVERAGE;
      h['PaletteSizeY'] = 0;
      h['PaletteSizeUV'] = 0;
      h[`interp_filter[0]`] = BILINEAR;
      h[`interp_filter[1]`] = BILINEAR;
      this.find_mv_stack(0);
      this.assign_mv({ b, h }, 0);
    } else {
      h.is_inter = 0;
      h.intra_frame_y_mode = this.S({ b, h }, { name: "intra_frame_y_mode" });
      h['YMode'] = h.intra_frame_y_mode;
      this.intra_angle_info_y({ b, h });
      if (h['HasChroma']) {
        h.uv_mode = this.S({ b, h }, { name: "uv_mode" });
        h['UVMode'] = h.uv_mode;
        if (h['UVMode'] == UV_CFL_PRED) {
          this.read_cfl_alphas({ b, h });
        }
        this.intra_angle_info_uv({ b, h });
      }
      h['PaletteSizeY'] = 0;
      h['PaletteSizeUV'] = 0;
      if (h['MiSize'] >= BLOCK_8X8 &&
        Block_Width[h['MiSize']] <= 64 &&
        Block_Height[h['MiSize']] <= 64 &&
        h.allow_screen_content_tools) {
        this.palette_mode_info({ b, h });
      }
      this.filter_intra_mode_info({ b, h });
    }
  }

  // 5.11.8. Intra segment ID syntax
  intra_segment_id({ b, h }: { b: BitReader, h: any }) {
    if (h.segmentation_enabled)
      this.read_segment_id({ b, h });
    else
      h.segment_id = 0;
    h['Lossless'] = h[`LosslessArray[${h.segment_id}]`];
  }

  // 5.11.9. Read segment ID syntax
  read_segment_id({ b, h }: { b: BitReader, h: any }) {
    let neg_deinterleave = function (diff: number, ref: number, max: number) {
      if (!ref)
        return diff
      if (ref >= (max - 1))
        return max - diff - 1
      if (2 * ref < max) {
        if (diff <= 2 * ref) {
          if (diff & 1)
            return ref + ((diff + 1) >> 1)
          else
            return ref - (diff >> 1)
        }
        return diff
      } else {
        if (diff <= 2 * (max - ref - 1)) {
          if (diff & 1)
            return ref + ((diff + 1) >> 1)
          else
            return ref - (diff >> 1)
        }
        return max - (diff + 1)
      }
    }

    let prevUL = -1;
    if (h['AvailU'] && h['AvailL'])
      prevUL = h[`SegmentIds[${h['MiRow'] - 1}][${h['MiCol'] - 1}]`];
    let prevU = -1;
    if (h['AvailU'])
      prevU = h[`SegmentIds[${h['MiRow'] - 1}][${h['MiCol']}]`];
    let prevL = -1;
    if (h['AvailL'])
      prevL = h[`SegmentIds[${h['MiRow']}][${h['MiCol']} - 1]`];
    if (prevU == -1)
      h.pred = (prevL == -1) ? 0 : prevL
    else if (prevL == -1)
      h.pred = prevU
    else
      h.pred = (prevUL == prevU) ? prevU : prevL
    if (h.skip) {
      h.segment_id = h.pred;
    } else {
      h.segment_id = this.S({ b, h }, { name: "segment_id" });
      h.segment_id = neg_deinterleave(h.segment_id, h.pred,
        h['LastActiveSegId'] + 1);
    }
  }

  // 5.11.10. Skip mode syntax
  read_skip_mode({ b, h }: { b: BitReader, h: any }) {
    if (this.seg_feature_active({ b, h }, SEG_LVL_SKIP) ||
      this.seg_feature_active({ b, h }, SEG_LVL_REF_FRAME) ||
      this.seg_feature_active({ b, h }, SEG_LVL_GLOBALMV) ||
      !h.skip_mode_present ||
      Block_Width[h['MiSize']] < 8 ||
      Block_Height[h['MiSize']] < 8) {
      h.skip_mode = 0;
    } else {
      h.skip_mode = this.S({ b, h }, { name: "skip_mode" });
    }
  }

  // 5.11.11. Skip syntax
  read_skip({ b, h }: { b: BitReader, h: any }) {
    if (h['SegIdPreSkip'] && this.seg_feature_active({ b, h }, SEG_LVL_SKIP)) {
      h.skip = 1;
    } else {
      h.skip = this.S({ b, h }, { name: "Skip" });
    }
  }

  // 5.11.12. Quantizer index delta syntaxf
  read_delta_qindex({ b, h }: { b: BitReader, h: any }) {
    let sbSize = h.use_128x128_superblock ? BLOCK_128X128 : BLOCK_64X64;
    if (h['MiSize'] == sbSize && h.skip)
      return;
    if (h['ReadDeltas']) {
      h.delta_q_abs = this.S({ b, h }, { name: "delta_q_abs" });
      if (h.delta_q_abs == DELTA_Q_SMALL) {
        h.delta_q_rem_bits = this.L({ b, h }, 3);
        h.delta_q_rem_bits++;
        h.delta_q_abs_bits = this.L({ b, h }, h.delta_q_rem_bits);
        h.delta_q_abs = h.delta_q_abs_bits + (1 << h.delta_q_rem_bits) + 1;
      }
      if (h.delta_q_abs) {
        h.delta_q_sign_bit = this.L({ b, h }, 1);
        let reducedDeltaQIndex = h.delta_q_sign_bit ? -h.delta_q_abs : h.delta_q_abs;
        h['CurrentQIndex'] = this.Clip3(1, 255,
          h['CurrentQIndex'] + (reducedDeltaQIndex << h.delta_q_res));
      }
    }
  }

  // 5.11.13. Loop filter delta syntax
  read_delta_lf({ b, h }: { b: BitReader, h: any }) {
    let sbSize = h.use_128x128_superblock ? BLOCK_128X128 : BLOCK_64X64;
    if (h['MiSize'] == sbSize && h.skip)
      return;
    if (h['ReadDeltas'] && h.delta_lf_present) {
      let frameLfCount = 1;
      if (h.delta_lf_multi) {
        frameLfCount = (h['NumPlanes'] > 1) ? FRAME_LF_COUNT : (FRAME_LF_COUNT - 2);
      }
      for (let i = 0; i < frameLfCount; i++) {
        h.delta_lf_abs = this.S({ b, h }, { name: "delta_lf_abs" });
        let deltaLfAbs = h.delta_lf_abs;
        if (h.delta_lf_abs == DELTA_LF_SMALL) {
          h.delta_lf_rem_bits = this.L({ b, h }, 3);
          let n = h.delta_lf_rem_bits + 1;
          h.delta_lf_abs_bits = this.L({ b, h }, n);
          let deltaLfAbs = h.delta_lf_abs_bits +
            (1 << n) + 1;
        }
        if (deltaLfAbs) {
          h.delta_lf_sign_bit = this.L({ b, h }, 1);
          let reducedDeltaLfLevel = h.delta_lf_sign_bit ?
            -deltaLfAbs :
            deltaLfAbs;
          h[`DeltaLF[${i}]`] = this.Clip3(-MAX_LOOP_FILTER, MAX_LOOP_FILTER, h[`DeltaLF[${i}]`] +
            (reducedDeltaLfLevel << h.delta_lf_res))
        }
      }
    }
  }

  // 5.11.14. Segmentation feature active function
  seg_feature_active_idx({ b, h }: { b: BitReader, h: any }, idx: number, feature: number) {
    return h.segmentation_enabled && h[`FeatureEnabled[${idx}][${feature}]`];
  }
  seg_feature_active({ b, h }: { b: BitReader, h: any }, feature: number) {
    return this.seg_feature_active_idx({ b, h }, h.segment_id, feature);
  }

  // 5.11.15. TX size syntax
  read_tx_size({ b, h }: { b: BitReader, h: any }, allowSelect: number) {
    const Max_Tx_Depth = [
      0, 1, 1, 1,
      2, 2, 2, 3,
      3, 3, 4, 4,
      4, 4, 4, 4,
      2, 2, 3, 3,
      4, 4];
    if (h['Lossless']) {
      h['TxSize'] = TX_4X4;
      return;
    }
    let maxRectTxSize = Max_Tx_Size_Rect[h['MiSize']];
    let maxTxDepth = Max_Tx_Depth[h['MiSize']];
    h['TxSize'] = maxRectTxSize;
    if (h['MiSize'] > BLOCK_4X4 && allowSelect && h['TxMode'] == TX_MODE_SELECT) {
      h.tx_depth = this.S({ b, h }, { name: "tx_depth" });
      for (let i = 0; i < h.tx_depth; i++)
        h['TxSize'] = Split_Tx_Size[h['TxSize']];
    }
  }


  // 5.11.16. Block TX size syntax
  read_block_tx_size({ b, h }: { b: BitReader, h: any }) {
    let bw4 = Num_4x4_Blocks_Wide[h['MiSize']];
    let bh4 = Num_4x4_Blocks_High[h['MiSize']];
    if (h['TxMode'] == TX_MODE_SELECT &&
      h['MiSize'] > BLOCK_4X4 && h.is_inter &&
      !h.skip && !h['Lossless']) {
      let maxTxSz = Max_Tx_Size_Rect[h['MiSize']];
      let txW4 = Tx_Width[maxTxSz] / MI_SIZE;
      let txH4 = Tx_Height[maxTxSz] / MI_SIZE;
      for (let row = h['MiRow']; row < h['MiRow'] + bh4; row += txH4)
        for (let col = h['MiCol']; col < h['MiCol'] + bw4; col += txW4)
          this.read_var_tx_size({ b, h }, row, col, maxTxSz, 0);
    } else {
      this.read_tx_size({ b, h }, Number(!h.skip || !h.is_inter));
      for (let row = h['MiRow']; row < h['MiRow'] + bh4; row++)
        for (let col = h['MiCol']; col < h['MiCol'] + bw4; col++)
          h[`InterTxSizes[${row}][${col}]`] = h['TxSize'];
    }
  }

  // 5.11.17. Var TX size syntax
  read_var_tx_size({ b, h }: { b: BitReader, h: any }, row: number, col: number, txSz: number, depth: number) {
    if (row >= h['MiRows'] || col >= h['MiCols'])
      return;
    if (txSz == TX_4X4 || depth == MAX_VARTX_DEPTH) {
      h.txfm_split = 0;
    } else {
      h.txfm_split = this.S({ b, h }, { name: "txfm_split" });
    }
    let w4 = Tx_Width[txSz] / MI_SIZE;
    let h4 = Tx_Height[txSz] / MI_SIZE;
    if (h.txfm_split) {
      let subTxSz = Split_Tx_Size[txSz];
      let stepW = Tx_Width[subTxSz] / MI_SIZE;
      let stepH = Tx_Height[subTxSz] / MI_SIZE;
      for (let i = 0; i < h4; i += stepH)
        for (let j = 0; j < w4; j += stepW)
          this.read_var_tx_size({ b, h }, row + i, col + j, subTxSz, depth + 1);
    } else {
      for (let i = 0; i < h4; i++)
        for (let j = 0; j < w4; j++)
          h[`InterTxSizes[${row + i}][${col + j}]`] = txSz;
      h['TxSize'] = txSz;
    }
  }

  // 5.11.18. Inter frame mode info syntax
  inter_frame_mode_info({ b, h }: { b: BitReader, h: any }) {
    h.use_intrabc = 0
    h[`LeftRefFrame[0]`] = h['AvailL'] ? h[`RefFrames[${h['MiRow']}][${h['MiCol'] - 1}][0]`] : INTRA_FRAME;
    h[`AboveRefFrame[0]`] = h['AvailU'] ? h[`RefFrames[${h['MiRow'] - 1}][${h['MiCol']}][0]`] : INTRA_FRAME;
    h[`LeftRefFrame[1]`] = h['AvailL'] ? h[`RefFrames[${h['MiRow']}][${h['MiCol']} - 1][1]`] : NONE;
    h[`AboveRefFrame[1]`] = h['AvailU'] ? h[`RefFrames[${h['MiRow']} - 1][${h['MiCol']}][1]`] : NONE;
    h['LeftIntra'] = h[`LeftRefFrame[0]`] <= INTRA_FRAME;
    h['AboveIntra'] = h[`AboveRefFrame[0]`] <= INTRA_FRAME;
    h['LeftSingle'] = h[`LeftRefFrame[1]`] <= INTRA_FRAME;
    h['AboveSingle'] = h[`AboveRefFrame[1]`] <= INTRA_FRAME;
    h.skip = 0;
    this.inter_segment_id({ b, h }, 1);
    this.read_skip_mode({ b, h });
    if (h.skip_mode)
      h.skip = 1;
    else
      this.read_skip({ b, h });
    if (!h['SegIdPreSkip'])
      this.inter_segment_id({ b, h }, 0);
    h['Lossless'] = h[`LosslessArray[segment_id]`];
    this.read_cdef({ b, h });
    this.read_delta_qindex({ b, h });
    this.read_delta_lf({ b, h });
    h['ReadDeltas'] = 0;
    this.read_is_inter({ b, h });
    if (h.is_inter)
      this.inter_block_mode_info({ b, h });
    else
      this.intra_block_mode_info({ b, h });
  }

  // 5.11.19. Inter segment ID syntax
  inter_segment_id({ b, h }: { b: BitReader, h: any }, preSkip: number) {
    if (h.segmentation_enabled) {
      let predictedSegmentId = this.get_segment_id({ b, h });
      if (h.segmentation_update_map) {
        if (preSkip && !h['SegIdPreSkip']) {
          h.segment_id = 0;
          return;
        }
        if (!preSkip) {
          if (h.skip) {
            h.seg_id_predicted = 0;
            for (let i = 0; i < Num_4x4_Blocks_Wide[h['MiSize']]; i++)
              h[`AboveSegPredContext[${h['MiCol'] + i}]`] = h.seg_id_predicted;
            for (let i = 0; i < Num_4x4_Blocks_High[h['MiSize']]; i++)
              h[`LeftSegPredContext[${h['MiRow'] + i}]`] = h.seg_id_predicted;
            this.read_segment_id({ b, h });
            return
          }
        }
        if (h.segmentation_temporal_update == 1) {
          h.seg_id_predicted = this.S({ b, h }, { name: "seg_id_predicted" });
          if (h.seg_id_predicted)
            h.segment_id = predictedSegmentId;
          else
            this.read_segment_id({ b, h });
          for (let i = 0; i < Num_4x4_Blocks_Wide[h['MiSize']]; i++)
            h[`AboveSegPredContext[${h['MiCol'] + i}]`] = h.seg_id_predicted;
          for (let i = 0; i < Num_4x4_Blocks_High[h['MiSize']]; i++)
            h[`LeftSegPredContext[${h['MiRow'] + i}]`] = h.seg_id_predicted;
        } else {
          this.read_segment_id({ b, h });
        }
      } else {
        h.segment_id = predictedSegmentId;
      }
    } else {
      h.segment_id = 0;
    }
  }

  // 5.11.20. Is inter syntax
  read_is_inter({ b, h }: { b: BitReader, h: any }) {
    if (h.skip_mode) {
      h.is_inter = 1;
    } else if (this.seg_feature_active({ b, h }, SEG_LVL_REF_FRAME)) {
      h.is_inter = h[`FeatureData[${h.segment_id}][${SEG_LVL_REF_FRAME}]`] != INTRA_FRAME;
    } else if (this.seg_feature_active({ b, h }, SEG_LVL_GLOBALMV)) {
      h.is_inter = 1;
    } else {
      h.is_inter = this.S({ b, h }, { name: "is_inter" });
    }
  }

  // 5.11.21. Get segment ID function
  get_segment_id({ b, h }: { b: BitReader, h: any }) {
    let bw4 = Num_4x4_Blocks_Wide[h['MiSize']];
    let bh4 = Num_4x4_Blocks_High[h['MiSize']];
    let xMis = Math.min(h['MiCols'] - h['MiCol'], bw4);
    let yMis = Math.min(h['MiRows'] - h['MiRow'], bh4);
    let seg = 7;
    for (let y = 0; y < yMis; y++)
      for (let x = 0; x < xMis; x++)
        seg = Math.min(seg, h[`PrevSegmentIds[${h['MiRow'] + y}][${h['MiCol'] + x}]`]);
    return seg;
  }

  // 5.11.22. Intra block mode info syntax
  intra_block_mode_info({ b, h }: { b: BitReader, h: any }) {
    h[`RefFrame[0]`] = INTRA_FRAME;
    h[`RefFrame[1]`] = NONE;
    h.y_mode = this.S({ b, h }, { name: "y_mode" });
    h['YMode'] = h.y_mode;
    this.intra_angle_info_y({ b, h });
    if (h['HasChroma']) {
      h.uv_mode = this.S({ b, h }, { name: "uv_mode" });
      h['UVMode'] = h.uv_mode;
      if (h['UVMode'] == UV_CFL_PRED) {
        this.read_cfl_alphas({ b, h });
      }
      this.intra_angle_info_uv({ b, h });
    }
    h['PaletteSizeY'] = 0;
    h['PaletteSizeUV'] = 0;
    if (h['MiSize'] >= BLOCK_8X8 &&
      Block_Width[h['MiSize']] <= 64 &&
      Block_Height[h['MiSize']] <= 64 &&
      h.allow_screen_content_tools)
      this.palette_mode_info({ b, h });
    this.filter_intra_mode_info({ b, h });
  }

  // 5.11.23. Inter block mode info syntax
  inter_block_mode_info({ b, h }: { b: BitReader, h: any }) {
    let has_nearmv = function () {
      return (h['YMode'] == NEARMV || h['YMode'] == NEAR_NEARMV
        || h['YMode'] == NEAR_NEWMV || h['YMode'] == NEW_NEARMV);
    }
    let needs_interp_filter = function () {
      let large = (Math.min(Block_Width[h['MiSize']], Block_Height[h['MiSize']]) >= 8)
      if (h.skip_mode || h.motion_mode == LOCALWARP) {
        return 0;
      } else if (large && h['YMode'] == GLOBALMV) {
        return h[`GmType[${h['RefFrame[0]']}]`] == TRANSLATION;
      } else if (large && h.YMode == GLOBAL_GLOBALMV) {
        return h[`GmType[${h['RefFrame[0]']}]`] == TRANSLATION || h[`GmType[${h['RefFrame[1]']}]`] == TRANSLATION;
      } else {
        return 1;
      }
    }
    h['PaletteSizeY'] = 0;
    h['PaletteSizeUV'] = 0;
    this.read_ref_frames({ b, h });
    let isCompound = Number(h[`RefFrame[1]`] > INTRA_FRAME);
    this.find_mv_stack(isCompound);
    if (h.skip_mode) {
      h['YMode'] = NEAREST_NEARESTMV;
    } else if (this.seg_feature_active({ b, h }, SEG_LVL_SKIP) ||
      this.seg_feature_active({ b, h }, SEG_LVL_GLOBALMV)) {
      h['YMode'] = GLOBALMV;
    } else if (isCompound) {
      h.compound_mode = this.S({ b, h }, { name: "compound_mode" });
      h['YMode'] = NEAREST_NEARESTMV + h.compound_mode;
    } else {
      h.new_mv = this.S({ b, h }, { name: "new_mv" });
      if (h.new_mv == 0) {
        h['YMode'] = NEWMV;
      } else {
        h.zero_mv = this.S({ b, h }, { name: "zero_mv" });
        if (h.zero_mv == 0) {
          h['YMode'] = GLOBALMV;
        } else {
          h.ref_mv = this.S({ b, h }, { name: "ref_mv" });
          h['YMode'] = (h.ref_mv == 0) ? NEARESTMV : NEARMV;
        }
      }
    }
    h['RefMvIdx'] = 0;
    if (h['YMode'] == NEWMV || h['YMode'] == NEW_NEWMV) {
      for (let idx = 0; idx < 2; idx++) {
        if (h['NumMvFound'] > idx + 1) {
          h.drl_mode = this.S({ b, h }, { name: "drl_mode" });
          if (h.drl_mode == 0) {
            h['RefMvIdx'] = idx;
            break;
          }
          h['RefMvIdx'] = idx + 1;
        }
      }
    } else if (has_nearmv()) {
      h['RefMvIdx'] = 1;
      for (let idx = 1; idx < 3; idx++) {
        if (h['NumMvFound'] > idx + 1) {
          h.drl_mode = this.S({ b, h }, { name: "drl_mode" });
          if (h.drl_mode == 0) {
            h['RefMvIdx'] = idx;
            break;
          }
          h['RefMvIdx'] = idx + 1;
        }
      }
    }
    this.assign_mv({ b, h }, isCompound);
    this.read_interintra_mode({ b, h }, isCompound);
    this.read_motion_mode({ b, h }, isCompound);
    this.read_compound_type({ b, h }, isCompound);
    if (h.interpolation_filter == SWITCHABLE) {
      for (let dir = 0; dir < (h.enable_dual_filter ? 2 : 1); dir++) {
        if (needs_interp_filter()) {
          h.interp_filter[dir] = this.S({ b, h }, { name: "interp_filter", dir });
        } else {
          h.interp_filter[dir] = EIGHTTAP;
        }
      }
      if (!h.enable_dual_filter)
        h[`interp_filter[1]`] = h[`interp_filter[0]`];
    } else {
      for (let dir = 0; dir < 2; dir++)
        h[`interp_filter[${dir}]`] = h.interpolation_filter;
    }
  }

  // 5.11.24. Filter intra mode info syntax
  filter_intra_mode_info({ b, h }: { b: BitReader, h: any }) {
    h.use_filter_intra = 0;
    if (this.seq_header.enable_filter_intra &&
      h['YMode'] == DC_PRED && h['PaletteSizeY'] == 0 &&
      Math.max(Block_Width[h['MiSize']], Block_Height[h['MiSize']]) <= 32) {
      h.use_filter_intra = this.S({ b, h }, { name: "use_filter_intra" });
      if (h.use_filter_intra) {
        h.filter_intra_mode = this.S({ b, h }, { name: "filter_intra_mode" });
      }
    }
  }

  // 5.11.25. Ref frames syntax
  read_ref_frames({ b, h }: { b: BitReader, h: any }) {
    if (h.skip_mode) {
      h[`RefFrame[0]`] = h[`SkipModeFrame[0]`];
      h[`RefFrame[1]`] = h[`SkipModeFrame[1]`];
    } else if (this.seg_feature_active({ b, h }, SEG_LVL_REF_FRAME)) {
      h[`RefFrame[0]`] = h[`FeatureData[${h.segment_id}][${SEG_LVL_REF_FRAME}]`];
      h[`RefFrame[1]`] = NONE;
    } else if (this.seg_feature_active({ b, h }, SEG_LVL_SKIP) ||
      this.seg_feature_active({ b, h }, SEG_LVL_GLOBALMV)) {
      h[`RefFrame[0]`] = LAST_FRAME;
      h[`RefFrame[1]`] = NONE;
    } else {
      let bw4 = Num_4x4_Blocks_Wide[h['MiSize']];
      let bh4 = Num_4x4_Blocks_High[h['MiSize']];
      if (h.reference_select && (Math.min(bw4, bh4) >= 2))
        h.comp_mode = this.S({ b, h }, { name: "comp_mode" });
      else
        h.comp_mode = SINGLE_REFERENCE;
      if (h.comp_mode == COMPOUND_REFERENCE) {
        h.comp_ref_type = this.S({ b, h }, { name: "comp_ref_type" });
        if (h.comp_ref_type == UNIDIR_COMP_REFERENCE) {
          h.uni_comp_ref = this.S({ b, h }, { name: "uni_comp_ref" });
          if (h.uni_comp_ref) {
            h[`RefFrame[0]`] = BWDREF_FRAME;
            h[`RefFrame[1]`] = ALTREF_FRAME;
          } else {
            h.uni_comp_ref_p1 = this.S({ b, h }, { name: "uni_comp_ref_p1" });
            if (h.uni_comp_ref_p1) {
              h.uni_comp_ref_p2 = this.S({ b, h }, { name: "uni_comp_ref_p2" });
              if (h.uni_comp_ref_p2) {
                h[`RefFrame[0]`] = LAST_FRAME;
                h[`RefFrame[1]`] = GOLDEN_FRAME;
              } else {
                h[`RefFrame[0]`] = LAST_FRAME;
                h[`RefFrame[1]`] = LAST3_FRAME;
              }
            } else {
              h[`RefFrame[0]`] = LAST_FRAME;
              h[`RefFrame[1]`] = LAST2_FRAME;
            }
          }
        } else {
          h.comp_ref = this.S({ b, h }, { name: "comp_ref" });
          if (h.comp_ref == 0) {
            h.comp_ref_p1 = this.S({ b, h }, { name: "comp_ref_p1" });
            h[`RefFrame[0]`] = h.comp_ref_p1 ?
              LAST2_FRAME : LAST_FRAME;
          } else {
            h.comp_ref_p2 = this.S({ b, h }, { name: "comp_ref_p2" });
            h[`RefFrame[0]`] = h.comp_ref_p2 ?
              GOLDEN_FRAME : LAST3_FRAME;
          }
          h.comp_bwdref = this.S({ b, h }, { name: "comp_bwdref" });
          if (h.comp_bwdref == 0) {
            h.comp_bwdref_p1 = this.S({ b, h }, { name: "comp_bwdref_p1" });
            h[`RefFrame[1]`] = h.comp_bwdref_p1 ?
              ALTREF2_FRAME : BWDREF_FRAME;
          } else {
            h[`RefFrame[1]`] = ALTREF_FRAME;
          }
        }
      } else {
        h.single_ref_p1 = this.S({ b, h }, { name: "single_ref_p1" });
        if (h.single_ref_p1) {
          h.single_ref_p2 = this.S({ b, h }, { name: "single_ref_p2" });
          if (h.single_ref_p2 == 0) {
            h.single_ref_p6 = this.S({ b, h }, { name: "single_ref_p6" });
            h[`RefFrame[0]`] = h.single_ref_p6 ?
              ALTREF2_FRAME : BWDREF_FRAME;
          } else {
            h[`RefFrame[0]`] = ALTREF_FRAME;
          }
        } else {
          h.single_ref_p3 = this.S({ b, h }, { name: "single_ref_p3" });
          if (h.single_ref_p3) {
            h.single_ref_p5 = this.S({ b, h }, { name: "single_ref_p5" });
            h[`RefFrame[0]`] = h.single_ref_p5 ?
              GOLDEN_FRAME : LAST3_FRAME;
          } else {
            h.single_ref_p4 = this.S({ b, h }, { name: "single_ref_p4" });
            h[`RefFrame[0]`] = h.single_ref_p4 ?
              LAST2_FRAME : LAST_FRAME;
          }
        }
        h[`RefFrame[1]`] = NONE;
      }
    }
  }

  // 5.11.26. Assign MV syntax
  assign_mv({ b, h }: { b: BitReader, h: any }, isCompound: number) {
    for (let i = 0; i < 1 + isCompound; i++) {
      let compMode = this.get_mode({ b, h }, i);
      if (h.use_intrabc) {
        compMode = NEWMV
      }
      if (h.use_intrabc) {
        h[`PredMv[0]`] = h[`RefStackMv[0][0]`];
        if (h[`PredMv[0][0]`] == 0 && h[`PredMv[0][1]`] == 0) {
          h[`PredMv[0]`] = h[`RefStackMv[1][0]`];
        }
        if (h[`PredMv[0][0]`] == 0 && h[`PredMv[0][1]`] == 0) {
          let sbSize = h.use_128x128_superblock ? BLOCK_128X128 : BLOCK_64X64;
          let sbSize4 = Num_4x4_Blocks_High[sbSize];
          if (h['MiRow'] - sbSize4 < h['MiRowStart']) {
            h[`PredMv[0][0]`] = 0;
            h[`PredMv[0][1]`] = -(sbSize4 * MI_SIZE + INTRABC_DELAY_PIXELS) * 8;
          } else {
            h[`PredMv[0][0]`] = -(sbSize4 * MI_SIZE * 8);
            h[`PredMv[0][1]`] = 0;
          }
        }
      } else if (compMode == GLOBALMV) {
        h[`PredMv[${i}]`] = h[`GlobalMvs[${i}]`];
      } else {
        let pos = (compMode == NEARESTMV) ? 0 : h['RefMvIdx'];
        if (compMode == NEWMV && h['NumMvFound'] <= 1)
          pos = 0
        h[`PredMv[${i}]`] = h[`RefStackMv[${pos}][${i}]`];
      }
      if (compMode == NEWMV) {
        this.read_mv({ b, h }, i);
      } else {
        h[`Mv[${i}]`] = h[`PredMv[${i}]`];
      }
    }
  }

  // 5.11.27. Read motion mode syntax
  read_motion_mode({ b, h }: { b: BitReader, h: any }, isCompound: number) {
    let is_scaled = function (refFrame: number) {
      let refIdx = h[`ref_frame_idx[${refFrame - LAST_FRAME}]`];
      let xScale = ((h[`RefUpscaledWidth[${refIdx}]`] << REF_SCALE_SHIFT) + (h['FrameWidth'] / 2)) / h['FrameWidth'];
      let yScale = ((h[`RefFrameHeight[${refIdx}]`] << REF_SCALE_SHIFT) + (h['FrameHeight'] / 2)) / h['FrameHeight'];
      let noScale = 1 << REF_SCALE_SHIFT;
      return xScale != noScale || yScale != noScale;
    }

    if (h.skip_mode) {
      h.motion_mode = SIMPLE;
      return;
    }
    if (!h.is_motion_mode_switchable) {
      h.motion_mode = SIMPLE;
      return;
    }
    if (Math.min(Block_Width[h['MiSize']],
      Block_Height[h['MiSize']]) < 8) {
      h.motion_mode = SIMPLE;
      return;
    }
    if (!h.force_integer_mv &&
      (h['YMode'] == GLOBALMV || h['YMode'] == GLOBAL_GLOBALMV)) {
      if (h[`GmType[${h['RefFrame[0]']}]`] > TRANSLATION) {
        h.motion_mode = SIMPLE;
        return;
      }
    }
    if (isCompound || h[`RefFrame[1]`] == INTRA_FRAME || !this.has_overlappable_candidates({ b, h })) {
      h.motion_mode = SIMPLE;
      return;
    }
    this.find_warp_samples();
    if (h.force_integer_mv || h['NumSamples'] == 0 ||
      !h.allow_warped_motion || is_scaled(h[`RefFrame[0]`])) {
      h.use_obmc = this.S({ b, h }, { name: "use_obmc" });
      h.motion_mode = h.use_obmc ? OBMC : SIMPLE;
    } else {
      h.motion_mode = this.S({ b, h }, { name: "motion_mode" });
    }
  }

  // 5.11.28. Read inter intra syntax
  read_interintra_mode({ b, h }: { b: BitReader, h: any }, isCompound: number) {
    if (!h.skip_mode && h.enable_interintra_compound && !isCompound &&
      h['MiSize'] >= BLOCK_8X8 && h['MiSize'] <= BLOCK_32X32) {
      h.interintra = this.S({ b, h }, { name: "interintra" });
      if (h.interintra) {
        h.interintra_mode = this.S({ b, h }, { name: "interintra_mode" });
        h[`RefFrame[1]`] = INTRA_FRAME;
        h['AngleDeltaY'] = 0;
        h['AngleDeltaUV'] = 0;
        h.use_filter_intra = 0;
        h.wedge_interintra = this.S({ b, h }, { name: "wedge_interintra" });
        if (h.wedge_interintra) {
          h.wedge_index = this.S({ b, h }, { name: "wedge_index" });
          h.wedge_sign = 0;
        }
      }
    } else {
      h.interintra = 0;
    }
  }

  // 5.11.29. Read compound type syntax
  read_compound_type({ b, h }: { b: BitReader, h: any }, isCompound: number) {
    h.comp_group_idx = 0;
    h.compound_idx = 1;
    if (h.skip_mode) {
      h.compound_type = COMPOUND_AVERAGE;
      return;
    }
    if (isCompound) {
      let n = Wedge_Bits[h['MiSize']];
      if (h.enable_masked_compound) {
        h.comp_group_idx = this.S({ b, h }, { name: "comp_group_idx" });
      }
      if (h.comp_group_idx == 0) {
        if (h.enable_jnt_comp) {
          h.compound_idx = this.S({ b, h }, { name: "compound_idx" });
          h.compound_type = h.compound_idx ? COMPOUND_AVERAGE :
            COMPOUND_DISTANCE;
        } else {
          h.compound_type = COMPOUND_AVERAGE;
        }
      } else {
        if (n == 0) {
          h.compound_type = COMPOUND_DIFFWTD
        } else {
          h.compound_type = this.S({ b, h }, { name: "compound_type" });
        }
      }
      if (h.compound_type == COMPOUND_WEDGE) {
        h.wedge_index = this.S({ b, h }, { name: "wedge_index" });
        h.wedge_sign = this.L({ b, h }, 1);
      } else if (h.compound_type == COMPOUND_DIFFWTD) {
        h.mask_type = this.L({ b, h }, 1);
      }
    } else {
      if (h.interintra) {
        h.compound_type = h.wedge_interintra ? COMPOUND_WEDGE : COMPOUND_INTRA;
      } else {
        h.compound_type = COMPOUND_AVERAGE;
      }
    }
  }

  // 5.11.30. Get mode function
  get_mode({ b, h }: { b: BitReader, h: any }, refList: number) {
    let compMode = GLOBALMV;
    if (refList == 0) {
      if (h['YMode'] < NEAREST_NEARESTMV)
        compMode = h['YMode'];
      else if (h['YMode'] == NEW_NEWMV || h['YMode'] == NEW_NEARESTMV || h['YMode'] == NEW_NEARMV)
        compMode = NEWMV;
      else if (h['YMode'] == NEAREST_NEARESTMV || h['YMode'] == NEAREST_NEWMV)
        compMode = NEARESTMV;
      else if (h['YMode'] == NEAR_NEARMV || h['YMode'] == NEAR_NEWMV)
        compMode = NEARMV;
      else
        compMode = GLOBALMV;
    } else {
      if (h['YMode'] == NEW_NEWMV || h['YMode'] == NEAREST_NEWMV || h['YMode'] == NEAR_NEWMV)
        compMode = NEWMV;
      else if (h['YMode'] == NEAREST_NEARESTMV || h['YMode'] == NEW_NEARESTMV)
        compMode = NEARESTMV;
      else if (h['YMode'] == NEAR_NEARMV || h['YMode'] == NEW_NEARMV)
        compMode = NEARMV;
      else
        compMode = GLOBALMV;
    }
    return compMode
  }

  // 5.11.31. MV syntax
  read_mv({ b, h }: { b: BitReader, h: any }, ref: number) {
    let diffMv = [0, 0];
    if (h.use_intrabc) {
      h['MvCtx'] = MV_INTRABC_CONTEXT;
    } else {
      h['MvCtx'] = 0;
    }
    h.mv_joint = this.S({ b, h }, { name: "mv_joint" });
    if (h.mv_joint == MV_JOINT_HZVNZ || h.mv_joint == MV_JOINT_HNZVNZ)
      diffMv[0] = this.read_mv_component({ b, h }, 0);
    if (h.mv_joint == MV_JOINT_HNZVZ || h.mv_joint == MV_JOINT_HNZVNZ)
      diffMv[1] = this.read_mv_component({ b, h }, 1);
    h[`Mv[${ref}][0]`] = h[`PredMv[${ref}][0]`] + diffMv[0];
    h[`Mv[${ref}][1]`] = h[`PredMv[${ref}][1]`] + diffMv[1]
  }

  // 5.11.32. MV component syntax
  read_mv_component({ b, h }: { b: BitReader, h: any }, comp: number) {
    h.mv_sign = this.S({ b, h }, { name: "mv_sign" });
    h.mv_class = this.S({ b, h }, { name: "mv_class" });
    let mag = 0;
    if (h.mv_class == MV_CLASS_0) {
      h.mv_class0_bit = this.S({ b, h }, { name: "mv_class0_bit" });
      if (h.force_integer_mv)
        h.mv_class0_fr = 3;
      else
        h.mv_class0_fr = this.S({ b, h }, { name: "mv_class0_fr" });
      if (h.allow_high_precision_mv)
        h.mv_class0_hp = this.S({ b, h }, { name: "mv_class0_hp" });
      else
        h.mv_class0_hp = 1;
      mag = ((h.mv_class0_bit << 3) |
        (h.mv_class0_fr << 1) |
        h.mv_class0_hp) + 1
    } else {
      let d = 0;
      for (let i = 0; i < h.mv_class; i++) {
        h.mv_bit = this.S({ b, h }, { name: "mv_bit" });
        d |= h.mv_bit << i;
      }
      mag = CLASS0_SIZE << (h.mv_class + 2)
      if (h.force_integer_mv)
        h.mv_fr = 3;
      else
        h.mv_fr = this.S({ b, h }, { name: "mv_fr" });
      if (h.allow_high_precision_mv)
        h.mv_hp = this.S({ b, h }, { name: "mv_hp" });
      else
        h.mv_hp = 1;
      mag += ((d << 3) | (h.mv_fr << 1) | h.mv_hp) + 1;
    }
    return h.mv_sign ? -mag : mag;
  }

  // 5.11.33. Compute prediction syntax
  compute_prediction({ b, h }: { b: BitReader, h: any }) {
    let sbMask = h.use_128x128_superblock ? 31 : 15;
    let subBlockMiRow = h['MiRow'] & sbMask;
    let subBlockMiCol = h['MiCol'] & sbMask;
    for (let plane = 0; plane < 1 + h['HasChroma'] * 2; plane++) {
      let planeSz = this.get_plane_residual_size({ b, h }, h['MiSize'], plane);
      let num4x4W = Num_4x4_Blocks_Wide[planeSz];
      let num4x4H = Num_4x4_Blocks_High[planeSz];
      let log2W = MI_SIZE_LOG2 + Mi_Width_Log2[planeSz]
      let log2H = MI_SIZE_LOG2 + Mi_Height_Log2[planeSz]
      let subX = (plane > 0) ? this.seq_header.subsampling_x : 0
      let subY = (plane > 0) ? this.seq_header.subsampling_y : 0
      let baseX = (h['MiCol'] >> subX) * MI_SIZE
      let baseY = (h['MiRow'] >> subY) * MI_SIZE
      let candRow = (h.MiRow >> subY) << subY
      let candCol = (h.MiCol >> subX) << subX
      h.IsInterIntra = (h.is_inter && h[`RefFrame[1]`] == INTRA_FRAME)
      if (h.IsInterIntra) {
        if (h.interintra_mode == II_DC_PRED) h.mode = DC_PRED
        else if (h.interintra_mode == II_V_PRED) h.mode = V_PRED
        else if (h.interintra_mode == II_H_PRED) h.mode = H_PRED
        else h.mode = SMOOTH_PRED
        this.predict_intra(plane, baseX, baseY,
          plane == 0 ? h.AvailL : h.AvailLChroma,
          plane == 0 ? h.AvailU : h.AvailUChroma,
          h[`BlockDecoded[${plane}][${(subBlockMiRow >> subY) - 1}][${(subBlockMiCol >> subX) + num4x4W}]`],
          h[`BlockDecoded[${plane}][${(subBlockMiRow >> subY) + num4x4H}][${(subBlockMiCol >> subX) - 1}]`],
          h.mode,
          log2W, log2H)
      }
      if (h.is_inter) {
        let predW = Block_Width[h.MiSize] >> subX;
        let predH = Block_Height[h.MiSize] >> subY;
        let someUseIntra = 0;
        let r = 0;
        let c = 0;
        for (r = 0; r < (num4x4H << subY); r++)
          for (c = 0; c < (num4x4W << subX); c++)
            if (h[`RefFrames[${candRow + r}][${candCol + c}][0]`] == INTRA_FRAME)
              someUseIntra = 1;
        if (someUseIntra) {
          predW = num4x4W * 4;
          predH = num4x4H * 4;
          candRow = h.MiRow;
          candCol = h.MiCol;
        }
        r = 0
        for (let y = 0; y < num4x4H * 4; y += predH) {
          c = 0
          for (let x = 0; x < num4x4W * 4; x += predW) {
            this.predict_inter(plane, baseX + x, baseY + y,
              predW, predH,
              candRow + r, candCol + c)
            c++
          }
          r++
        }
      }
    }
  }

  // 5.11.34. Residual syntax
  residual({ b, h }: { b: BitReader, h: any }) {
    let sbMask = h.use_128x128_superblock ? 31 : 15;
    let widthChunks = Math.max(1, Block_Width[h.MiSize] >> 6);
    let heightChunks = Math.max(1, Block_Height[h.MiSize] >> 6);
    let miSizeChunk = (widthChunks > 1 || heightChunks > 1) ? BLOCK_64X64 : h.MiSize;
    for (let chunkY = 0; chunkY < heightChunks; chunkY++) {
      for (let chunkX = 0; chunkX < widthChunks; chunkX++) {
        let miRowChunk = h.MiRow + (chunkY << 4);
        let miColChunk = h.MiCol + (chunkX << 4);
        let subBlockMiRow = miRowChunk & sbMask;
        let subBlockMiCol = miColChunk & sbMask;
        for (let plane = 0; plane < 1 + h.HasChroma * 2; plane++) {
          let txSz = h.Lossless ? TX_4X4 : this.get_tx_size({ b, h }, plane, h.TxSize);
          let stepX = Tx_Width[txSz] >> 2;
          let stepY = Tx_Height[txSz] >> 2;
          let planeSz = this.get_plane_residual_size({ b, h }, miSizeChunk, plane);
          let num4x4W = Num_4x4_Blocks_Wide[planeSz];
          let num4x4H = Num_4x4_Blocks_High[planeSz];
          let subX = (plane > 0) ? this.seq_header.subsampling_x : 0;
          let subY = (plane > 0) ? this.seq_header.subsampling_y : 0;
          let baseX = (miColChunk >> subX) * MI_SIZE;
          let baseY = (miRowChunk >> subY) * MI_SIZE;
          if (h.is_inter && !h.Lossless && !plane) {
            this.transform_tree({ b, h }, baseX, baseY, num4x4W * 4, num4x4H * 4);
          } else {
            let baseXBlock = (h.MiCol >> subX) * MI_SIZE;
            let baseYBlock = (h.MiRow >> subY) * MI_SIZE;
            for (let y = 0; y < num4x4H; y += stepY)
              for (let x = 0; x < num4x4W; x += stepX)
                this.transform_block({ b, h }, plane, baseXBlock, baseYBlock, txSz,
                  x + ((chunkX << 4) >>> subX),
                  y + ((chunkY << 4) >>> subY));
          }
        }
      }
    }
  }

  // 5.11.35. Transform block syntax
  transform_block({ b, h }: { b: BitReader, h: any }, plane: number, baseX: number, baseY: number, txSz: number, x: number, y: number) {
    let startX = baseX + 4 * x;
    let startY = baseY + 4 * y;
    let subX = (plane > 0) ? this.seq_header.subsampling_x : 0;
    let subY = (plane > 0) ? this.seq_header.subsampling_y : 0;
    let row = (startY << subY) >> MI_SIZE_LOG2;
    let col = (startX << subX) >> MI_SIZE_LOG2;
    let sbMask = h.use_128x128_superblock ? 31 : 15;
    let subBlockMiRow = row & sbMask;
    let subBlockMiCol = col & sbMask;
    let stepX = Tx_Width[txSz] >> MI_SIZE_LOG2;
    let stepY = Tx_Height[txSz] >> MI_SIZE_LOG2;
    let maxX = (h.MiCols * MI_SIZE) >> subX;
    let maxY = (h.MiRows * MI_SIZE) >> subY;
    if (startX >= maxX || startY >= maxY) {
      return;
    }
    if (!h.is_inter) {
      if (((plane == 0) && h.PaletteSizeY) ||
        ((plane != 0) && h.PaletteSizeUV)) {
        this.predict_palette(plane, startX, startY, x, y, txSz);
      } else {
        let isCfl = (plane > 0 && h.UVMode == UV_CFL_PRED);
        if (plane == 0) {
          h.mode = h.YMode;
        } else {
          h.mode = (isCfl) ? DC_PRED : h.UVMode;
        }
        let log2W = Tx_Width_Log2[txSz];
        let log2H = Tx_Height_Log2[txSz];
        this.predict_intra(plane, startX, startY,
          (plane == 0 ? h.AvailL : h.AvailLChroma) || x > 0,
          (plane == 0 ? h.AvailU : h.AvailUChroma) || y > 0,
          h[`BlockDecoded[${plane}][${(subBlockMiRow >> subY) - 1}][${(subBlockMiCol >> subX) + stepX}]`],
          h[`BlockDecoded[${plane}][${(subBlockMiRow >> subY) + stepY}][${(subBlockMiCol >> subX) - 1}]`],
          h.mode,
          log2W, log2H);
        if (isCfl) {
          this.predict_chroma_from_luma(plane, startX, startY, txSz);
        }
      }
      if (plane == 0) {
        h.MaxLumaW = startX + stepX * 4;
        h.MaxLumaH = startY + stepY * 4;
      }
    }
    if (!h.skip) {
      let eob = this.coeffs({ b, h }, plane, startX, startY, txSz);
      if (eob > 0)
        this.reconstruct(plane, startX, startY, txSz);
    }
    for (let i = 0; i < stepY; i++) {
      for (let j = 0; j < stepX; j++) {
        h[`LoopfilterTxSizes[${plane}][${(row >> subY) + i}][${(col >> subX) + j}]`] = txSz;
        h[`BlockDecoded[${plane}][${(subBlockMiRow >> subY) + i}][${(subBlockMiCol >> subX) + j}]`] = 1;
      }
    }
  }

  // 5.11.36. Transform tree syntax
  transform_tree({ b, h }: { b: BitReader, h: any }, startX: number, startY: number, width: number, height: number) {

    let maxX = h.MiCols * MI_SIZE;
    let maxY = h.MiRows * MI_SIZE;
    if (startX >= maxX || startY >= maxY) {
      return;
    }
    let row = startY >> MI_SIZE_LOG2;
    let col = startX >> MI_SIZE_LOG2;
    let lumaTxSz = h[`InterTxSizes[${row}][${col}]`];
    let lumaW = Tx_Width[lumaTxSz];
    let lumaH = Tx_Height[lumaTxSz];
    if (width <= lumaW && height <= lumaH) {
      let txSz = this.find_tx_size(width, height);
      this.transform_block({ b, h }, 0, startX, startY, txSz, 0, 0);
    } else {
      if (width > height) {
        this.transform_tree({ b, h }, startX, startY, width / 2, height)
        this.transform_tree({ b, h }, startX + width / 2, startY, width / 2, height)
      } else if (width < height) {
        this.transform_tree({ b, h }, startX, startY, width, height / 2)
        this.transform_tree({ b, h }, startX, startY + height / 2, width, height / 2)
      } else {
        this.transform_tree({ b, h }, startX, startY, width / 2, height / 2)
        this.transform_tree({ b, h }, startX + width / 2, startY, width / 2, height / 2)
        this.transform_tree({ b, h }, startX, startY + height / 2, width / 2, height / 2)
        this.transform_tree({ b, h }, startX + width / 2, startY + height / 2, width / 2, height / 2)
      }
    }
  }
  find_tx_size(w: number, h: number) {
    let txSz = 0;
    for (txSz = 0; txSz < TX_SIZES_ALL; txSz++)
      if (Tx_Width[txSz] == w && Tx_Height[txSz] == h)
        break;
    return txSz;
  }

  // 5.11.37. Get TX size function
  get_tx_size({ b, h }: { b: BitReader, h: any }, plane: number, txSz: number) {
    if (plane == 0)
      return txSz;
    let uvTx = Max_Tx_Size_Rect[this.get_plane_residual_size({ b, h }, h.MiSize, plane)];
    if (Tx_Width[uvTx] == 64 || Tx_Height[uvTx] == 64) {
      if (Tx_Width[uvTx] == 16) {
        return TX_16X32;
      }
      if (Tx_Height[uvTx] == 16) {
        return TX_32X16;
      }
      return TX_32X32;
    }
    return uvTx;
  }

  // 5.11.38. Get plane residual size function
  get_plane_residual_size({ b, h }: { b: BitReader, h: any }, subsize: number, plane: number) {
    const Subsampled_Size = [
      [[BLOCK_4X4, BLOCK_4X4], [BLOCK_4X4, BLOCK_4X4]],
      [[BLOCK_4X8, BLOCK_4X4], [BLOCK_INVALID, BLOCK_4X4]],
      [[BLOCK_8X4, BLOCK_INVALID], [BLOCK_4X4, BLOCK_4X4]],
      [[BLOCK_8X8, BLOCK_8X4], [BLOCK_4X8, BLOCK_4X4]],
      [[BLOCK_8X16, BLOCK_8X8], [BLOCK_INVALID, BLOCK_4X8]],
      [[BLOCK_16X8, BLOCK_INVALID], [BLOCK_8X8, BLOCK_8X4]],
      [[BLOCK_16X16, BLOCK_16X8], [BLOCK_8X16, BLOCK_8X8]],
      [[BLOCK_16X32, BLOCK_16X16], [BLOCK_INVALID, BLOCK_8X16]],
      [[BLOCK_32X16, BLOCK_INVALID], [BLOCK_16X16, BLOCK_16X8]],
      [[BLOCK_32X32, BLOCK_32X16], [BLOCK_16X32, BLOCK_16X16]],
      [[BLOCK_32X64, BLOCK_32X32], [BLOCK_INVALID, BLOCK_16X32]],
      [[BLOCK_64X32, BLOCK_INVALID], [BLOCK_32X32, BLOCK_32X16]],
      [[BLOCK_64X64, BLOCK_64X32], [BLOCK_32X64, BLOCK_32X32]],
      [[BLOCK_64X128, BLOCK_64X64], [BLOCK_INVALID, BLOCK_32X64]],
      [[BLOCK_128X64, BLOCK_INVALID], [BLOCK_64X64, BLOCK_64X32]],
      [[BLOCK_128X128, BLOCK_128X64], [BLOCK_64X128, BLOCK_64X64]],
      [[BLOCK_4X16, BLOCK_4X8], [BLOCK_INVALID, BLOCK_4X8]],
      [[BLOCK_16X4, BLOCK_INVALID], [BLOCK_8X4, BLOCK_8X4]],
      [[BLOCK_8X32, BLOCK_8X16], [BLOCK_INVALID, BLOCK_4X16]],
      [[BLOCK_32X8, BLOCK_INVALID], [BLOCK_16X8, BLOCK_16X4]],
      [[BLOCK_16X64, BLOCK_16X32], [BLOCK_INVALID, BLOCK_8X32]],
      [[BLOCK_64X16, BLOCK_INVALID], [BLOCK_32X16, BLOCK_32X8]],
    ];
    let subx = plane > 0 ? this.seq_header.subsampling_x : 0;
    let suby = plane > 0 ? this.seq_header.subsampling_y : 0;
    return Subsampled_Size[subsize][subx][suby]
  }

  // 5.11.39. Coefficients syntax
  coeffs({ b, h }: { b: BitReader, h: any }, plane: number, startX: number, startY: number, txSz: number) {
    let x4 = startX >> 2;
    let y4 = startY >> 2;
    let w4 = Tx_Width[txSz] >> 2;
    let h4 = Tx_Height[txSz] >> 2;
    let txSzCtx = (Tx_Size_Sqr[txSz] + Tx_Size_Sqr_Up[txSz] + 1) >> 1;
    let ptype = Number(plane > 0);
    let segEob = (txSz == TX_16X64 || txSz == TX_64X16) ? 512 :
      Math.min(1024, Tx_Width[txSz] * Tx_Height[txSz]);
    for (let c = 0; c < segEob; c++)
      h[`Quant[${c}]`] = 0;
    for (let i = 0; i < 64; i++)
      for (let j = 0; j < 64; j++)
        h[`Dequant[${i}][${j}]`] = 0;
    let eob = 0;
    let culLevel = 0;
    let dcCategory = 0;
    h.all_zero = this.S({ b, h }, { name: "all_zero", txSzCtx, plane, txSz, x4, y4, w4, h4 });
    if (h.all_zero) {
      let c = 0;
      if (plane == 0) {
        for (let i = 0; i < w4; i++) {
          for (let j = 0; j < h4; j++) {
            h[`TxTypes[${y4 + j}][${x4 + i}]`] = DCT_DCT;
          }
        }
      }
    } else {
      if (plane == 0)
        this.transform_type({ b, h }, x4, y4, txSz);
      h.PlaneTxType = this.compute_tx_type({ b, h }, plane, txSz, x4, y4);
      let scan = this.get_scan({ b, h }, txSz);
      let eobMultisize = Math.min(Tx_Width_Log2[txSz], 5) + Math.min(Tx_Height_Log2[txSz], 5) - 4;
      let eobPt = 0;
      if (eobMultisize == 0) {
        h.eob_pt_16 = this.S({ b, h }, { name: "eob_pt_16", plane, txSz, x4, y4, ptype });
        eobPt = h.eob_pt_16 + 1;
      } else if (eobMultisize == 1) {
        h.eob_pt_32 = this.S({ b, h }, { name: "eob_pt_32", plane, txSz, x4, y4, ptype });
        eobPt = h.eob_pt_32 + 1;
      } else if (eobMultisize == 2) {
        h.eob_pt_64 = this.S({ b, h }, { name: "eob_pt_64", plane, txSz, x4, y4, ptype });
        eobPt = h.eob_pt_64 + 1;
      } else if (eobMultisize == 3) {
        h.eob_pt_128 = this.S({ b, h }, { name: "eob_pt_128", plane, txSz, x4, y4, ptype });
        eobPt = h.eob_pt_128 + 1;
      } else if (eobMultisize == 4) {
        h.eob_pt_256 = this.S({ b, h }, { name: "eob_pt_256", plane, txSz, x4, y4, ptype });
        eobPt = h.eob_pt_256 + 1;
      } else if (eobMultisize == 5) {
        h.eob_pt_512 = this.S({ b, h }, { name: "eob_pt_512", plane, txSz, x4, y4, ptype });
        eobPt = h.eob_pt_512 + 1;
      } else {
        h.eob_pt_1024 = this.S({ b, h }, { name: "eob_pt_1024", plane, txSz, x4, y4, ptype });
        eobPt = h.eob_pt_1024 + 1;
      }
      eob = (eobPt < 2) ? eobPt : ((1 << (eobPt - 2)) + 1);
      let eobShift = Math.max(-1, eobPt - 3);
      if (eobShift >= 0) {
        h.eob_extra = this.S({ b, h }, { name: "eob_extra", txSzCtx, ptype, eobPt });
        if (h.eob_extra) {
          eob += (1 << eobShift);
        }
        for (let i = 1; i < Math.max(0, eobPt - 2); i++) {
          eobShift = Math.max(0, eobPt - 2) - 1 - i;
          h.eob_extra_bit = this.L({ b, h }, 1);
          if (h.eob_extra_bit) {
            eob += (1 << eobShift);
          }
        }
      }
      for (let c = eob - 1; c >= 0; c--) {
        let pos = scan[c];
        let level = 0;
        if (c == (eob - 1)) {
          h.coeff_base_eob = this.S({ b, h }, { name: "coeff_base_eob", txSz, plane, x4, y4, c, scan, txSzCtx, ptype });
          level = h.coeff_base_eob + 1;
        } else {
          h.coeff_base = this.S({ b, h }, { name: "coeff_base", txSz, plane, x4, y4, c, scan, txSzCtx, ptype });
          level = h.coeff_base;
        }
        if (level > NUM_BASE_LEVELS) {
          for (let idx = 0;
            idx < COEFF_BASE_RANGE / (BR_CDF_SIZE - 1);
            idx++) {
            h.coeff_br = this.S({ b, h }, { name: "coeff_br", txSz, pos, plane, x4, y4, txSzCtx, ptype });
            level += h.coeff_br;
            if (h.coeff_br < (BR_CDF_SIZE - 1))
              break;
          }
        }
        h[`Quant[${pos}]`] = level;
      }
      for (let c = 0; c < eob; c++) {
        let pos = scan[c]
        let sign = 0;
        if (h[`Quant[${pos}]`] != 0) {
          if (c == 0) {
            h.dc_sign = this.S({ b, h }, { name: "dc_sign", plane, w4, h4, x4, y4, ptype });
            sign = h.dc_sign;
          } else {
            h.sign_bit = this.L({ b, h }, 1);
            sign = h.sign_bit;
          }
        }
        if (h[`Quant[${pos}]`] >
          (NUM_BASE_LEVELS + COEFF_BASE_RANGE)) {
          let length = 0
          do {
            length++
            h.golomb_length_bit = this.L({ b, h }, 1);
          } while (!h.golomb_length_bit);
          let x = 1;
          for (let i = length - 2; i >= 0; i--) {
            h.golomb_data_bit = this.L({ b, h }, 1);
            x = (x << 1) | h.golomb_data_bit;
          }
          h[`Quant[${pos}]`] = x + COEFF_BASE_RANGE + NUM_BASE_LEVELS;
        }
        if (pos == 0 && h[`Quant[${pos}]`] > 0) {
          dcCategory = sign ? 1 : 2;
        }
        h[`Quant[${pos}]`] = h[`Quant[${pos}]`] & 0xFFFFF;
        culLevel += h[`Quant[${pos}]`];
        if (sign)
          h[`Quant[${pos}]`] = - h[`Quant[${pos}]`];
      }
      culLevel = Math.min(63, culLevel);
    }
    for (let i = 0; i < w4; i++) {
      h[`AboveLevelContext[${plane}][${x4 + i}]`] = culLevel;
      h[`AboveDcContext[${plane}][${x4 + i}]`] = dcCategory;
    }
    for (let i = 0; i < h4; i++) {
      h[`LeftLevelContext[${plane}][${y4 + i}]`] = culLevel;
      h[`LeftDcContext[${plane}][${y4 + i}]`] = dcCategory;
    }
    return eob;
  }

  // 5.11.40. Compute transform type function
  compute_tx_type({ b, h }: { b: BitReader, h: any }, plane: number, txSz: number, blockX: number, blockY: number) {
    let txSzSqrUp = Tx_Size_Sqr_Up[txSz];
    if (h.Lossless || txSzSqrUp > TX_32X32)
      return DCT_DCT;
    let txSet = this.get_tx_set({ b, h }, txSz);
    if (plane == 0) {
      return h[`TxTypes[${blockY}][${blockX}]`];
    }
    if (h.is_inter) {
      let x4 = Math.max(h.MiCol, blockX << this.seq_header.subsampling_x);
      let y4 = Math.max(h.MiRow, blockY << this.seq_header.subsampling_y);
      let txType = h[`TxTypes[${y4}][${x4}]`];
      if (!this.is_tx_type_in_set({ b, h }, txSet, txType))
        return DCT_DCT;
      return txType;
    }
    let txType = Mode_To_Txfm[h.UVMode]
    if (!this.is_tx_type_in_set({ b, h }, txSet, txType))
      return DCT_DCT;
    return txType;
  }

  is_tx_type_in_set({ b, h }: { b: BitReader, h: any }, txSet: number, txType: number) {
    const Tx_Type_In_Set_Intra = [
      [
        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      ],
      [
        1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0,
      ],
      [
        1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,
      ]
    ];
    const Tx_Type_In_Set_Inter = [
      [
        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      ],
      [
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
      ],
      [
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0,
      ],
      [
        1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,
      ]
    ];
    return h.is_inter ? Tx_Type_In_Set_Inter[txSet][txType] :
      Tx_Type_In_Set_Intra[txSet][txType];
  }

  // 5.11.41. Get scan function
  get_mrow_scan(txSz: number) {
    if (txSz == TX_4X4)
      return Mrow_Scan_4x4;
    else if (txSz == TX_4X8)
      return Mrow_Scan_4x8;
    else if (txSz == TX_8X4)
      return Mrow_Scan_8x4;
    else if (txSz == TX_8X8)
      return Mrow_Scan_8x8;
    else if (txSz == TX_8X16)
      return Mrow_Scan_8x16;
    else if (txSz == TX_16X8)
      return Mrow_Scan_16x8;
    else if (txSz == TX_16X16)
      return Mrow_Scan_16x16;
    else if (txSz == TX_4X16)
      return Mrow_Scan_4x16;
    return Mrow_Scan_16x4;
  }

  get_mcol_scan(txSz: number) {
    if (txSz == TX_4X4)
      return Mcol_Scan_4x4;
    else if (txSz == TX_4X8)
      return Mcol_Scan_4x8;
    else if (txSz == TX_8X4)
      return Mcol_Scan_8x4;
    else if (txSz == TX_8X8)
      return Mcol_Scan_8x8;
    else if (txSz == TX_8X16)
      return Mcol_Scan_8x16;
    else if (txSz == TX_16X8)
      return Mcol_Scan_16x8;
    else if (txSz == TX_16X16)
      return Mcol_Scan_16x16;
    else if (txSz == TX_4X16)
      return Mcol_Scan_4x16;
    return Mcol_Scan_16x4;
  }

  get_default_scan(txSz: number) {
    if (txSz == TX_4X4)
      return Default_Scan_4x4;
    else if (txSz == TX_4X8)
      return Default_Scan_4x8;
    else if (txSz == TX_8X4)
      return Default_Scan_8x4;
    else if (txSz == TX_8X8)
      return Default_Scan_8x8;
    else if (txSz == TX_8X16)
      return Default_Scan_8x16;
    else if (txSz == TX_16X8)
      return Default_Scan_16x8;
    else if (txSz == TX_16X16)
      return Default_Scan_16x16;
    else if (txSz == TX_16X32)
      return Default_Scan_16x32;
    else if (txSz == TX_32X16)
      return Default_Scan_32x16;
    else if (txSz == TX_4X16)
      return Default_Scan_4x16;
    else if (txSz == TX_16X4)
      return Default_Scan_16x4;
    else if (txSz == TX_8X32)
      return Default_Scan_8x32;
    else if (txSz == TX_32X8)
      return Default_Scan_32x8;
    return Default_Scan_32x32;
  }

  get_scan({ b, h }: { b: BitReader, h: any }, txSz: number) {
    if (txSz == TX_16X64) {
      return Default_Scan_16x32;
    }
    if (txSz == TX_64X16) {
      return Default_Scan_32x16;
    }
    if (Tx_Size_Sqr_Up[txSz] == TX_64X64) {
      return Default_Scan_32x32;
    }
    if (h.PlaneTxType == IDTX) {
      return this.get_default_scan(txSz);
    }
    let preferRow = (h.PlaneTxType == V_DCT ||
      h.PlaneTxType == V_ADST ||
      h.PlaneTxType == V_FLIPADST)
    let preferCol = (h.PlaneTxType == H_DCT ||
      h.PlaneTxType == H_ADST ||
      h.PlaneTxType == H_FLIPADST)
    if (preferRow) {
      return this.get_mrow_scan(txSz);
    } else if (preferCol) {
      return this.get_mcol_scan(txSz);
    }
    return this.get_default_scan(txSz);
  }

  // 5.11.42. Intra angle info luma syntax
  intra_angle_info_y({ b, h }: { b: BitReader, h: any }) {
    h.AngleDeltaY = 0;
    if (h.MiSize >= BLOCK_8X8) {
      if (this.is_directional_mode(h.YMode)) {
        h.angle_delta_y = this.S({ b, h }, { name: "angle_delta_y" });
        h.AngleDeltaY = h.angle_delta_y - MAX_ANGLE_DELTA;
      }
    }
  }

  // 5.11.43. Intra angle info chroma syntax
  intra_angle_info_uv({ b, h }: { b: BitReader, h: any }) {
    h.AngleDeltaUV = 0;
    if (h.MiSize >= BLOCK_8X8) {
      if (this.is_directional_mode(h.UVMode)) {
        h.angle_delta_uv = this.S({ b, h }, { name: "angle_delta_uv" });
        h.AngleDeltaUV = h.angle_delta_uv - MAX_ANGLE_DELTA;
      }
    }
  }

  // 5.11.44. Is directional mode function
  is_directional_mode(mode: number) {
    if ((mode >= V_PRED) && (mode <= D67_PRED)) {
      return 1;
    }
    return 0;
  }

  // 5.11.45. Read CFL alphas syntax
  read_cfl_alphas({ b, h }: { b: BitReader, h: any }) {
    /** +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     *  | cfl_alpha_signs | Name of signU | Name of signV |
     *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     *  |        0        | CFL_SIGN_ZERO | CFL_SIGN_NEG  |
     *  |        1        | CFL_SIGN_ZERO | CFL_SIGN_POS  |
     *  |        2        | CFL_SIGN_NEG  | CFL_SIGN_ZERO |
     *  |        3        | CFL_SIGN_NEG  | CFL_SIGN_NEG  |
     *  |        4        | CFL_SIGN_NEG  | CFL_SIGN_POS  |
     *  |        5        | CFL_SIGN_POS  | CFL_SIGN_ZERO |
     *  |        6        | CFL_SIGN_POS  | CFL_SIGN_NEG  |
     *  |        7        | CFL_SIGN_POS  | CFL_SIGN_POS  |
     *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     */
    h.cfl_alpha_signs = this.S({ b, h }, { name: "cfl_alpha_signs" });
    /** +-+-+-+-+-+-+-+-+-+-+-+-+
     *  | signU | Name of signU |
     *  +-+-+-+-+-+-+-+-+-+-+-+-+
     *  |   0   | CFL_SIGN_ZERO |
     *  |   1   | CFL_SIGN_NEG  |
     *  |   2   | CFL_SIGN_POS  |
     *  +-+-+-+-+-+-+-+-+-+-+-+-+
     */
    let signU = Math.floor((h.cfl_alpha_signs + 1) / 3);
    let signV = (h.cfl_alpha_signs + 1) % 3;
    if (signU != CFL_SIGN_ZERO) { // signU != CFL_SIGN_ZERO
      h.cfl_alpha_u = this.S({ b, h }, { name: "cfl_alpha_u", signU, signV });
      h.CflAlphaU = 1 + h.cfl_alpha_u;
      if (signU == CFL_SIGN_NEG)
        h.CflAlphaU = -h.CflAlphaU;
    } else {
      h.CflAlphaU = 0;
    }
    if (signV != CFL_SIGN_ZERO) {
      h.cfl_alpha_v = this.S({ b, h }, { name: "cfl_alpha_v", signU, signV });
      h.CflAlphaV = 1 + h.cfl_alpha_v;
      if (signV == CFL_SIGN_NEG)
        h.CflAlphaV = -h.CflAlphaV;
    } else {
      h.CflAlphaV = 0;
    }
  }

  // 5.11.46. Palette mode info syntax
  palette_mode_info({ b, h }: { b: BitReader, h: any }) {
    let bsizeCtx = Mi_Width_Log2[h.MiSize] + Mi_Height_Log2[h.MiSize] - 2;
    if (h.YMode == DC_PRED) {
      h.has_palette_y = this.S({ b, h }, { name: "has_palette_y" });
      if (h.has_palette_y) {
        h.palette_size_y_minus_2 = this.S({ b, h }, { name: "palette_size_y_minus_2" });
        h.PaletteSizeY = h.palette_size_y_minus_2 + 2;
        let cacheN = this.get_palette_cache({ b, h }, 0);
        let idx = 0;
        for (let i = 0; i < cacheN && idx < h.PaletteSizeY; i++) {
          h.use_palette_color_cache_y = this.L({ b, h }, 1);
          if (h.use_palette_color_cache_y) {
            h[`palette_colors_y[${idx}]`] = h[`PaletteCache[${i}]`];
            idx++;
          }
        }
        if (idx < h.PaletteSizeY) {
          h[`palette_colors_y[${idx}]`] = this.L({ b, h }, h.BitDepth);
          idx++;
        }
        let paletteBits = 0;
        if (idx < h.PaletteSizeY) {
          let minBits = h.BitDepth - 3;
          h.palette_num_extra_bits_y = this.L({ b, h }, 2);
          paletteBits = minBits + h.palette_num_extra_bits_y;
        }
        while (idx < h.PaletteSizeY) {
          h.palette_delta_y = this.L({ b, h }, paletteBits);
          h.palette_delta_y++;
          h[`palette_colors_y[${idx}]`] =
            this.Clip1(h[`palette_colors_y[${idx - 1}]`] +
              h.palette_delta_y);
          let range = (1 << h.BitDepth) - h[`palette_colors_y[${idx}]`] - 1;
          paletteBits = Math.min(paletteBits, CeilLog2(range));
          idx++;
        }
        this.sort(h.palette_colors_y, 0, h.PaletteSizeY - 1);
      }
    }
    if (h.HasChroma && h.UVMode == DC_PRED) {
      h.has_palette_uv = this.S({ b, h }, { name: "has_palette_uv" });
      if (h.has_palette_uv) {
        h.palette_size_uv_minus_2 = this.S({ b, h }, { name: "palette_size_uv_minus_2" });
        h.PaletteSizeUV = h.palette_size_uv_minus_2 + 2;
        let cacheN = this.get_palette_cache({ b, h }, 1);
        let idx = 0
        for (let i = 0; i < cacheN && idx < h.PaletteSizeUV; i++) {
          h.use_palette_color_cache_u = this.L({ b, h }, 1);
          if (h.use_palette_color_cache_u) {
            h[`palette_colors_u[${idx}]`] = h[`PaletteCache[${i}]`];
            idx++;
          }
        }
        if (idx < h.PaletteSizeUV) {
          h[`palette_colors_u[${idx}]`] = this.L({ b, h }, h.BitDepth);
          idx++;
        }
        let paletteBits = 0;
        if (idx < h.PaletteSizeUV) {
          let minBits = h.BitDepth - 3;
          h.palette_num_extra_bits_u = this.L({ b, h }, 2);
          paletteBits = minBits + h.palette_num_extra_bits_u;
        }
        while (idx < h.PaletteSizeUV) {
          h.palette_delta_u = this.L({ b, h }, paletteBits);
          h[`palette_colors_u[${idx}]`] =
            this.Clip1(h[`palette_colors_u[${idx - 1}]`] +
              h.palette_delta_u);
          let range = (1 << h.BitDepth) - h[`palette_colors_u[${idx}]`];
          paletteBits = Math.min(paletteBits, CeilLog2(range));
          idx++;
        }
        this.sort(h.palette_colors_u, 0, h.PaletteSizeUV - 1);
        h.delta_encode_palette_colors_v = this.L({ b, h }, 1);
        if (h.delta_encode_palette_colors_v) {
          let minBits = h.BitDepth - 4;
          let maxVal = 1 << h.BitDepth;
          h.palette_num_extra_bits_v = this.L({ b, h }, 2);
          paletteBits = minBits + h.palette_num_extra_bits_v;
          h[`palette_colors_v[0]`] = this.L({ b, h }, h.BitDepth);
          for (let idx = 1; idx < h.PaletteSizeUV; idx++) {
            h.palette_delta_v = this.L({ b, h }, paletteBits);
            if (h.palette_delta_v) {
              h.palette_delta_sign_bit_v = this.L({ b, h }, 1);
              if (h.palette_delta_sign_bit_v) {
                h.palette_delta_v = -h.palette_delta_v;
              }
            }
            let val = h[`palette_colors_v[${idx - 1}]`] + h.palette_delta_v;
            if (val < 0) val += maxVal;
            if (val >= maxVal) val -= maxVal;
            h[`palette_colors_v[${idx}]`] = this.Clip1(val);
          }
        } else {
          for (idx = 0; idx < h.PaletteSizeUV; idx++) {
            h[`palette_colors_v[idx]`] = this.L({ b, h }, h.BitDepth);
          }
        }
      }
    }
  }

  get_palette_cache({ b, h }: { b: BitReader, h: any }, plane: number) {
    let aboveN = 0;
    if ((h.MiRow * MI_SIZE) % 64) {
      aboveN = h[`PaletteSizes[${plane}][${h.MiRow - 1}][${h.MiCol}]`];
    }
    let leftN = 0;
    if (h.AvailL) {
      leftN = h[`PaletteSizes[${plane}][${h.MiRow}][${h.MiCol - 1}]`];
    }
    let aboveIdx = 0;
    let leftIdx = 0;
    let n = 0
    while (aboveIdx < aboveN && leftIdx < leftN) {
      let aboveC = h[`PaletteColors[${plane}][${h.MiRow - 1}][${h.MiCol}][${aboveIdx}]`];
      let leftC = h[`PaletteColors[${plane}][${h.MiRow}][${h.MiCol - 1}][${leftIdx}]`];
      if (leftC < aboveC) {
        if (n == 0 || leftC != h[`PaletteCache[${n - 1}]`]) {
          h[`PaletteCache[${n}]`] = leftC;
          n++;
        }
        leftIdx++;
      } else {
        if (n == 0 || aboveC != h[`PaletteCache[${n - 1}]`]) {
          h[`PaletteCache[${n}]`] = aboveC;
          n++;
        }
        aboveIdx++;
        if (leftC == aboveC) {
          leftIdx++;
        }
      }
    }
    while (aboveIdx < aboveN) {
      let val = h[`PaletteColors[${plane}][${h.MiRow - 1}][${h.MiCol}][${aboveIdx}]`];
      aboveIdx++;
      if (n == 0 || val != h[`PaletteCache[${n - 1}]`]) {
        h[`PaletteCache[${n}]`] = val;
        n++;
      }
    }
    while (leftIdx < leftN) {
      let val = h[`PaletteColors[${plane}][${h.MiRow}][${h.MiCol - 1}][${leftIdx}]`];
      leftIdx++;
      if (n == 0 || val != h[`PaletteCache[${n - 1}]`]) {
        h[`PaletteCache[${n}]`] = val;
        n++;
      }
    }
    return n;
  }

  // 5.11.47. Transform type syntax
  transform_type({ b, h }: { b: BitReader, h: any }, x4: number, y4: number, txSz: number) {
    const Tx_Type_Intra_Inv_Set1 = [IDTX, DCT_DCT, V_DCT, H_DCT, ADST_ADST, ADST_DCT, DCT_ADST];
    const Tx_Type_Intra_Inv_Set2 = [IDTX, DCT_DCT, ADST_ADST, ADST_DCT, DCT_ADST];
    const Tx_Type_Inter_Inv_Set1 = [
      IDTX, V_DCT, H_DCT, V_ADST, H_ADST, V_FLIPADST, H_FLIPADST,
      DCT_DCT, ADST_DCT, DCT_ADST, FLIPADST_DCT, DCT_FLIPADST, ADST_ADST,
      FLIPADST_FLIPADST, ADST_FLIPADST, FLIPADST_ADST];
    const Tx_Type_Inter_Inv_Set2 = [
      IDTX, V_DCT, H_DCT, DCT_DCT, ADST_DCT, DCT_ADST, FLIPADST_DCT,
      DCT_FLIPADST, ADST_ADST, FLIPADST_FLIPADST, ADST_FLIPADST,
      FLIPADST_ADST];
    const Tx_Type_Inter_Inv_Set3 = [IDTX, DCT_DCT];

    let set = this.get_tx_set({ b, h }, txSz);
    if (set > 0 &&
      (h.segmentation_enabled ? this.get_qindex({ h }, 1, h.segment_id) : h.base_q_idx) > 0) {
      if (h.is_inter) {
        h.inter_tx_type = this.S({ b, h }, { name: "inter_tx_type" });
        if (set == TX_SET_INTER_1)
          h.TxType = Tx_Type_Inter_Inv_Set1[h.inter_tx_type]
        else if (set == TX_SET_INTER_2)
          h.TxType = Tx_Type_Inter_Inv_Set2[h.inter_tx_type]
        else
          h.TxType = Tx_Type_Inter_Inv_Set3[h.inter_tx_type]
      } else {
        h.intra_tx_type = this.S({ b, h }, { name: "intra_tx_type", set, txSz });
        if (set == TX_SET_INTRA_1)
          h.TxType = Tx_Type_Intra_Inv_Set1[h.intra_tx_type]
        else
          h.TxType = Tx_Type_Intra_Inv_Set2[h.intra_tx_type]
      }
    } else {
      h.TxType = DCT_DCT
    }
    for (let i = 0; i < (Tx_Width[txSz] >> 2); i++) {
      for (let j = 0; j < (Tx_Height[txSz] >> 2); j++) {
        h[`TxTypes[${y4 + j}][${x4 + i}]`] = h.TxType;
      }
    }
  }

  // 5.11.48. Get transform set function
  get_tx_set({ b, h }: { b: BitReader, h: any }, txSz: number) {
    let txSzSqr = Tx_Size_Sqr[txSz];
    let txSzSqrUp = Tx_Size_Sqr_Up[txSz];
    if (txSzSqrUp > TX_32X32)
      return TX_SET_DCTONLY
    if (h.is_inter) {
      if (h.reduced_tx_set || txSzSqrUp == TX_32X32) return TX_SET_INTER_3;
      else if (txSzSqr == TX_16X16) return TX_SET_INTER_2
      return TX_SET_INTER_1;
    } else {
      if (txSzSqrUp == TX_32X32) return TX_SET_DCTONLY
      else if (h.reduced_tx_set) return TX_SET_INTRA_2
      else if (txSzSqr == TX_16X16) return TX_SET_INTRA_2
      return TX_SET_INTRA_1
    }
  }

  // 5.11.49. Palette tokens syntax
  palette_tokens({ b, h }: { b: BitReader, h: any }) {
    let blockHeight = Block_Height[h['MiSize']];
    let blockWidth = Block_Width[h['MiSize']];
    let onscreenHeight = Math.min(blockHeight, (h['MiRows'] - h['MiRow']) * MI_SIZE);
    let onscreenWidth = Math.min(blockWidth, (h['MiCols'] - h['MiCol']) * MI_SIZE);
    if (h['PaletteSizeY']) {
      h.color_index_map_y = this.NS({ b, h }, h['PaletteSizeY']);
      h[`ColorMapY[0][0]`] = h.color_index_map_y;
      for (let i = 1; i < onscreenHeight + onscreenWidth - 1; i++) {
        for (let j = Math.min(i, onscreenWidth - 1);
          j >= Math.max(0, i - onscreenHeight + 1); j--) {
          this.get_palette_color_context({ b, h },
            h['ColorMapY'], (i - j), j, h['PaletteSizeY']);
          h.palette_color_idx_y = this.S({ b, h }, { name: "palette_color_idx_y" });
          h[`ColorMapY[${i - j}][${j}]`] = h[`ColorOrder[${h.palette_color_idx_y}]`];
        }
      }
      for (let i = 0; i < onscreenHeight; i++) {
        for (let j = onscreenWidth; j < blockWidth; j++) {
          h[`ColorMapY[${i}][${j}]`] = h[`ColorMapY[${i}][${onscreenWidth - 1}]`];
        }
      }
      for (let i = onscreenHeight; i < blockHeight; i++) {
        for (let j = 0; j < blockWidth; j++) {
          h[`ColorMapY[${i}][${j}]`] = h[`ColorMapY[${onscreenHeight - 1}][${j}]`]
        }
      }
    }
    if (h['PaletteSizeUV']) {
      h.color_index_map_uv = this.NS({ b, h }, h['PaletteSizeUV']);
      h[`ColorMapUV[0][0]`] = h.color_index_map_uv;
      blockHeight = blockHeight >> this.seq_header.subsampling_y;
      blockWidth = blockWidth >> this.seq_header.subsampling_x;
      onscreenHeight = onscreenHeight >> this.seq_header.subsampling_y;
      onscreenWidth = onscreenWidth >> this.seq_header.subsampling_x;
      if (blockWidth < 4) {
        blockWidth += 2;
        onscreenWidth += 2;
      }
      if (blockHeight < 4) {
        blockHeight += 2;
        onscreenHeight += 2;
      }
      for (let i = 1; i < onscreenHeight + onscreenWidth - 1; i++) {
        for (let j = Math.min(i, onscreenWidth - 1);
          j >= Math.max(0, i - onscreenHeight + 1); j--) {
          this.get_palette_color_context({ b, h },
            h['ColorMapUV'], (i - j), j, h['PaletteSizeUV']);
          h.palette_color_idx_uv = this.S({ b, h }, { name: "palette_color_idx_uv" });
          h[`ColorMapUV[${i - j}][${j}]`] = h[`ColorOrder[${h.palette_color_idx_uv}]`];
        }
      }
      for (let i = 0; i < onscreenHeight; i++) {
        for (let j = onscreenWidth; j < blockWidth; j++) {
          h[`ColorMapUV[${i}][${j}]`] = h[`ColorMapUV[${i}][${onscreenWidth - 1}]`];
        }
      }
      for (let i = onscreenHeight; i < blockHeight; i++) {
        for (let j = 0; j < blockWidth; j++) {
          h[`ColorMapUV[${i}][${j}]`] = h[`ColorMapUV[${onscreenHeight - 1}][${j}]`];
        }
      }
    }
  }

  // 5.11.50. Palette color context function
  get_palette_color_context({ b, h }: { b: BitReader, h: any }, colorMap: number[][], r: number, c: number, n: number) {
    let scores = [0, 0, 0, 0, 0, 0, 0, 0];
    for (let i = 0; i < PALETTE_COLORS; i++) {
      scores[i] = 0
      h[`ColorOrder[${i}]`] = i;
    }
    let neighbor = 0;
    if (c > 0) {
      neighbor = colorMap[r][c - 1]
      scores[neighbor] += 2
    }
    if ((r > 0) && (c > 0)) {
      neighbor = colorMap[r - 1][c - 1]
      scores[neighbor] += 1
    }
    if (r > 0) {
      neighbor = colorMap[r - 1][c]
      scores[neighbor] += 2
    }
    for (let i = 0; i < PALETTE_NUM_NEIGHBORS; i++) {
      let maxScore = scores[i];
      let maxIdx = i;
      for (let j = i + 1; j < n; j++) {
        if (scores[j] > maxScore) {
          maxScore = scores[j]
          maxIdx = j
        }
      }
      if (maxIdx != i) {
        maxScore = scores[maxIdx]
        let maxColorOrder = h[`ColorOrder[${maxIdx}]`];
        for (let k = maxIdx; k > i; k--) {
          scores[k] = scores[k - 1]
          h[`ColorOrder[${k}]`] = h[`ColorOrder[${k - 1}]`];
        }
        scores[i] = maxScore
        h[`ColorOrder[${i}]`] = maxColorOrder;
      }
    }
    h.ColorContextHash = 0;
    for (let i = 0; i < PALETTE_NUM_NEIGHBORS; i++) {
      h.ColorContextHash += scores[i] * Palette_Color_Hash_Multipliers[i]
    }
  }

  // 5.11.51. Is inside function
  is_inside({ b, h }: { b: BitReader, h: any }, candidateR: number, candidateC: number) {
    return (candidateC >= h['MiColStart'] &&
      candidateC < h['MiColEnd'] &&
      candidateR >= h['MiRowStart'] &&
      candidateR < h['MiRowEnd']);
  }

  // 5.11.52. Is inside filter region function
  is_inside_filter_region({ b, h }: { b: BitReader, h: any }, candidateR: number, candidateC: number) {
    let colStart = 0;
    let colEnd = h.MiCols;
    let rowStart = 0;
    let rowEnd = h.MiRows;
    return (candidateC >= colStart &&
      candidateC < colEnd &&
      candidateR >= rowStart &&
      candidateR < rowEnd);
  }

  // 5.11.53. Clamp MV row function
  clamp_mv_row({ b, h }: { b: BitReader, h: any }, mvec: number, border: number) {
    let bh4 = Num_4x4_Blocks_High[h.MiSize]
    let mbToTopEdge = -((h.MiRow * MI_SIZE) * 8);
    let mbToBottomEdge = ((h.MiRows - bh4 - h.MiRow) * MI_SIZE) * 8;
    return this.Clip3(mbToTopEdge - border, mbToBottomEdge + border, mvec);
  }

  // 5.11.54. Clamp MV col function
  clamp_mv_col({ b, h }: { b: BitReader, h: any }, mvec: number, border: number) {
    let bw4 = Num_4x4_Blocks_Wide[h.MiSize];
    let mbToLeftEdge = -((h.MiCol * MI_SIZE) * 8);
    let mbToRightEdge = ((h.MiCols - bw4 - h.MiCol) * MI_SIZE) * 8;
    return this.Clip3(mbToLeftEdge - border, mbToRightEdge + border, mvec);
  }

  // 5.11.55. Clear CDEF function
  clear_cdef({ b, h }: { b: BitReader, h: any }, r: number, c: number) {
    h[`cdef_idx[${r}][${c}]`] = -1; // 定对于特定的64×64块应该使用哪些CDEF过滤参数。值-1表示对该块禁用CDEF
    if (this.seq_header.use_128x128_superblock) {
      let cdefSize4 = Num_4x4_Blocks_Wide[BLOCK_64X64];
      h[`cdef_idx[${r}][${c + cdefSize4}]`] = -1;
      h[`cdef_idx[${r + cdefSize4}][${c}]`] = -1;
      h[`cdef_idx[${r + cdefSize4}][${c + cdefSize4}]`] = -1;
    }
  }

  // 5.11.56. Read CDEF syntax
  read_cdef({ b, h }: { b: BitReader, h: any }) {
    if (h.skip || h.CodedLossless || !this.seq_header.enable_cdef || h.allow_intrabc) {
      return;
    }
    let cdefSize4 = Num_4x4_Blocks_Wide[BLOCK_64X64];
    let cdefMask4 = ~(cdefSize4 - 1);
    let r = h.MiRow & cdefMask4;
    let c = h.MiCol & cdefMask4;
    if (h[`cdef_idx[${r}][${c}]`] == -1) {
      h[`cdef_idx[${r}][${c}]`] = this.L({ b, h }, h.cdef_bits);
      let w4 = Num_4x4_Blocks_Wide[h.MiSize];
      let h4 = Num_4x4_Blocks_High[h.MiSize];
      for (let i = r; i < r + h4; i += cdefSize4) {
        for (let j = c; j < c + w4; j += cdefSize4) {
          h[`cdef_idx[${i}][${j}]`] = h[`cdef_idx[${r}][${c}]`];
        }
      }
    }
  }

  // 5.11.57. Read loop restoration syntax
  read_lr({ b, h }: { b: BitReader, h: any }, r: number, c: number, bSize: number) {
    let count_units_in_frame = function (unitSize: number, frameSize: number) {
      return Math.max(Math.floor((frameSize + (unitSize >>> 1)) / unitSize), 1);
    }
    if (h.allow_intrabc) {
      return;
    }
    let wide = Num_4x4_Blocks_Wide[bSize];
    let high = Num_4x4_Blocks_High[bSize];
    for (let plane = 0; plane < this.seq_header['NumPlanes']; plane++) {
      if (h[`FrameRestorationType[${plane}]`] != RESTORE_NONE) {
        let subX = (plane == 0) ? 0 : this.seq_header.subsampling_x;
        let subY = (plane == 0) ? 0 : this.seq_header.subsampling_y;
        let unitSize = h[`LoopRestorationSize[${plane}]`];

        let unitRows = count_units_in_frame(unitSize, Round2(h.FrameHeight, subY));
        let unitCols = count_units_in_frame(unitSize, Round2(h.UpscaledWidth, subX));
        let unitRowStart = Math.floor((r * (MI_SIZE >>> subY) + unitSize - 1) / unitSize);
        let unitRowEnd = Math.min(unitRows, Math.floor(((r + high) * (MI_SIZE >>> subY) + unitSize - 1) / unitSize));
        let numerator = 0;
        let denominator = 0;
        if (h.use_superres) {
          numerator = (MI_SIZE >>> subX) * h['SuperresDenom'];
          denominator = unitSize * SUPERRES_NUM;
        } else {
          numerator = MI_SIZE >>> subX;
          denominator = unitSize;
        }
        let unitColStart = Math.floor((c * numerator + denominator - 1) / denominator);
        let unitColEnd = Math.min(unitCols, Math.floor(((c + wide) * numerator + denominator - 1) / denominator));
        for (let unitRow = unitRowStart; unitRow < unitRowEnd; unitRow++) {
          for (let unitCol = unitColStart; unitCol < unitColEnd; unitCol++) {
            this.read_lr_unit({ b, h }, plane, unitRow, unitCol)
          }
        }
      }
    }
  }

  // 5.11.58. Read loop restoration unit syntax
  read_lr_unit({ b, h }: { b: BitReader, h: any }, plane: number, unitRow: number, unitCol: number) {
    const Wiener_Taps_Min = [-5, -23, -17];
    const Wiener_Taps_Max = [10, 8, 46];
    const Wiener_Taps_K = [1, 2, 3];
    const Sgrproj_Xqd_Min = [-96, -32];
    const Sgrproj_Xqd_Max = [31, 95];
    const Sgr_Params = [
      [2, 12, 1, 4], [2, 15, 1, 6], [2, 18, 1, 8], [2, 21, 1, 9],
      [2, 24, 1, 10], [2, 29, 1, 11], [2, 36, 1, 12], [2, 45, 1, 13],
      [2, 56, 1, 14], [2, 68, 1, 15], [0, 0, 1, 5], [0, 0, 1, 8],
      [0, 0, 1, 11], [0, 0, 1, 14], [2, 30, 0, 0], [2, 75, 0, 0]
    ];

    if (h[`FrameRestorationType[${plane}]`] == RESTORE_WIENER) {
      h.use_wiener = this.S({ b, h }, { name: "use_wiener" });
      h.restoration_type = h.use_wiener ? RESTORE_WIENER : RESTORE_NONE;
    } else if (h[`FrameRestorationType[${plane}]`] == RESTORE_SGRPROJ) {
      h.use_sgrproj = this.S({ b, h }, { name: "use_sgrproj" });
      h.restoration_type = h.use_sgrproj ? RESTORE_SGRPROJ : RESTORE_NONE;
    } else {
      h.restoration_type = this.S({ b, h }, { name: "restoration_type" });
    }
    h[`LrType[${plane}][${unitRow}][${unitCol}]`] = h.restoration_type;
    if (h.restoration_type == RESTORE_WIENER) {
      for (let pass = 0; pass < 2; pass++) {
        let firstCoeff = 0;
        if (plane) {
          firstCoeff = 1;
          h[`LrWiener[plane][unitRow][unitCol][pass][0]`] = 0;
        } else {
          firstCoeff = 0;
        }
        for (let j = firstCoeff; j < 3; j++) {
          let min = Wiener_Taps_Min[j];
          let max = Wiener_Taps_Max[j];
          let k = Wiener_Taps_K[j];
          let v = this.decode_signed_subexp_with_ref_bool({ b, h },
            min, max + 1, k, h[`RefLrWiener[${plane}][${pass}][${j}]`]);
          h[`LrWiener[${plane}][${unitRow}][${unitCol}][${pass}][${j}]`] = v;
          h[`RefLrWiener[${plane}][${pass}][${j}]`] = v;
        }
      }
    } else if (h.restoration_type == RESTORE_SGRPROJ) {
      h.lr_sgr_set = this.L({ b, h }, SGRPROJ_PARAMS_BITS);
      h[`LrSgrSet[${plane}][${unitRow}][${unitCol}]`] = h.lr_sgr_set;
      for (let i = 0; i < 2; i++) {
        let radius = Sgr_Params[h.lr_sgr_set][i * 2];
        let min = Sgrproj_Xqd_Min[i];
        let max = Sgrproj_Xqd_Max[i];
        let v = 0;
        if (radius) {
          v = this.decode_signed_subexp_with_ref_bool({ b, h },
            min, max + 1, SGRPROJ_PRJ_SUBEXP_K,
            h[`RefSgrXqd[${plane}][${i}]`]);
        } else {
          v = 0;
          if (i == 1) {
            v = this.Clip3(min, max, (1 << SGRPROJ_PRJ_BITS) -
              h[`RefSgrXqd[${plane}][0]`])
          }
        }
        h[`LrSgrXqd[${plane}][${unitRow}][${unitCol}][${i}]`] = v;
        h[`RefSgrXqd[${plane}][${i}]`] = v;
      }
    }
  }

  decode_signed_subexp_with_ref_bool({ b, h }: { b: BitReader, h: any }, low: number, high: number, k: number, r: number) {
    let x = this.decode_unsigned_subexp_with_ref_bool({ b, h }, high - low, k, r - low)
    return x + low;
  }

  decode_unsigned_subexp_with_ref_bool({ b, h }: { b: BitReader, h: any }, mx: number, k: number, r: number) {
    let v = this.decode_subexp_bool({ b, h }, mx, k);
    if ((r << 1) <= mx) {
      return this.inverse_recenter(r, v);
    } else {
      return mx - 1 - this.inverse_recenter(mx - 1 - r, v);
    }
  }

  decode_subexp_bool({ b, h }: { b: BitReader, h: any }, numSyms: number, k: number) {
    let i = 0;
    let mk = 0;
    while (1) {
      let b2 = i ? k + i - 1 : k;
      let a = 1 << b2;
      if (numSyms <= mk + 3 * a) {
        h.subexp_unif_bools = this.NS({ b, h }, numSyms - mk);
        return h.subexp_unif_bools + mk;
      } else {
        h.subexp_more_bools = this.L({ b, h }, 1);
        if (h.subexp_more_bools) {
          i++;
          mk += a;
        } else {
          h.subexp_bools = this.L({ b, h }, b2);
          return h.subexp_bools + mk;
        }
      }
    }
  }

  // 5.12.1. General tile list OBU syntax
  tile_list_obu({ b, h }: { b: BitReader, h: any }) {
    h['output_frame_width_in_tiles_minus_1'] = b.f(8);
    h['output_frame_height_in_tiles_minus_1'] = b.f(8);
    h['tile_count_minus_1'] = b.f(16);
    for (let tile = 0; tile <= h['tile_count_minus_1']; tile++)
      this.tile_list_entry({ b, h });
  }

  // 5.12.2. Tile list entry syntax
  tile_list_entry({ b, h }: { b: BitReader, h: any }) {
    h['anchor_frame_idx'] = b.f(8);
    h['anchor_tile_row'] = b.f(8);
    h['anchor_tile_col'] = b.f(8);
    h['tile_data_size_minus_1'] = b.f(16);
    let N = 8 * (h['tile_data_size_minus_1'] + 1);
    h['coded_tile_data'] = b.f(N);
  }

  // 6.10.2 解码图块语义
  clear_left_context({ b, h }: { b: BitReader, h: any }) {
    for (let plane = 0; plane < 3; plane++) {
      for (let i = 0; i < h.MiRows; i++) {
        h[`LeftLevelContext[${plane}][${i}]`] = 0;
        h[`LeftDcContext[${plane}][${i}]`] = 0;
        h[`LeftSegPredContext[${i}]`] = 0;
      }
    }
  }
  clear_above_context({ b, h }: { b: BitReader, h: any }) {
    // 当这个函数被调用时，数组AboveLevelContext, AboveDcContext和AboveSegPredContext被设置为0
    for (let plane = 0; plane < 3; plane++) {
      for (let i = 0; i < h.MiCols; i++) {
        h[`AboveLevelContext[${plane}][${i}]`] = 0;
        h[`AboveDcContext[${plane}][${i}]`] = 0;
        h[`AboveSegPredContext[${i}]`] = 0;
      }
    }
  }

  // 7.3.1 一般的
  _7_3_1({ b, h }: { b: BitReader, h: any }) {
    // 未知
    let tile = 0;
    let OutputFrameY: number[][] = [];
    let OutputFrameU: number[][] = [];
    let OutputFrameV: number[][] = [];
    let OutY: number[][] = [];
    let OutU: number[][] = [];
    let OutV: number[][] = [];

    const TileWidth = (h['MiColEnd'] - h['MiColStart']) * MI_SIZE;
    const TileHeight = (h['MiRowEnd'] - h['MiRowStart']) * MI_SIZE;
    let destX = TileWidth * (tile % (h['output_frame_width_in_tiles_minus_1'] + 1));
    let destY = TileHeight * (tile / (h['output_frame_width_in_tiles_minus_1'] + 1));
    let width = TileWidth;
    let height = TileHeight;
    for (let y = 0; y < h; y++) {
      for (let x = 0; x < width; x++) {
        OutputFrameY[y + destY][x + destX] = OutY[y][x];
      }
    }
    width = width >> h['subsampling_x'];
    h = h >> h['subsampling_y'];
    destX = destX >> h['subsampling_x'];
    destY = destY >> h['subsampling_y'];
    for (let y = 0; y < h; y++) {
      for (let x = 0; x < width; x++) {
        OutputFrameU[y + destY][x + destX] = OutU[y][x];
        OutputFrameV[y + destY][x + destX] = OutV[y][x];
      }
    }
  }

  // 7.3.2 解码相机瓦片过程
  _7_3_2({ b, h }: { b: BitReader, h: any }) {
    let CurrentQIndex = h['base_q_idx'];
    this.init_symbol(h['tile_data_size_minus_1'] + 1, { b, h });
    this.clear_above_context({ b, h });
    let sbSize = h['use_128x128_superblock'] ? BLOCK_128X128 : BLOCK_64X64;
    let sbSize4 = Num_4x4_Blocks_Wide[sbSize];
    let MiRowStart = h[`MiRowStarts[${h.anchor_tile_row}]`];
    let MiRowEnd = h[`MiRowStarts[${h.anchor_tile_row + 1}]`];
    let MiColStart = h[`MiColStarts[${h.anchor_tile_col}]`];
    let MiColEnd = h[`MiColStarts[${h.anchor_tile_col + 1}]`];
    for (let r = MiRowStart; r < MiRowEnd; r += sbSize4) {
      this.clear_left_context({ b, h });
      for (let c = MiColStart; c < MiColEnd; c += sbSize4) {
        let ReadDeltas = h.delta_q_present;
        this.clear_block_decoded_flags({ b, h }, Number(c < (MiColEnd - 1)), c, sbSize);
        this.decode_partition({ b, h }, r, c, sbSize);
      }
    }
    this.exit_symbol({ b, h });
    let width = (MiColEnd - MiColStart) * MI_SIZE;
    let height = (MiRowEnd - MiRowStart) * MI_SIZE;
    let x0 = MiColStart * MI_SIZE;
    let y0 = MiRowStart * MI_SIZE;
    let subX = this.seq_header.subsampling_x;
    let subY = this.seq_header.subsampling_y;
    let xC0 = (MiColStart * MI_SIZE) >> subX;
    let yC0 = (MiRowStart * MI_SIZE) >> subY;
  }

  // 7.10.3. Has overlappable candidates process
  has_overlappable_candidates({ b, h }: { b: BitReader, h: any }) {
    if (h.AvailU) {
      let w4 = Num_4x4_Blocks_Wide[h.MiSize];
      for (let x4 = h.MiCol; x4 < Math.min(h.MiCols, h.MiCol + w4); x4 += 2) {
        if (h[`RefFrames[${h.MiRow - 1}][${x4 | 1}][0]`] > INTRA_FRAME)
          return 1;
      }
    }
    if (h.AvailL) {
      let h4 = Num_4x4_Blocks_High[h.MiSize];
      for (let y4 = h.MiRow; y4 < Math.min(h.MiRows, h.MiRow + h4); y4 += 2) {
        if (h[`RefFrames[${y4 | 1}][${h.MiCol - 1}][0]`] > INTRA_FRAME)
          return 1;
      }
    }
    return 0;
  }

  decode_frame_wrapup({ b, h }: { b: BitReader, h: any }) {

  }

  init_symbol(sz: number, { b, h }: { b: BitReader, h: any }) {
    // this.aom.tell_offs = 10 - (32 - 8);
    // this.aom.dif = 2147483647;
    // this.aom.rng = 32768;
    // this.aom.cnt = -15;
    // let s = 32 - 9 - (this.aom.cnt + 15);
    // for (; s >= 0; s -= 8) {
    //   this.aom.dif ^= b.u(8) << s;
    //   this.aom.cnt += 8;
    // }
    // this.aom.dif = 1316613375;
    // this.aom.cnt = 9;

    // let numBits = Math.min(sz * 8, 15);
    // let buf = b.f(numBits);
    // let paddedBuf = buf << (15 - numBits);
    // h.SymbolValue = ((1 << 15) - 1) ^ paddedBuf;
    // h.SymbolRange = 1 << 15;
    // h.SymbolMaxBits = 8 * sz - 15;

    h.SymbolValue = 2147483647;
    h.SymbolRange = 1 << 15;
    h.SymbolCount = - 15;
    let s = 32 - 9 - (h.SymbolCount + 15);
    for (; s >= 0; s -= 8) {
      h.SymbolValue ^= b.u(8) << s;
      h.SymbolCount += 8;
    }
  }

  // 8.2.6 Symbol decoding process
  read_symbol({ b, h }: { b: BitReader, h: any }, cdf: number[], nsymbs: number) {
    // decode_cdf_q15
    const N = cdf.length - 1;
    let prev = 0;
    let c = h.SymbolValue >>> 16;
    let v = h.SymbolRange;
    let symbol = -1;
    do {
      symbol++;
      prev = v;
      {
        let v1 = h.SymbolRange >>> 8;
        let v2 = cdf[symbol] >>> EC_PROB_SHIFT;
        let v3 = v1 * v2;
        let v4 = 7 - EC_PROB_SHIFT;
        v = v3 >>> v4;
      }
      // v = ((h.SymbolRange >>> 8) * (cdf[symbol] >>> EC_PROB_SHIFT)) >>> (7 - EC_PROB_SHIFT);
      v += EC_MIN_PROB * (N - symbol - 1);
    } while (c < v);

    h.SymbolRange = prev - v;
    h.SymbolValue -= v << 16;

    this.renormalized_symbol({ h, b });

    // Update CDF if required
    if (!h.disable_cdf_update) {
      const nsymbs2speed = [0, 0, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2];
      const rate = 3 + Number(cdf[N] > 15) + Number(cdf[N] > 31) + Math.min(Math.floor(Math.log2(N)), 2);
      let tmp = 32768;
      for (let i = 0; i < N - 1; i++) {
        tmp = (i === symbol) ? 0 : tmp;
        if (tmp < cdf[i]) {
          cdf[i] -= ((cdf[i] - tmp) >> rate);
        } else {
          cdf[i] += ((tmp - cdf[i]) >> rate);
        }
      }
      cdf[N] += Number(cdf[N] < 32);
    }
    return symbol;
  }

  renormalized_symbol({ b, h }: { b: BitReader, h: any }) {
    const bits = 15 - b.FloorLog2(h.SymbolRange);
    h.SymbolRange = h.SymbolRange << bits;
    h.SymbolCount -= bits;

    h.SymbolValue = ((((h.SymbolValue + 1) << bits) & 0xffffffff) - 1) >>> 0;
    if (h.SymbolCount < 0) {
      let s = 32 - 9 - (h.SymbolCount + 15);
      for (; s >= 0; s -= 8) {
        h.SymbolValue = (h.SymbolValue ^ (b.u(8) << s)) >>> 0;
        h.SymbolCount += 8;
      }
    }
  };

  exit_symbol({ b, h }: { b: BitReader, h: any }) {
  }

  // 8.2.3
  read_bool() {
    let cdf = [0, 0, 0];
    cdf[0] = 1 << 14
    cdf[1] = 1 << 15
    cdf[2] = 0;
  }

  // 8.2.5
  read_literal({ b, h }: { b: BitReader, h: any }, n: number) {
    let x = 0;
    for (let i = 0; i < n; i++) {
      // x = 2 * x + this.read_bool();
    }
  }

  frame_end_update_cdf({ b, h }: { b: BitReader, h: any }) {
  }

  load_grain_params(idx: number, { b, h }: { b: BitReader, h: any },) {

  }

  set_frame_refs({ b, h }: { b: BitReader, h: any }) {

  }

  init_non_coeff_cdfs({ b, h }: { b: BitReader, h: any }) {
    this.TileIntraFrameYModeCdf = Default_Intra_Frame_Y_Mode_Cdf.map((c0) => c0.map((c1) => OBU.AOM_CDF(c1)));

    this.TileYModeCdf = Default_Y_Mode_Cdf.map((cdf) => OBU.AOM_CDF(cdf));
    this.TileUVModeCflNotAllowedCdf = Default_Uv_Mode_Cfl_Not_Allowed_Cdf.map((cdf) => OBU.AOM_CDF(cdf));
    this.TileUVModeCflAllowedCdf = Default_Uv_Mode_Cfl_Allowed_Cdf.map((cdf) => OBU.AOM_CDF(cdf));
    this.TileAngleDeltaCdf = Default_Angle_Delta_Cdf.map((cdf) => OBU.AOM_CDF(cdf));
    this.TileIntrabcCdf = OBU.AOM_CDF(Default_Intrabc_Cdf);
    this.TilePartitionW8Cdf = Default_Partition_W8_Cdf.map((cdf) => OBU.AOM_CDF(cdf));
    this.TilePartitionW16Cdf = Default_Partition_W16_Cdf.map((cdf) => OBU.AOM_CDF(cdf));
    this.TilePartitionW32Cdf = Default_Partition_W32_Cdf.map((cdf) => OBU.AOM_CDF(cdf));
    this.TilePartitionW64Cdf = Default_Partition_W64_Cdf.map((cdf) => OBU.AOM_CDF(cdf));
    this.TilePartitionW128Cdf = Default_Partition_W128_Cdf.map((cdf) => OBU.AOM_CDF(cdf));
    this.TileSegmentIdCdf = Default_Segment_Id_Cdf.map((cdf) => OBU.AOM_CDF(cdf));
    this.TileSegmentIdPredictedCdf = Default_Segment_Id_Predicted_Cdf.map((cdf) => OBU.AOM_CDF(cdf));
    this.TileTx8x8Cdf = Default_Tx_8x8_Cdf.map((cdf) => OBU.AOM_CDF(cdf));
    this.TileTx16x16Cdf = Default_Tx_16x16_Cdf.map((cdf) => OBU.AOM_CDF(cdf));
    this.TileTx32x32Cdf = Default_Tx_32x32_Cdf.map((cdf) => OBU.AOM_CDF(cdf));
    this.TileTx64x64Cdf = Default_Tx_64x64_Cdf.map((cdf) => OBU.AOM_CDF(cdf));
    this.TileTxfmSplitCdf = Default_Txfm_Split_Cdf.map((cdf) => OBU.AOM_CDF(cdf));
    this.TileFilterIntraModeCdf = OBU.AOM_CDF(Default_Filter_Intra_Mode_Cdf);
    this.TileFilterIntraCdf = Default_Filter_Intra_Cdf.map((cdf) => OBU.AOM_CDF(cdf));
    this.TileInterpFilterCdf = Default_Interp_Filter_Cdf.map((cdf) => OBU.AOM_CDF(cdf));
    this.TileMotionModeCdf = Default_Motion_Mode_Cdf.map((cdf) => OBU.AOM_CDF(cdf));
    this.TileNewMvCdf = Default_New_Mv_Cdf.map((cdf) => OBU.AOM_CDF(cdf));
    this.TileZeroMvCdf = Default_Zero_Mv_Cdf.map((cdf) => OBU.AOM_CDF(cdf));
    this.TileRefMvCdf = Default_Ref_Mv_Cdf.map((cdf) => OBU.AOM_CDF(cdf));
    this.TileCompoundModeCdf = Default_Compound_Mode_Cdf.map((cdf) => OBU.AOM_CDF(cdf));
    this.TileDrlModeCdf = Default_Drl_Mode_Cdf.map((cdf) => OBU.AOM_CDF(cdf));
    this.TileIsInterCdf = Default_Is_Inter_Cdf.map((cdf) => OBU.AOM_CDF(cdf));
    this.TileCompModeCdf = Default_Comp_Mode_Cdf.map((cdf) => OBU.AOM_CDF(cdf));
    this.TileSkipModeCdf = Default_Skip_Mode_Cdf.map((cdf) => OBU.AOM_CDF(cdf));
    this.TileSkipCdf = Default_Skip_Cdf.map((cdf) => OBU.AOM_CDF(cdf));
    this.TileCompRefCdf = Default_Comp_Ref_Cdf.map((cdfs) => { return cdfs.map((cdf) => OBU.AOM_CDF(cdf)) });
    this.TileCompBwdRefCdf = Default_Comp_Bwd_Ref_Cdf.map((cdfs) => { return cdfs.map((cdf) => OBU.AOM_CDF(cdf)) });
    this.TileSingleRefCdf = Default_Single_Ref_Cdf.map((cdfs) => { return cdfs.map((cdf) => OBU.AOM_CDF(cdf)) });
    this.TilePaletteYModeCdf = Default_Palette_Y_Mode_Cdf.map((cdfs) => { return cdfs.map((cdf) => OBU.AOM_CDF(cdf)) });
    this.TilePaletteUVModeCdf = Default_Palette_Uv_Mode_Cdf.map((cdf) => OBU.AOM_CDF(cdf));
    this.TilePaletteYSizeCdf = Default_Palette_Y_Size_Cdf.map((cdf) => OBU.AOM_CDF(cdf));
    this.TilePaletteUVSizeCdf = Default_Palette_Uv_Size_Cdf.map((cdf) => OBU.AOM_CDF(cdf));
    this.TilePaletteSize2YColorCdf = Default_Palette_Size_2_Y_Color_Cdf.map((cdf) => OBU.AOM_CDF(cdf));
    this.TilePaletteSize2UVColorCdf = Default_Palette_Size_2_Uv_Color_Cdf.map((cdf) => OBU.AOM_CDF(cdf));
    this.TilePaletteSize3YColorCdf = Default_Palette_Size_3_Y_Color_Cdf.map((cdf) => OBU.AOM_CDF(cdf));
    this.TilePaletteSize3UVColorCdf = Default_Palette_Size_3_Uv_Color_Cdf.map((cdf) => OBU.AOM_CDF(cdf));
    this.TilePaletteSize4YColorCdf = Default_Palette_Size_4_Y_Color_Cdf.map((cdf) => OBU.AOM_CDF(cdf));
    this.TilePaletteSize4UVColorCdf = Default_Palette_Size_4_Uv_Color_Cdf.map((cdf) => OBU.AOM_CDF(cdf));
    this.TilePaletteSize5YColorCdf = Default_Palette_Size_5_Y_Color_Cdf.map((cdf) => OBU.AOM_CDF(cdf));
    this.TilePaletteSize5UVColorCdf = Default_Palette_Size_5_Uv_Color_Cdf.map((cdf) => OBU.AOM_CDF(cdf));
    this.TilePaletteSize6YColorCdf = Default_Palette_Size_6_Y_Color_Cdf.map((cdf) => OBU.AOM_CDF(cdf));
    this.TilePaletteSize6UVColorCdf = Default_Palette_Size_6_Uv_Color_Cdf.map((cdf) => OBU.AOM_CDF(cdf));
    this.TilePaletteSize7YColorCdf = Default_Palette_Size_7_Y_Color_Cdf.map((cdf) => OBU.AOM_CDF(cdf));
    this.TilePaletteSize7UVColorCdf = Default_Palette_Size_7_Uv_Color_Cdf.map((cdf) => OBU.AOM_CDF(cdf));
    this.TilePaletteSize8YColorCdf = Default_Palette_Size_8_Y_Color_Cdf.map((cdf) => OBU.AOM_CDF(cdf));
    this.TilePaletteSize8UVColorCdf = Default_Palette_Size_8_Uv_Color_Cdf.map((cdf) => OBU.AOM_CDF(cdf));
    this.TileDeltaQCdf = OBU.AOM_CDF(Default_Delta_Q_Cdf);;
    this.TileDeltaLFCdf = OBU.AOM_CDF(Default_Delta_Lf_Cdf);
    this.TileIntraTxTypeSet1Cdf = Default_Intra_Tx_Type_Set1_Cdf.map((cdfs) => { return cdfs.map((cdf) => OBU.AOM_CDF(cdf)) });
    this.TileIntraTxTypeSet2Cdf = Default_Intra_Tx_Type_Set2_Cdf.map((cdfs) => { return cdfs.map((cdf) => OBU.AOM_CDF(cdf)) });
    this.TileInterTxTypeSet1Cdf = Default_Inter_Tx_Type_Set1_Cdf.map((cdf) => OBU.AOM_CDF(cdf));
    this.TileInterTxTypeSet2Cdf = OBU.AOM_CDF(Default_Inter_Tx_Type_Set2_Cdf);
    this.TileInterTxTypeSet3Cdf = Default_Inter_Tx_Type_Set3_Cdf.map((cdf) => OBU.AOM_CDF(cdf));
    this.TileUseObmcCdf = Default_Use_Obmc_Cdf.map((cdf) => OBU.AOM_CDF(cdf));
    this.TileInterIntraCdf = Default_Inter_Intra_Cdf.map((cdf) => OBU.AOM_CDF(cdf));
    this.TileCompRefTypeCdf = Default_Comp_Ref_Type_Cdf.map((cdf) => OBU.AOM_CDF(cdf));
    this.TileCflSignCdf = OBU.AOM_CDF(Default_Cfl_Sign_Cdf);
    this.TileUniCompRefCdf = Default_Uni_Comp_Ref_Cdf.map((cdfs) => { return cdfs.map((cdf) => OBU.AOM_CDF(cdf)) });
    this.TileWedgeInterIntraCdf = Default_Wedge_Inter_Intra_Cdf.map((cdf) => OBU.AOM_CDF(cdf));
    this.TileCompGroupIdxCdf = Default_Comp_Group_Idx_Cdf.map((cdf) => OBU.AOM_CDF(cdf));
    this.TileCompoundIdxCdf = Default_Compound_Idx_Cdf.map((cdf) => OBU.AOM_CDF(cdf));
    this.TileCompoundTypeCdf = Default_Compound_Type_Cdf.map((cdf) => OBU.AOM_CDF(cdf));
    this.TileInterIntraModeCdf = Default_Inter_Intra_Mode_Cdf.map((cdf) => OBU.AOM_CDF(cdf));
    this.TileWedgeIndexCdf = Default_Wedge_Index_Cdf.map((cdf) => OBU.AOM_CDF(cdf));
    this.TileCflAlphaCdf = Default_Cfl_Alpha_Cdf.map((cdf) => OBU.AOM_CDF(cdf));
    this.TileUseWienerCdf = OBU.AOM_CDF(Default_Use_Wiener_Cdf);
    this.TileUseSgrprojCdf = OBU.AOM_CDF(Default_Use_Sgrproj_Cdf);
    this.TileRestorationTypeCdf = OBU.AOM_CDF(Default_Restoration_Type_Cdf);
    this.TileTxbSkipCdf = Default_Txb_Skip_Cdf.map((c0) => c0.map((c1) => c1.map((c2) => OBU.AOM_CDF(c2))));
    this.TileEobPt16Cdf = Default_Eob_Pt_16_Cdf.map((c0) => c0.map((c1) => c1.map((c2) => OBU.AOM_CDF(c2))));
    this.TileEobPt32Cdf = Default_Eob_Pt_32_Cdf.map((c0) => c0.map((c1) => c1.map((c2) => OBU.AOM_CDF(c2))));
    this.TileEobPt64Cdf = Default_Eob_Pt_64_Cdf.map((c0) => c0.map((c1) => c1.map((c2) => OBU.AOM_CDF(c2))));
    this.TileEobPt128Cdf = Default_Eob_Pt_128_Cdf.map((c0) => c0.map((c1) => c1.map((c2) => OBU.AOM_CDF(c2))));
    this.TileEobPt256Cdf = Default_Eob_Pt_256_Cdf.map((c0) => c0.map((c1) => c1.map((c2) => OBU.AOM_CDF(c2))));
    this.TileEobPt512Cdf = Default_Eob_Pt_512_Cdf.map((c0) => c0.map((c1) => OBU.AOM_CDF(c1)));
    this.TileEobPt1024Cdf = Default_Eob_Pt_1024_Cdf.map((c0) => c0.map((c1) => OBU.AOM_CDF(c1)));
    this.TileEobExtraCdf = Default_Eob_Extra_Cdf.map((c0) => c0.map((c1) => c1.map((c2) => c2.map((c3) => OBU.AOM_CDF(c3)))));
    this.TileDcSignCdf = Default_Dc_Sign_Cdf.map((c0) => c0.map((c1) => c1.map((c2) => OBU.AOM_CDF(c2))));
    this.TileCoeffBaseEobCdf = Default_Coeff_Base_Eob_Cdf.map((c0) => c0.map((c1) => c1.map((c2) => c2.map((c3) => OBU.AOM_CDF(c3)))));
    this.TileCoeffBaseCdf = Default_Coeff_Base_Cdf.map((c0) => c0.map((c1) => c1.map((c2) => c2.map((c3) => OBU.AOM_CDF(c3)))));
    this.TileCoeffBrCdf = Default_Coeff_Br_Cdf.map((c0) => c0.map((c1) => c1.map((c2) => c2.map((c3) => OBU.AOM_CDF(c3)))));

    // i = 0..MV_CONTEXTS-1 and comp = 0..1
    this.TileMvJointCdf = OBU.AOM_CDF(Default_Mv_Joint_Cdf);
    this.TileMvClassCdf = Default_Mv_Class_Cdf.map((cdf) => OBU.AOM_CDF(cdf));
    this.TileMvClass0BitCdf = OBU.AOM_CDF(Default_Mv_Class0_Bit_Cdf);
    this.TileMvFrCdf = Default_Mv_Fr_Cdf.map((cdf) => OBU.AOM_CDF(cdf));
    this.TileMvClass0FrCdf = Default_Mv_Class0_Fr_Cdf.map((cdfs) => cdfs.map((cdf) => OBU.AOM_CDF(cdf)));
    this.TileMvClass0HpCdf = OBU.AOM_CDF(Default_Mv_Class0_Hp_Cdf);
    this.TileMvSignCdf = OBU.AOM_CDF(Default_Mv_Sign_Cdf);
    this.TileMvBitCdf = Default_Mv_Bit_Cdf.map((cdf) => OBU.AOM_CDF(cdf));
    this.TileMvHpCdf = OBU.AOM_CDF(Default_Mv_Hp_Cdf);
    this.TileDeltaLFMultiCdf = OBU.AOM_CDF(Default_Delta_Lf_Cdf);
  }

  load_cdfs(ctx: number, { b, h }: { b: BitReader, h: any }) {
    // this.YModeCdf = this.save_cdfs(ctx);
    // this.UVModeCflNotAllowedCdf = SavedCdfs[ctx].UVModeCflNotAllowedCdf.slice();
  }

  motion_field_estimation({ b, h }: { b: BitReader, h: any }) {

  }

  init_coeff_cdfs({ b, h }: { b: BitReader, h: any }) {
    let idx = 0;
    if (h.base_q_idx <= 20) {
      idx = 0;
    } else if (h.base_q_idx <= 60) {
      idx = 1;
    } else if (h.base_q_idx <= 120) {
      idx = 2;
    } else {
      idx = 3;
    }

    this.TxbSkipCdf = Default_Txb_Skip_Cdf[idx].map((c0) => c0.map((c1) => OBU.AOM_CDF(c1)));
    this.EobPt16Cdf = Default_Eob_Pt_16_Cdf[idx].map((c0) => c0.map((c1) => OBU.AOM_CDF(c1)));
    this.EobPt32Cdf = Default_Eob_Pt_32_Cdf[idx].map((c0) => c0.map((c1) => OBU.AOM_CDF(c1)));
    this.EobPt64Cdf = Default_Eob_Pt_64_Cdf[idx].map((c0) => c0.map((c1) => OBU.AOM_CDF(c1)));
    this.EobPt128Cdf = Default_Eob_Pt_128_Cdf[idx].map((c0) => c0.map((c1) => OBU.AOM_CDF(c1)));
    this.EobPt256Cdf = Default_Eob_Pt_256_Cdf[idx].map((c0) => c0.map((c1) => OBU.AOM_CDF(c1)));
    this.EobPt512Cdf = Default_Eob_Pt_512_Cdf[idx].map((c0) => OBU.AOM_CDF(c0));
    this.EobPt1024Cdf = Default_Eob_Pt_1024_Cdf[idx].map((c0) => OBU.AOM_CDF(c0));
    this.EobExtraCdf = Default_Eob_Extra_Cdf[idx].map((c0) => c0.map((c1) => c1.map((c2) => OBU.AOM_CDF(c2))));
    this.DcSignCdf = Default_Dc_Sign_Cdf[idx].map((c0) => c0.map((c1) => OBU.AOM_CDF(c1)));
    this.CoeffBaseEobCdf = Default_Coeff_Base_Eob_Cdf[idx].map((c0) => c0.map((c1) => c1.map((c2) => OBU.AOM_CDF(c2))));
    this.CoeffBaseCdf = Default_Coeff_Base_Cdf[idx].map((c0) => c0.map((c1) => c1.map((c2) => OBU.AOM_CDF(c2))));
    this.CoeffBrCdf = Default_Coeff_Br_Cdf[idx].map((c0) => c0.map((c1) => c1.map((c2) => OBU.AOM_CDF(c2))));
  }

  load_previous_segment_ids({ b, h }: { b: BitReader, h: any }) {
    let prevFrame = h.ref_frame_idx[h.primary_ref_frame];
    if (h.segmentation_enabled) {
      if (h[`RefMiCols[${prevFrame}]`] == h.MiCols && h[`RefMiRows[${prevFrame}]`] == h.MiRows) {
        for (let row = 0; row < h.MiRows; ++row)
          for (let col = 0; col < h.MiCols; ++col)
            h[`PrevSegmentIds[${row}][${col}]`] = h[`SavedSegmentIds[${prevFrame}][${row}][${col}]`];
      }
    } else {
      for (let row = 0; row < h.MiRows; ++row)
        for (let col = 0; col < h.MiCols; ++col)
          h[`PrevSegmentIds[${row}][${col}]`] = 0;
    }
  }

  //-?
  setup_past_independence({ b, h }: { b: BitReader, h: any }) {
    for (let i = 0; i < MAX_SEGMENTS; i++) {
      for (let j = 0; j < SEG_LVL_MAX; j++) {
        h[`FeatureData[${i}][${j}]`] = 0;
        h[`FeatureEnabled[${i}][${j}]`] = 0;
      }
    }

    for (let row = 0; row < h.MiRows; row++) {
      for (let col = 0; col < h.MiCols; col++) {
        h[`PrevSegmentIds[${row}][${col}]`] = 0;
      }
    }

    for (let ref = LAST_FRAME; ref <= ALTREF_FRAME; ++ref) {
      h[`GmType[${ref}]`] = IDENTITY;
      for (let i = 0; i <= 5; ++i) {
        h[`PrevGmParams[${ref}][${i}]`] = (i % 3) == 2 ? (1 << WARPEDMODEL_PREC_BITS) : 0;
      }
    }

    h.loop_filter_delta_enabled = 1;
    let loop_filter_ref_deltas = [1, 0, 0, 0, 0, -1, -1, -1];
    for (let i = 0; i < loop_filter_ref_deltas.length; ++i) {
      h[`loop_filter_ref_deltas[${i}]`] = loop_filter_ref_deltas[i];
    }
    h[`loop_filter_mode_deltas[0]`] = 0;
    h[`loop_filter_mode_deltas[1]`] = 0;
  };

  //-?
  load_previous() {

  };

  //-?
  get_qindex({ h }: { h: any }, ignoreDeltaQ: number, segmentId: number) {
    let qindex = h.base_q_idx;
    if (h.segmentation_enabled && h[`FeatureEnabled[${segmentId}][0]`])
      qindex += h[`FeatureData[${segmentId}][0]`];
    return this.Clip3(0, 255, qindex);
  };

  Clip1(_1: number) {

  }

  Clip3(low: number, high: number, value: number) {
    return value < low ? low : (value > high ? high : value);
  }

  reset_grain_params({ b, h }: { b: BitReader, h: any }) {
  }

  update_frame_buffers({ h }: { h: any }) {
    if (h.tg_end == undefined || h['TileRows'] == undefined || h['TileCols'] == undefined) return;

    let frameDecodingFinished = h.tg_end == h['TileRows'] * h['TileCols'] - 1;
    if (!frameDecodingFinished) return;

    let refIndex = 0;
    for (let mask = h.refresh_frame_flags; mask; mask = mask >> 1) {
      if (mask & 1) {
        this.RefFrameType[refIndex] = h;
      }
      ++refIndex;
    }
  }

  is_valid_seq_level_idx(seq_level_idx: number) {
    const SEQ_LEVEL_MAX = 31;
    const SEQ_LEVELS = 28;
    const SEQ_LEVEL_2_2 = 2;
    const SEQ_LEVEL_2_3 = 3;
    const SEQ_LEVEL_3_2 = 6;
    const SEQ_LEVEL_3_3 = 7;
    const SEQ_LEVEL_4_2 = 10;
    const SEQ_LEVEL_4_3 = 11;
    let valid = (seq_level_idx == SEQ_LEVEL_MAX ||
      (seq_level_idx < SEQ_LEVELS &&
        // The following levels are currently undefined.
        seq_level_idx != SEQ_LEVEL_2_2 && seq_level_idx != SEQ_LEVEL_2_3 &&
        seq_level_idx != SEQ_LEVEL_3_2 && seq_level_idx != SEQ_LEVEL_3_3 &&
        seq_level_idx != SEQ_LEVEL_4_2 && seq_level_idx != SEQ_LEVEL_4_3));
    if (!valid)
      throw Error("The given bitstream is not supported");
  }

  find_mv_stack(isCompound: number) {

  }

  find_warp_samples() {

  }

  predict_intra(_1: number, _2: number, _3: number, _4: number, _5: number, _6: number, _7: number, _8: number, _9: number, _10: number) {

  }
  predict_inter(_1: number, _2: number, _3: number, _4: number, _5: number, _6: number, _7: number) {

  }
  predict_palette(_1: number, _2: number, _3: number, _4: number, _5: number, _6: number) {

  }
  predict_chroma_from_luma(_1: number, _2: number, _3: number, _4: number) {

  }
  reconstruct(_1: number, _2: number, _3: number, _4: number) {

  }
  sort(arr: number, i1: number, i2: number) {

  }

  current_frame_buffer() {

  }

  av1_decode_tiles({ b, h }: { b: BitReader, h: any }) {
    const tile_cols = h['TileCols'];
    const tile_rows = h['TileRows'];

    let tile_buffers: any[][] = [];
    for (let row = 0; row < tile_rows; row++) {
      let tile_bs_buf: any[] = [];
      for (let col = 0; col < tile_cols; col++) {
        tile_bs_buf.push(undefined);
      }
      tile_buffers.push(tile_bs_buf);
    }
    let tile_rows_start = 0;
    let tile_rows_end;
    let tile_cols_start = 0;
    let tile_cols_end;
    let inv_col_order;
    let inv_row_order;
    let tile_row = 0;
    let tile_col = 0;
    let allow_update_cdf;
    let raw_data_end;

    const large_scale = 0;
    if (!large_scale) {
      tile_rows_start = 0;
      tile_rows_end = tile_rows;
      tile_cols_start = 0;
      tile_cols_end = tile_cols;
      inv_col_order = 0;
      inv_row_order = 0;
      allow_update_cdf = 1;
    }

    for (tile_row = tile_rows_start; tile_row < tile_rows_end; ++tile_row) {
      const row = inv_row_order ? tile_rows - 1 - tile_row : tile_row;
      for (tile_col = tile_cols_start; tile_col < tile_cols_end; ++tile_col) {
        const col = inv_col_order ? tile_cols - 1 - tile_col : tile_col;
        // const tile_data = pbi -> tile_data + row * tiles -> cols + col;
        const tile_bs_buf = tile_buffers[row][col];

      }
    }
  }
}