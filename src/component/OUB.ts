import { BitReader } from "./BitReader";

// 3. Symbols and abbreviated terms
const REFS_PER_FRAME = 7;
const TOTAL_REFS_PER_FRAME = 8;
const BLOCK_SIZE_GROUPS = 4;
const BLOCK_SIZES = 22;
const BLOCK_INVALID = 22;
const MAX_SB_SIZE = 128;
const MI_SIZE = 4;
const MI_SIZE_LOG2 = 2;
const MAX_TILE_WIDTH = 4096;
const MAX_TILE_AREA = 4096 * 2304;
const MAX_TILE_ROWS = 64;
const MAX_TILE_COLS = 64;
const INTRABC_DELAY_PIXELS = 256;
const INTRABC_DELAY_SB64 = 4;
const NUM_REF_FRAMES = 8;
const IS_INTER_CONTEXTS = 4;
const REF_CONTEXTS = 3;
const MAX_SEGMENTS = 8;
const SEGMENT_ID_CONTEXTS = 3;
const SEG_LVL_ALT_Q = 0;
const SEG_LVL_ALT_LF_Y_V = 1;
const SEG_LVL_REF_FRAME = 5;
const SEG_LVL_SKIP = 6;
const SEG_LVL_GLOBALMV = 7;
const SEG_LVL_MAX = 8;
const PLANE_TYPES = 2;
const TX_SIZE_CONTEXTS = 3;
const INTERP_FILTERS = 3;
const INTERP_FILTER_CONTEXTS = 16;
const SKIP_MODE_CONTEXTS = 3;
const SKIP_CONTEXTS = 3;
const PARTITION_CONTEXTS = 4;
const TX_SIZES = 5;
const TX_SIZES_ALL = 19;
const TX_MODES = 3;
const DCT_DCT = 0;
const ADST_DCT = 1;
const DCT_ADST = 2;
const ADST_ADST = 3;
const FLIPADST_DCT = 4;
const DCT_FLIPADST = 5;
const FLIPADST_FLIPADST = 6;
const ADST_FLIPADST = 7;
const FLIPADST_ADST = 8;
const IDTX = 9;
const V_DCT = 10;
const H_DCT = 11;
const V_ADST = 12;
const H_ADST = 13;
const V_FLIPADST = 14;
const H_FLIPADST = 15;
const TX_TYPES = 16;
const MB_MODE_COUNT = 17;
const INTRA_MODES = 13;
const UV_INTRA_MODES_CFL_NOT_ALLOWED = 13;
const UV_INTRA_MODES_CFL_ALLOWED = 14;
const COMPOUND_MODES = 8;
const COMPOUND_MODE_CONTEXTS = 8;
const COMP_NEWMV_CTXS = 5;
const NEW_MV_CONTEXTS = 6;
const ZERO_MV_CONTEXTS = 2;
const REF_MV_CONTEXTS = 6;
const DRL_MODE_CONTEXTS = 3;
const MV_CONTEXTS = 2;
const MV_INTRABC_CONTEXT = 1;
const MV_JOINTS = 4;
const MV_CLASSES = 11;
const CLASS0_SIZE = 2;
const MV_OFFSET_BITS = 10;
const MAX_LOOP_FILTER = 63;
const REF_SCALE_SHIFT = 14;
const SUBPEL_BITS = 4;
const SUBPEL_MASK = 15;
const SCALE_SUBPEL_BITS = 10;
const MV_BORDER = 128;
const PALETTE_COLOR_CONTEXTS = 5;
const PALETTE_MAX_COLOR_CONTEXT_HASH = 8;
const PALETTE_BLOCK_SIZE_CONTEXTS = 7;
const PALETTE_Y_MODE_CONTEXTS = 3;
const PALETTE_UV_MODE_CONTEXTS = 2;
const PALETTE_SIZES = 7;
const PALETTE_COLORS = 8;
const PALETTE_NUM_NEIGHBORS = 3;
const DELTA_Q_SMALL = 3;
const DELTA_LF_SMALL = 3;
const QM_TOTAL_SIZE = 3344;
const MAX_ANGLE_DELTA = 3;
const DIRECTIONAL_MODES = 8;
const ANGLE_STEP = 3;
const TX_SET_TYPES_INTRA = 3;
const TX_SET_TYPES_INTER = 4;
const WARPEDMODEL_PREC_BITS = 16;
const IDENTITY = 0;
const TRANSLATION = 1;
const ROTZOOM = 2;
const AFFINE = 3;
const GM_ABS_TRANS_BITS = 12;
const GM_ABS_TRANS_ONLY_BITS = 9;
const GM_ABS_ALPHA_BITS = 12;
const DIV_LUT_PREC_BITS = 14;
const DIV_LUT_BITS = 8;
const DIV_LUT_NUM = 257;
const MOTION_MODES = 3;
const SIMPLE = 0;
const OBMC = 1;
const LOCALWARP = 2;
const LEAST_SQUARES_SAMPLES_MAX = 8;
const LS_MV_MAX = 256;
const WARPEDMODEL_TRANS_CLAMP = 1;
const WARPEDMODEL_NONDIAGAFFINE_CLAMP = 1;
const WARPEDPIXEL_PREC_SHIFTS = 1;
const WARPEDDIFF_PREC_BITS = 10;
const GM_ALPHA_PREC_BITS = 15;
const GM_TRANS_PREC_BITS = 6;
const GM_TRANS_ONLY_PREC_BITS = 3;
const INTERINTRA_MODES = 4;
const MASK_MASTER_SIZE = 64;
const SEGMENT_ID_PREDICTED_CONTEXTS = 3;
const FWD_REFS = 4;
const BWD_REFS = 3;
const SINGLE_REFS = 7;
const UNIDIR_COMP_REFS = 4;
const COMPOUND_TYPES = 2;
const CFL_JOINT_SIGNS = 8;
const CFL_ALPHABET_SIZE = 16;
const COMP_INTER_CONTEXTS = 5;
const COMP_REF_TYPE_CONTEXTS = 5;
const CFL_ALPHA_CONTEXTS = 6;
const INTRA_MODE_CONTEXTS = 5;
const COMP_GROUP_IDX_CONTEXTS = 6;
const COMPOUND_IDX_CONTEXTS = 6;
const INTRA_EDGE_KERNELS = 3;
const INTRA_EDGE_TAPS = 5;
const FRAME_LF_COUNT = 4;
const MAX_VARTX_DEPTH = 2;
const TXFM_PARTITION_CONTEXTS = 21;
const REF_CAT_LEVEL = 640;
const MAX_REF_MV_STACK_SIZE = 8;
const MFMV_STACK_SIZE = 3;
const MAX_TX_DEPTH = 2;
const WEDGE_TYPES = 16;
const FILTER_BITS = 7;
const WIENER_COEFFS = 3;
const SGRPROJ_PARAMS_BITS = 4;
const SGRPROJ_PRJ_SUBEXP_K = 4;
const SGRPROJ_PRJ_BITS = 7;
const SGRPROJ_RST_BITS = 4;
const SGRPROJ_MTABLE_BITS = 20;
const SGRPROJ_RECIP_BITS = 12;
const SGRPROJ_SGR_BITS = 8;
const EC_PROB_SHIFT = 6;
const EC_MIN_PROB = 4;
const SELECT_SCREEN_CONTENT_TOOLS = 2;
const SELECT_INTEGER_MV = 2;
const RESTORATION_TILESIZE_MAX = 256;
const MAX_FRAME_DISTANCE = 31;
const MAX_OFFSET_WIDTH = 8;
const MAX_OFFSET_HEIGHT = 0;
const WARP_PARAM_REDUCE_BITS = 6;
const NUM_BASE_LEVELS = 2;
const COEFF_BASE_RANGE = 12;
const BR_CDF_SIZE = 4;
const SIG_COEF_CONTEXTS_EOB = 4;
const SIG_COEF_CONTEXTS_2D = 26;
const SIG_COEF_CONTEXTS = 42;
const SIG_REF_DIFF_OFFSET_NUM = 5;
const SUPERRES_NUM = 8;
const SUPERRES_DENOM_MIN = 9;
const SUPERRES_DENOM_BITS = 3;
const SUPERRES_FILTER_BITS = 6;
const SUPERRES_FILTER_SHIFTS = 1;
const SUPERRES_FILTER_TAPS = 8;
const SUPERRES_FILTER_OFFSET = 3;
const SUPERRES_SCALE_BITS = 14;
const SUPERRES_SCALE_MASK = (1 << 14) - 1;
const SUPERRES_EXTRA_BITS = 8;
const TXB_SKIP_CONTEXTS = 13;
const EOB_COEF_CONTEXTS = 9;
const DC_SIGN_CONTEXTS = 3;
const LEVEL_CONTEXTS = 21;
const TX_CLASS_2D = 0;
const TX_CLASS_HORIZ = 1;
const TX_CLASS_VERT = 2;
const REFMVS_LIMIT = (1 << 12) - 1;
const INTRA_FILTER_SCALE_BITS = 4;
const INTRA_FILTER_MODES = 5;
const COEFF_CDF_Q_CTXS = 4;
const PRIMARY_REF_NONE = 7;
const BUFFER_POOL_MAX_SIZE = 10;

// 4.7. Mathematical functions
function Round2(x: number, n: number) {
  if (n == 0)
    return x;
  return (x + (1 << (n - 1))) >> n;
}

function CeilLog2(x: number) {
  if (x < 2)
    return 0;
  let i = 1;
  let p = 2;
  while (p < x) {
    i++;
    p = p << 1;
  }
  return i;
}

// 6.2.2. OBU header semantics
export const OBU_SEQUENCE_HEADER = 1;
export const OBU_TEMPORAL_DELIMITER = 2;
export const OBU_FRAME_HEADER = 3;
export const OBU_TILE_GROUP = 4;
export const OBU_METADATA = 5;
export const OBU_FRAME = 6;
export const OBU_REDUNDANT_FRAME_HEADER = 7;
export const OBU_TILE_LIST = 8;
export const OBU_PADDING = 9;

// 6.4.2. Color config semantics
const CP_BT_709 = 1;
const CP_UNSPECIFIED = 2;
const CP_BT_470_M = 4;
const CP_BT_470_B_G = 5;
const CP_BT_601 = 6;
const CP_SMPTE_240 = 7;
const CP_GENERIC_FILM = 8;
const CP_BT_2020 = 9;
const CP_XYZ = 10;
const CP_SMPTE_431 = 11;
const CP_SMPTE_432 = 12;
const CP_EBU_3213 = 22;

const TC_RESERVED_0 = 0;
const TC_BT_709 = 1;
const TC_UNSPECIFIED = 2;
const TC_RESERVED_3 = 3;
const TC_BT_470_M = 4;
const TC_BT_470_B_G = 5;
const TC_BT_601 = 6;
const TC_SMPTE_240 = 7;
const TC_LINEAR = 8;
const TC_LOG_100 = 9;
const TC_LOG_100_SQRT10 = 10;
const TC_IEC_61966 = 11;
const TC_BT_1361 = 12;
const TC_SRGB = 13;
const TC_BT_2020_10_BIT = 14;
const TC_BT_2020_12_BIT = 15;
const TC_SMPTE_2084 = 16;
const TC_SMPTE_428 = 17;
const TC_HLG = 18;

const MC_IDENTITY = 0;
const MC_BT_709 = 1;
const MC_UNSPECIFIED = 2;
const MC_RESERVED_3 = 3;
const MC_FCC = 4;
const MC_BT_470_B_G = 5;
const MC_BT_601 = 6;
const MC_SMPTE_240 = 7;
const MC_SMPTE_YCGCO = 8;
const MC_BT_2020_NCL = 9;
const MC_BT_2020_CL = 10;
const MC_SMPTE_2085 = 11;
const MC_CHROMAT_NCL = 12;
const MC_CHROMAT_CL = 13;
const MC_ICTCP = 14;

const CSP_UNKNOWN = 0;
const CSP_VERTICAL = 1;
const CSP_COLOCATED = 2;
const CSP_RESERVED = 3;

// 6.8.2. Uncompressed header semantics
const KEY_FRAME = 0;
const INTER_FRAME = 1;
const INTRA_ONLY_FRAME = 2;
const SWITCH_FRAME = 3;

// 6.8.9. Interpolation filter semantics
const EIGHTTAP = 0;
const EIGHTTAP_SMOOTH = 1;
const EIGHTTAP_SHARP = 2;
const BILINEAR = 3;
const SWITCHABLE = 4;

// 6.8.21. TX mode semantics
const ONLY_4X4 = 0;         // 逆变换将只使用4x4变换
const TX_MODE_LARGEST = 1;  // 逆变换将使用适合块内的最大变换大小
const TX_MODE_SELECT = 2;   // 为每个块显式指定转换大小的选择

// 6.10.4. Decode partition semantics
const PARTITION_NONE = 0;
const PARTITION_HORZ = 1;
const PARTITION_VERT = 2;
const PARTITION_SPLIT = 3;
const PARTITION_HORZ_A = 4;
const PARTITION_HORZ_B = 5;
const PARTITION_VERT_A = 6;
const PARTITION_VERT_B = 7;
const PARTITION_HORZ_4 = 8;
const PARTITION_VERT_4 = 9;

const BLOCK_4X4 = 0;
const BLOCK_4X8 = 1;
const BLOCK_8X4 = 2;
const BLOCK_8X8 = 3;
const BLOCK_8X16 = 4;
const BLOCK_16X8 = 5;
const BLOCK_16X16 = 6;
const BLOCK_16X32 = 7;
const BLOCK_32X16 = 8;
const BLOCK_32X32 = 9;
const BLOCK_32X64 = 10;
const BLOCK_64X32 = 11;
const BLOCK_64X64 = 12;
const BLOCK_64X128 = 13;
const BLOCK_128X64 = 14;
const BLOCK_128X128 = 15;
const BLOCK_4X16 = 16;
const BLOCK_16X4 = 17;
const BLOCK_8X32 = 18;
const BLOCK_32X8 = 19;
const BLOCK_16X64 = 20;
const BLOCK_64X16 = 21;

// 6.10.6. Intra frame mode info semantics
const DC_PRED = 0;
const V_PRED = 1;
const H_PRED = 2;
const D45_PRED = 3;
const D135_PRED = 4;
const D113_PRED = 5
const D157_PRED = 6;
const D203_PRED = 7;
const D67_PRED = 8;
const SMOOTH_PRED = 9;
const SMOOTH_V_PRED = 10;
const SMOOTH_H_PRED = 11;
const PAETH_PRED = 12;
const UV_CFL_PRED = 13;

// 6.10.15. Loop restoration params semantics
const RESTORE_NONE = 0;
const RESTORE_SWITCHABLE = 3;
const RESTORE_WIENER = 1;
const RESTORE_SGRPROJ = 2;

// 6.10.16. TX size semantics
const TX_4X4 = 0;
const TX_8X8 = 1;
const TX_16X16 = 2;
const TX_32X32 = 3;
const TX_64X64 = 4;
const TX_4X8 = 5;
const TX_8X4 = 6;
const TX_8X16 = 7;
const TX_16X8 = 8;
const TX_16X32 = 9;
const TX_32X16 = 10;
const TX_32X64 = 11;
const TX_64X32 = 12;
const TX_4X16 = 13;
const TX_16X4 = 14;
const TX_8X32 = 15;
const TX_32X8 = 16;
const TX_16X64 = 17;
const TX_64X16 = 18;

// 6.10.19. Transform type semantics
/** +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |  is_inter | set | Name of transform set |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  | Don’t care|  0  |     TX_SET_DCTONLY    |
 *  |     0     |  1  |     TX_SET_INTRA_1    |
 *  |     0     |  2  |     TX_SET_INTRA_2    |
 *  |     1     |  1  |     TX_SET_INTER_1    |
 *  |     1     |  2  |     TX_SET_INTER_2    |
 *  |     1     |  3  |     TX_SET_INTER_3    |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 */
const TX_SET_DCTONLY = 0;
const TX_SET_INTRA_1 = 1;
const TX_SET_INTRA_2 = 2;
const TX_SET_INTER_1 = 1;
const TX_SET_INTER_2 = 2;
const TX_SET_INTER_3 = 3;

// 6.10.22. Inter block mode info semantics
const NEARESTMV = 14;
const NEARMV = 15;
const GLOBALMV = 16;
const NEWMV = 17;
const NEAREST_NEARESTMV = 18;
const NEAR_NEARMV = 19;
const NEAREST_NEWMV = 20;
const NEW_NEARESTMV = 21;
const NEAR_NEWMV = 22;
const NEW_NEARMV = 23;
const GLOBAL_GLOBALMV = 24;
const NEW_NEWMV = 25;

// 6.10.24. Ref frames semantics
const SINGLE_REFERENCE = 0;
const COMPOUND_REFERENCE = 1;

const UNIDIR_COMP_REFERENCE = 0;  // Both reference frames from the same group
const BIDIR_COMP_REFERENCE = 1;   // One from Group 1 and one from Group 2

const NONE = -1;
const INTRA_FRAME = 0;
const LAST_FRAME = 1;
const LAST2_FRAME = 2;
const LAST3_FRAME = 3;
const GOLDEN_FRAME = 4;
const BWDREF_FRAME = 5;
const ALTREF2_FRAME = 6;
const ALTREF_FRAME = 7;

// 6.10.27. Read inter intra semantics
const II_DC_PRED = 0;
const II_V_PRED = 1;
const II_H_PRED = 2;
const II_SMOOTH_PRED = 3;

// 6.10.28. Read compound type semantics
const COMPOUND_WEDGE = 0;
const COMPOUND_DIFFWTD = 1;
const COMPOUND_AVERAGE = 2;
const COMPOUND_INTRA = 3;
const COMPOUND_DISTANCE = 4;

// 6.10.29. MV semantics
/** +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  | mv_joint | Name of mv_joint | Changes row | Changes col |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |    0     |  MV_JOINT_ZERO   |     No      |     No      |
 *  |    1     |  MV_JOINT_HNZVZ  |     No      |     Yes     |
 *  |    2     |  MV_JOINT_HZVNZ  |     Yes     |     No      |
 *  |    3     |  MV_JOINT_HNZVNZ |     Yes     |     Yes     |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 */
const MV_JOINT_ZERO = 0;
const MV_JOINT_HNZVZ = 1;
const MV_JOINT_HZVNZ = 2;
const MV_JOINT_HNZVNZ = 3;

// 6.10.30. MV component semantics
const MV_CLASS_0 = 0;
const MV_CLASS_1 = 1;
const MV_CLASS_2 = 2;
const MV_CLASS_3 = 3;
const MV_CLASS_4 = 4;
const MV_CLASS_5 = 5;
const MV_CLASS_6 = 6;
const MV_CLASS_7 = 7;
const MV_CLASS_8 = 8;
const MV_CLASS_9 = 9;
const MV_CLASS_10 = 10;

// 6.10.36. Read CFL alphas semantics
const CFL_SIGN_ZERO = 0;
const CFL_SIGN_NEG = 1;
const CFL_SIGN_POS = 2;

// 9.2. Scan tables
const Default_Scan_4x4 = [
  0, 1, 4, 8,
  5, 2, 3, 6,
  9, 12, 13, 10,
  7, 11, 14, 15];
const Mcol_Scan_4x4 = [
  0, 4, 8, 12,
  1, 5, 9, 13,
  2, 6, 10, 14,
  3, 7, 11, 15];
const Mrow_Scan_4x4 = [
  0, 1, 2, 3,
  4, 5, 6, 7,
  8, 9, 10, 11,
  12, 13, 14, 15];
const Default_Scan_4x8 = [
  0, 1, 4, 2, 5, 8, 3, 6, 9, 12, 7, 10, 13, 16, 11, 14,
  17, 20, 15, 18, 21, 24, 19, 22, 25, 28, 23, 26, 29, 27, 30, 31];
const Mcol_Scan_4x8 = [
  0, 4, 8, 12, 16, 20, 24, 28, 1, 5, 9, 13, 17, 21, 25, 29,
  2, 6, 10, 14, 18, 22, 26, 30, 3, 7, 11, 15, 19, 23, 27, 31];
const Mrow_Scan_4x8 = [
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
  16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31];
const Default_Scan_8x4 = [
  0, 8, 1, 16, 9, 2, 24, 17, 10, 3, 25, 18, 11, 4, 26, 19,
  12, 5, 27, 20, 13, 6, 28, 21, 14, 7, 29, 22, 15, 30, 23, 31];
const Mcol_Scan_8x4 = [
  0, 8, 16, 24, 1, 9, 17, 25, 2, 10, 18, 26, 3, 11, 19, 27,
  4, 12, 20, 28, 5, 13, 21, 29, 6, 14, 22, 30, 7, 15, 23, 31];
const Mrow_Scan_8x4 = [
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
  16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31];
const Default_Scan_8x8 = [
  0, 1, 8, 16, 9, 2, 3, 10,
  17, 24, 32, 25, 18, 11, 4, 5,
  12, 19, 26, 33, 40, 48, 41, 34,
  27, 20, 13, 6, 7, 14, 21, 28,
  35, 42, 49, 56, 57, 50, 43, 36,
  29, 22, 15, 23, 30, 37, 44, 51,
  58, 59, 52, 45, 38, 31, 39, 46,
  53, 60, 61, 54, 47, 55, 62, 63];
const Mcol_Scan_8x8 = [
  0, 8, 16, 24, 32, 40, 48, 56,
  1, 9, 17, 25, 33, 41, 49, 57,
  2, 10, 18, 26, 34, 42, 50, 58,
  3, 11, 19, 27, 35, 43, 51, 59,
  4, 12, 20, 28, 36, 44, 52, 60,
  5, 13, 21, 29, 37, 45, 53, 61,
  6, 14, 22, 30, 38, 46, 54, 62,
  7, 15, 23, 31, 39, 47, 55, 63];
const Mrow_Scan_8x8 = [
  0, 1, 2, 3, 4, 5, 6, 7,
  8, 9, 10, 11, 12, 13, 14, 15,
  16, 17, 18, 19, 20, 21, 22, 23,
  24, 25, 26, 27, 28, 29, 30, 31,
  32, 33, 34, 35, 36, 37, 38, 39,
  40, 41, 42, 43, 44, 45, 46, 47,
  48, 49, 50, 51, 52, 53, 54, 55,
  56, 57, 58, 59, 60, 61, 62, 63];
const Default_Scan_8x16 = [
  0, 1, 8, 2, 9, 16, 3, 10, 17, 24, 4, 11, 18, 25, 32,
  5, 12, 19, 26, 33, 40, 6, 13, 20, 27, 34, 41, 48, 7, 14,
  21, 28, 35, 42, 49, 56, 15, 22, 29, 36, 43, 50, 57, 64, 23,
  30, 37, 44, 51, 58, 65, 72, 31, 38, 45, 52, 59, 66, 73, 80,
  39, 46, 53, 60, 67, 74, 81, 88, 47, 54, 61, 68, 75, 82, 89,
  96, 55, 62, 69, 76, 83, 90, 97, 104, 63, 70, 77, 84, 91, 98,
  105, 112, 71, 78, 85, 92, 99, 106, 113, 120, 79, 86, 93, 100, 107,
  114, 121, 87, 94, 101, 108, 115, 122, 95, 102, 109, 116, 123, 103, 110,
  117, 124, 111, 118, 125, 119, 126, 127];
const Mcol_Scan_8x16 = [
  0, 8, 16, 24, 32, 40, 48, 56, 64, 72, 80, 88, 96, 104, 112, 120,
  1, 9, 17, 25, 33, 41, 49, 57, 65, 73, 81, 89, 97, 105, 113, 121,
  2, 10, 18, 26, 34, 42, 50, 58, 66, 74, 82, 90, 98, 106, 114, 122,
  3, 11, 19, 27, 35, 43, 51, 59, 67, 75, 83, 91, 99, 107, 115, 123,
  4, 12, 20, 28, 36, 44, 52, 60, 68, 76, 84, 92, 100, 108, 116, 124,
  5, 13, 21, 29, 37, 45, 53, 61, 69, 77, 85, 93, 101, 109, 117, 125,
  6, 14, 22, 30, 38, 46, 54, 62, 70, 78, 86, 94, 102, 110, 118, 126,
  7, 15, 23, 31, 39, 47, 55, 63, 71, 79, 87, 95, 103, 111, 119, 127];
const Mrow_Scan_8x16 = [
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,
  15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29,
  30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44,
  45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,
  60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74,
  75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89,
  90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104,
  105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,
  120, 121, 122, 123, 124, 125, 126, 127];
const Default_Scan_16x8 = [
  0, 16, 1, 32, 17, 2, 48, 33, 18, 3, 64, 49, 34, 19, 4, 80,
  65, 50, 35, 20, 5, 96, 81, 66, 51, 36, 21, 6, 112, 97, 82, 67,
  52, 37, 22, 7, 113, 98, 83, 68, 53, 38, 23, 8, 114, 99, 84, 69,
  54, 39, 24, 9, 115, 100, 85, 70, 55, 40, 25, 10, 116, 101, 86, 71,
  56, 41, 26, 11, 117, 102, 87, 72, 57, 42, 27, 12, 118, 103, 88, 73,
  58, 43, 28, 13, 119, 104, 89, 74, 59, 44, 29, 14, 120, 105, 90, 75,
  60, 45, 30, 15, 121, 106, 91, 76, 61, 46, 31, 122, 107, 92, 77, 62,
  47, 123, 108, 93, 78, 63, 124, 109, 94, 79, 125, 110, 95, 126, 111, 127];
const Mcol_Scan_16x8 = [
  0, 16, 32, 48, 64, 80, 96, 112, 1, 17, 33, 49, 65, 81, 97, 113,
  2, 18, 34, 50, 66, 82, 98, 114, 3, 19, 35, 51, 67, 83, 99, 115,
  4, 20, 36, 52, 68, 84, 100, 116, 5, 21, 37, 53, 69, 85, 101, 117,
  6, 22, 38, 54, 70, 86, 102, 118, 7, 23, 39, 55, 71, 87, 103, 119,
  8, 24, 40, 56, 72, 88, 104, 120, 9, 25, 41, 57, 73, 89, 105, 121,
  10, 26, 42, 58, 74, 90, 106, 122, 11, 27, 43, 59, 75, 91, 107, 123,
  12, 28, 44, 60, 76, 92, 108, 124, 13, 29, 45, 61, 77, 93, 109, 125,
  14, 30, 46, 62, 78, 94, 110, 126, 15, 31, 47, 63, 79, 95, 111, 127];
const Mrow_Scan_16x8 = [
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,
  15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29,
  30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44,
  45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,
  60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74,
  75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89,
  90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104,
  105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,
  120, 121, 122, 123, 124, 125, 126, 127];
const Default_Scan_16x16 = [
  0, 1, 16, 32, 17, 2, 3, 18, 33, 48, 64, 49, 34, 19, 4, 5,
  20, 35, 50, 65, 80, 96, 81, 66, 51, 36, 21, 6, 7, 22, 37, 52,
  67, 82, 97, 112, 128, 113, 98, 83, 68, 53, 38, 23, 8, 9, 24, 39,
  54, 69, 84, 99, 114, 129, 144, 160, 145, 130, 115, 100, 85, 70, 55, 40,
  25, 10, 11, 26, 41, 56, 71, 86, 101, 116, 131, 146, 161, 176, 192, 177,
  162, 147, 132, 117, 102, 87, 72, 57, 42, 27, 12, 13, 28, 43, 58, 73,
  88, 103, 118, 133, 148, 163, 178, 193, 208, 224, 209, 194, 179, 164, 149, 134,
  119, 104, 89, 74, 59, 44, 29, 14, 15, 30, 45, 60, 75, 90, 105, 120,
  135, 150, 165, 180, 195, 210, 225, 240, 241, 226, 211, 196, 181, 166, 151, 136,
  121, 106, 91, 76, 61, 46, 31, 47, 62, 77, 92, 107, 122, 137, 152, 167,
  182, 197, 212, 227, 242, 243, 228, 213, 198, 183, 168, 153, 138, 123, 108, 93,
  78, 63, 79, 94, 109, 124, 139, 154, 169, 184, 199, 214, 229, 244, 245, 230,
  215, 200, 185, 170, 155, 140, 125, 110, 95, 111, 126, 141, 156, 171, 186, 201,
  216, 231, 246, 247, 232, 217, 202, 187, 172, 157, 142, 127, 143, 158, 173, 188,
  203, 218, 233, 248, 249, 234, 219, 204, 189, 174, 159, 175, 190, 205, 220, 235,
  250, 251, 236, 221, 206, 191, 207, 222, 237, 252, 253, 238, 223, 239, 254, 255];
const Mcol_Scan_16x16 = [
  0, 16, 32, 48, 64, 80, 96, 112, 128, 144, 160, 176, 192, 208, 224, 240,
  1, 17, 33, 49, 65, 81, 97, 113, 129, 145, 161, 177, 193, 209, 225, 241,
  2, 18, 34, 50, 66, 82, 98, 114, 130, 146, 162, 178, 194, 210, 226, 242,
  3, 19, 35, 51, 67, 83, 99, 115, 131, 147, 163, 179, 195, 211, 227, 243,
  4, 20, 36, 52, 68, 84, 100, 116, 132, 148, 164, 180, 196, 212, 228, 244,
  5, 21, 37, 53, 69, 85, 101, 117, 133, 149, 165, 181, 197, 213, 229, 245,
  6, 22, 38, 54, 70, 86, 102, 118, 134, 150, 166, 182, 198, 214, 230, 246,
  7, 23, 39, 55, 71, 87, 103, 119, 135, 151, 167, 183, 199, 215, 231, 247,
  8, 24, 40, 56, 72, 88, 104, 120, 136, 152, 168, 184, 200, 216, 232, 248,
  9, 25, 41, 57, 73, 89, 105, 121, 137, 153, 169, 185, 201, 217, 233, 249,
  10, 26, 42, 58, 74, 90, 106, 122, 138, 154, 170, 186, 202, 218, 234, 250,
  11, 27, 43, 59, 75, 91, 107, 123, 139, 155, 171, 187, 203, 219, 235, 251,
  12, 28, 44, 60, 76, 92, 108, 124, 140, 156, 172, 188, 204, 220, 236, 252,
  13, 29, 45, 61, 77, 93, 109, 125, 141, 157, 173, 189, 205, 221, 237, 253,
  14, 30, 46, 62, 78, 94, 110, 126, 142, 158, 174, 190, 206, 222, 238, 254,
  15, 31, 47, 63, 79, 95, 111, 127, 143, 159, 175, 191, 207, 223, 239, 255];
const Mrow_Scan_16x16 = [
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,
  15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29,
  30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44,
  45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,
  60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74,
  75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89,
  90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104,
  105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,
  120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134,
  135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149,
  150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164,
  165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179,
  180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194,
  195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209,
  210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224,
  225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239,
  240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254,
  255];
const Default_Scan_16x32 = [
  0, 1, 16, 2, 17, 32, 3, 18, 33, 48, 4, 19, 34, 49, 64,
  5, 20, 35, 50, 65, 80, 6, 21, 36, 51, 66, 81, 96, 7, 22,
  37, 52, 67, 82, 97, 112, 8, 23, 38, 53, 68, 83, 98, 113, 128,
  9, 24, 39, 54, 69, 84, 99, 114, 129, 144, 10, 25, 40, 55, 70,
  85, 100, 115, 130, 145, 160, 11, 26, 41, 56, 71, 86, 101, 116, 131,
  146, 161, 176, 12, 27, 42, 57, 72, 87, 102, 117, 132, 147, 162, 177,
  192, 13, 28, 43, 58, 73, 88, 103, 118, 133, 148, 163, 178, 193, 208,
  14, 29, 44, 59, 74, 89, 104, 119, 134, 149, 164, 179, 194, 209, 224,
  15, 30, 45, 60, 75, 90, 105, 120, 135, 150, 165, 180, 195, 210, 225,
  240, 31, 46, 61, 76, 91, 106, 121, 136, 151, 166, 181, 196, 211, 226,
  241, 256, 47, 62, 77, 92, 107, 122, 137, 152, 167, 182, 197, 212, 227,
  242, 257, 272, 63, 78, 93, 108, 123, 138, 153, 168, 183, 198, 213, 228,
  243, 258, 273, 288, 79, 94, 109, 124, 139, 154, 169, 184, 199, 214, 229,
  244, 259, 274, 289, 304, 95, 110, 125, 140, 155, 170, 185, 200, 215, 230,
  245, 260, 275, 290, 305, 320, 111, 126, 141, 156, 171, 186, 201, 216, 231,
  246, 261, 276, 291, 306, 321, 336, 127, 142, 157, 172, 187, 202, 217, 232,
  247, 262, 277, 292, 307, 322, 337, 352, 143, 158, 173, 188, 203, 218, 233,
  248, 263, 278, 293, 308, 323, 338, 353, 368, 159, 174, 189, 204, 219, 234,
  249, 264, 279, 294, 309, 324, 339, 354, 369, 384, 175, 190, 205, 220, 235,
  250, 265, 280, 295, 310, 325, 340, 355, 370, 385, 400, 191, 206, 221, 236,
  251, 266, 281, 296, 311, 326, 341, 356, 371, 386, 401, 416, 207, 222, 237,
  252, 267, 282, 297, 312, 327, 342, 357, 372, 387, 402, 417, 432, 223, 238,
  253, 268, 283, 298, 313, 328, 343, 358, 373, 388, 403, 418, 433, 448, 239,
  254, 269, 284, 299, 314, 329, 344, 359, 374, 389, 404, 419, 434, 449, 464,
  255, 270, 285, 300, 315, 330, 345, 360, 375, 390, 405, 420, 435, 450, 465,
  480, 271, 286, 301, 316, 331, 346, 361, 376, 391, 406, 421, 436, 451, 466,
  481, 496, 287, 302, 317, 332, 347, 362, 377, 392, 407, 422, 437, 452, 467,
  482, 497, 303, 318, 333, 348, 363, 378, 393, 408, 423, 438, 453, 468, 483,
  498, 319, 334, 349, 364, 379, 394, 409, 424, 439, 454, 469, 484, 499, 335,
  350, 365, 380, 395, 410, 425, 440, 455, 470, 485, 500, 351, 366, 381, 396,
  411, 426, 441, 456, 471, 486, 501, 367, 382, 397, 412, 427, 442, 457, 472,
  487, 502, 383, 398, 413, 428, 443, 458, 473, 488, 503, 399, 414, 429, 444,
  459, 474, 489, 504, 415, 430, 445, 460, 475, 490, 505, 431, 446, 461, 476,
  491, 506, 447, 462, 477, 492, 507, 463, 478, 493, 508, 479, 494, 509, 495,
  510, 511];
const Default_Scan_32x16 = [
  0, 32, 1, 64, 33, 2, 96, 65, 34, 3, 128, 97, 66, 35, 4,
  160, 129, 98, 67, 36, 5, 192, 161, 130, 99, 68, 37, 6, 224, 193,
  162, 131, 100, 69, 38, 7, 256, 225, 194, 163, 132, 101, 70, 39, 8,
  288, 257, 226, 195, 164, 133, 102, 71, 40, 9, 320, 289, 258, 227, 196,
  165, 134, 103, 72, 41, 10, 352, 321, 290, 259, 228, 197, 166, 135, 104,
  73, 42, 11, 384, 353, 322, 291, 260, 229, 198, 167, 136, 105, 74, 43,
  12, 416, 385, 354, 323, 292, 261, 230, 199, 168, 137, 106, 75, 44, 13,
  448, 417, 386, 355, 324, 293, 262, 231, 200, 169, 138, 107, 76, 45, 14,
  480, 449, 418, 387, 356, 325, 294, 263, 232, 201, 170, 139, 108, 77, 46,
  15, 481, 450, 419, 388, 357, 326, 295, 264, 233, 202, 171, 140, 109, 78,
  47, 16, 482, 451, 420, 389, 358, 327, 296, 265, 234, 203, 172, 141, 110,
  79, 48, 17, 483, 452, 421, 390, 359, 328, 297, 266, 235, 204, 173, 142,
  111, 80, 49, 18, 484, 453, 422, 391, 360, 329, 298, 267, 236, 205, 174,
  143, 112, 81, 50, 19, 485, 454, 423, 392, 361, 330, 299, 268, 237, 206,
  175, 144, 113, 82, 51, 20, 486, 455, 424, 393, 362, 331, 300, 269, 238,
  207, 176, 145, 114, 83, 52, 21, 487, 456, 425, 394, 363, 332, 301, 270,
  239, 208, 177, 146, 115, 84, 53, 22, 488, 457, 426, 395, 364, 333, 302,
  271, 240, 209, 178, 147, 116, 85, 54, 23, 489, 458, 427, 396, 365, 334,
  303, 272, 241, 210, 179, 148, 117, 86, 55, 24, 490, 459, 428, 397, 366,
  335, 304, 273, 242, 211, 180, 149, 118, 87, 56, 25, 491, 460, 429, 398,
  367, 336, 305, 274, 243, 212, 181, 150, 119, 88, 57, 26, 492, 461, 430,
  399, 368, 337, 306, 275, 244, 213, 182, 151, 120, 89, 58, 27, 493, 462,
  431, 400, 369, 338, 307, 276, 245, 214, 183, 152, 121, 90, 59, 28, 494,
  463, 432, 401, 370, 339, 308, 277, 246, 215, 184, 153, 122, 91, 60, 29,
  495, 464, 433, 402, 371, 340, 309, 278, 247, 216, 185, 154, 123, 92, 61,
  30, 496, 465, 434, 403, 372, 341, 310, 279, 248, 217, 186, 155, 124, 93,
  62, 31, 497, 466, 435, 404, 373, 342, 311, 280, 249, 218, 187, 156, 125,
  94, 63, 498, 467, 436, 405, 374, 343, 312, 281, 250, 219, 188, 157, 126,
  95, 499, 468, 437, 406, 375, 344, 313, 282, 251, 220, 189, 158, 127, 500,
  469, 438, 407, 376, 345, 314, 283, 252, 221, 190, 159, 501, 470, 439, 408,
  377, 346, 315, 284, 253, 222, 191, 502, 471, 440, 409, 378, 347, 316, 285,
  254, 223, 503, 472, 441, 410, 379, 348, 317, 286, 255, 504, 473, 442, 411,
  380, 349, 318, 287, 505, 474, 443, 412, 381, 350, 319, 506, 475, 444, 413,
  382, 351, 507, 476, 445, 414, 383, 508, 477, 446, 415, 509, 478, 447, 510,
  479, 511];
const Default_Scan_32x32 = [
  0, 1, 32, 64, 33, 2, 3, 34, 65, 96, 128, 97, 66,
  35, 4, 5, 36, 67, 98, 129, 160, 192, 161, 130, 99, 68,
  37, 6, 7, 38, 69, 100, 131, 162, 193, 224, 256, 225, 194,
  163, 132, 101, 70, 39, 8, 9, 40, 71, 102, 133, 164, 195,
  226, 257, 288, 320, 289, 258, 227, 196, 165, 134, 103, 72, 41,
  10, 11, 42, 73, 104, 135, 166, 197, 228, 259, 290, 321, 352,
  384, 353, 322, 291, 260, 229, 198, 167, 136, 105, 74, 43, 12,
  13, 44, 75, 106, 137, 168, 199, 230, 261, 292, 323, 354, 385,
  416, 448, 417, 386, 355, 324, 293, 262, 231, 200, 169, 138, 107,
  76, 45, 14, 15, 46, 77, 108, 139, 170, 201, 232, 263, 294,
  325, 356, 387, 418, 449, 480, 512, 481, 450, 419, 388, 357, 326,
  295, 264, 233, 202, 171, 140, 109, 78, 47, 16, 17, 48, 79,
  110, 141, 172, 203, 234, 265, 296, 327, 358, 389, 420, 451, 482,
  513, 544, 576, 545, 514, 483, 452, 421, 390, 359, 328, 297, 266,
  235, 204, 173, 142, 111, 80, 49, 18, 19, 50, 81, 112, 143,
  174, 205, 236, 267, 298, 329, 360, 391, 422, 453, 484, 515, 546,
  577, 608, 640, 609, 578, 547, 516, 485, 454, 423, 392, 361, 330,
  299, 268, 237, 206, 175, 144, 113, 82, 51, 20, 21, 52, 83,
  114, 145, 176, 207, 238, 269, 300, 331, 362, 393, 424, 455, 486,
  517, 548, 579, 610, 641, 672, 704, 673, 642, 611, 580, 549, 518,
  487, 456, 425, 394, 363, 332, 301, 270, 239, 208, 177, 146, 115,
  84, 53, 22, 23, 54, 85, 116, 147, 178, 209, 240, 271, 302,
  333, 364, 395, 426, 457, 488, 519, 550, 581, 612, 643, 674, 705,
  736, 768, 737, 706, 675, 644, 613, 582, 551, 520, 489, 458, 427,
  396, 365, 334, 303, 272, 241, 210, 179, 148, 117, 86, 55, 24,
  25, 56, 87, 118, 149, 180, 211, 242, 273, 304, 335, 366, 397,
  428, 459, 490, 521, 552, 583, 614, 645, 676, 707, 738, 769, 800,
  832, 801, 770, 739, 708, 677, 646, 615, 584, 553, 522, 491, 460,
  429, 398, 367, 336, 305, 274, 243, 212, 181, 150, 119, 88, 57,
  26, 27, 58, 89, 120, 151, 182, 213, 244, 275, 306, 337, 368,
  399, 430, 461, 492, 523, 554, 585, 616, 647, 678, 709, 740, 771,
  802, 833, 864, 896, 865, 834, 803, 772, 741, 710, 679, 648, 617,
  586, 555, 524, 493, 462, 431, 400, 369, 338, 307, 276, 245, 214,
  183, 152, 121, 90, 59, 28, 29, 60, 91, 122, 153, 184, 215,
  246, 277, 308, 339, 370, 401, 432, 463, 494, 525, 556, 587, 618,
  649, 680, 711, 742, 773, 804, 835, 866, 897, 928, 960, 929, 898,
  867, 836, 805, 774, 743, 712, 681, 650, 619, 588, 557, 526, 495,
  464, 433, 402, 371, 340, 309, 278, 247, 216, 185, 154, 123, 92,
  61, 30, 31, 62, 93, 124, 155, 186, 217, 248, 279, 310, 341,
  372, 403, 434, 465, 496, 527, 558, 589, 620, 651, 682, 713, 744,
  775, 806, 837, 868, 899, 930, 961, 992, 993, 962, 931, 900, 869,
  838, 807, 776, 745, 714, 683, 652, 621, 590, 559, 528, 497, 466,
  435, 404, 373, 342, 311, 280, 249, 218, 187, 156, 125, 94, 63,
  95, 126, 157, 188, 219, 250, 281, 312, 343, 374, 405, 436, 467,
  498, 529, 560, 591, 622, 653, 684, 715, 746, 777, 808, 839, 870,
  901, 932, 963, 994, 995, 964, 933, 902, 871, 840, 809, 778, 747,
  716, 685, 654, 623, 592, 561, 530, 499, 468, 437, 406, 375, 344,
  313, 282, 251, 220, 189, 158, 127, 159, 190, 221, 252, 283, 314,
  345, 376, 407, 438, 469, 500, 531, 562, 593, 624, 655, 686, 717,
  748, 779, 810, 841, 872, 903, 934, 965, 996, 997, 966, 935, 904,
  873, 842, 811, 780, 749, 718, 687, 656, 625, 594, 563, 532, 501,
  470, 439, 408, 377, 346, 315, 284, 253, 222, 191, 223, 254, 285,
  316, 347, 378, 409, 440, 471, 502, 533, 564, 595, 626, 657, 688,
  719, 750, 781, 812, 843, 874, 905, 936, 967, 998, 999, 968, 937,
  906, 875, 844, 813, 782, 751, 720, 689, 658, 627, 596, 565, 534,
  503, 472, 441, 410, 379, 348, 317, 286, 255, 287, 318, 349, 380,
  411, 442, 473, 504, 535, 566, 597, 628, 659, 690, 721, 752, 783,
  814, 845, 876, 907, 938, 969, 1000, 1001, 970, 939, 908, 877, 846,
  815, 784, 753, 722, 691, 660, 629, 598, 567, 536, 505, 474, 443,
  412, 381, 350, 319, 351, 382, 413, 444, 475, 506, 537, 568, 599,
  630, 661, 692, 723, 754, 785, 816, 847, 878, 909, 940, 971, 1002,
  1003, 972, 941, 910, 879, 848, 817, 786, 755, 724, 693, 662, 631,
  600, 569, 538, 507, 476, 445, 414, 383, 415, 446, 477, 508, 539,
  570, 601, 632, 663, 694, 725, 756, 787, 818, 849, 880, 911, 942,
  973, 1004, 1005, 974, 943, 912, 881, 850, 819, 788, 757, 726, 695,
  664, 633, 602, 571, 540, 509, 478, 447, 479, 510, 541, 572, 603,
  634, 665, 696, 727, 758, 789, 820, 851, 882, 913, 944, 975, 1006,
  1007, 976, 945, 914, 883, 852, 821, 790, 759, 728, 697, 666, 635,
  604, 573, 542, 511, 543, 574, 605, 636, 667, 698, 729, 760, 791,
  822, 853, 884, 915, 946, 977, 1008, 1009, 978, 947, 916, 885, 854,
  823, 792, 761, 730, 699, 668, 637, 606, 575, 607, 638, 669, 700,
  731, 762, 793, 824, 855, 886, 917, 948, 979, 1010, 1011, 980, 949,
  918, 887, 856, 825, 794, 763, 732, 701, 670, 639, 671, 702, 733,
  764, 795, 826, 857, 888, 919, 950, 981, 1012, 1013, 982, 951, 920,
  889, 858, 827, 796, 765, 734, 703, 735, 766, 797, 828, 859, 890,
  921, 952, 983, 1014, 1015, 984, 953, 922, 891, 860, 829, 798, 767,
  799, 830, 861, 892, 923, 954, 985, 1016, 1017, 986, 955, 924, 893,
  862, 831, 863, 894, 925, 956, 987, 1018, 1019, 988, 957, 926, 895,
  927, 958, 989, 1020, 1021, 990, 959, 991, 1022, 1023];
const Default_Scan_4x16 = [
  0, 1, 4, 2, 5, 8, 3, 6, 9, 12, 7, 10, 13, 16, 11, 14,
  17, 20, 15, 18, 21, 24, 19, 22, 25, 28, 23, 26, 29, 32, 27, 30,
  33, 36, 31, 34, 37, 40, 35, 38, 41, 44, 39, 42, 45, 48, 43, 46,
  49, 52, 47, 50, 53, 56, 51, 54, 57, 60, 55, 58, 61, 59, 62, 63];
const Mcol_Scan_4x16 = [
  0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60,
  1, 5, 9, 13, 17, 21, 25, 29, 33, 37, 41, 45, 49, 53, 57, 61,
  2, 6, 10, 14, 18, 22, 26, 30, 34, 38, 42, 46, 50, 54, 58, 62,
  3, 7, 11, 15, 19, 23, 27, 31, 35, 39, 43, 47, 51, 55, 59, 63];
const Mrow_Scan_4x16 = [
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
  16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
  32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
  48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63];
const Default_Scan_16x4 = [
  0, 16, 1, 32, 17, 2, 48, 33, 18, 3, 49, 34, 19, 4, 50, 35,
  20, 5, 51, 36, 21, 6, 52, 37, 22, 7, 53, 38, 23, 8, 54, 39,
  24, 9, 55, 40, 25, 10, 56, 41, 26, 11, 57, 42, 27, 12, 58, 43,
  28, 13, 59, 44, 29, 14, 60, 45, 30, 15, 61, 46, 31, 62, 47, 63];
const Mcol_Scan_16x4 = [
  0, 16, 32, 48, 1, 17, 33, 49, 2, 18, 34, 50, 3, 19, 35, 51,
  4, 20, 36, 52, 5, 21, 37, 53, 6, 22, 38, 54, 7, 23, 39, 55,
  8, 24, 40, 56, 9, 25, 41, 57, 10, 26, 42, 58, 11, 27, 43, 59,
  12, 28, 44, 60, 13, 29, 45, 61, 14, 30, 46, 62, 15, 31, 47, 63];
const Mrow_Scan_16x4 = [
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
  16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
  32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
  48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63];
const Default_Scan_8x32 = [
  0, 1, 8, 2, 9, 16, 3, 10, 17, 24, 4, 11, 18, 25, 32,
  5, 12, 19, 26, 33, 40, 6, 13, 20, 27, 34, 41, 48, 7, 14,
  21, 28, 35, 42, 49, 56, 15, 22, 29, 36, 43, 50, 57, 64, 23,
  30, 37, 44, 51, 58, 65, 72, 31, 38, 45, 52, 59, 66, 73, 80,
  39, 46, 53, 60, 67, 74, 81, 88, 47, 54, 61, 68, 75, 82, 89,
  96, 55, 62, 69, 76, 83, 90, 97, 104, 63, 70, 77, 84, 91, 98,
  105, 112, 71, 78, 85, 92, 99, 106, 113, 120, 79, 86, 93, 100, 107,
  114, 121, 128, 87, 94, 101, 108, 115, 122, 129, 136, 95, 102, 109, 116,
  123, 130, 137, 144, 103, 110, 117, 124, 131, 138, 145, 152, 111, 118, 125,
  132, 139, 146, 153, 160, 119, 126, 133, 140, 147, 154, 161, 168, 127, 134,
  141, 148, 155, 162, 169, 176, 135, 142, 149, 156, 163, 170, 177, 184, 143,
  150, 157, 164, 171, 178, 185, 192, 151, 158, 165, 172, 179, 186, 193, 200,
  159, 166, 173, 180, 187, 194, 201, 208, 167, 174, 181, 188, 195, 202, 209,
  216, 175, 182, 189, 196, 203, 210, 217, 224, 183, 190, 197, 204, 211, 218,
  225, 232, 191, 198, 205, 212, 219, 226, 233, 240, 199, 206, 213, 220, 227,
  234, 241, 248, 207, 214, 221, 228, 235, 242, 249, 215, 222, 229, 236, 243,
  250, 223, 230, 237, 244, 251, 231, 238, 245, 252, 239, 246, 253, 247, 254,
  255];
const Default_Scan_32x8 = [
  0, 32, 1, 64, 33, 2, 96, 65, 34, 3, 128, 97, 66, 35, 4,
  160, 129, 98, 67, 36, 5, 192, 161, 130, 99, 68, 37, 6, 224, 193,
  162, 131, 100, 69, 38, 7, 225, 194, 163, 132, 101, 70, 39, 8, 226,
  195, 164, 133, 102, 71, 40, 9, 227, 196, 165, 134, 103, 72, 41, 10,
  228, 197, 166, 135, 104, 73, 42, 11, 229, 198, 167, 136, 105, 74, 43,
  12, 230, 199, 168, 137, 106, 75, 44, 13, 231, 200, 169, 138, 107, 76,
  45, 14, 232, 201, 170, 139, 108, 77, 46, 15, 233, 202, 171, 140, 109,
  78, 47, 16, 234, 203, 172, 141, 110, 79, 48, 17, 235, 204, 173, 142,
  111, 80, 49, 18, 236, 205, 174, 143, 112, 81, 50, 19, 237, 206, 175,
  144, 113, 82, 51, 20, 238, 207, 176, 145, 114, 83, 52, 21, 239, 208,
  177, 146, 115, 84, 53, 22, 240, 209, 178, 147, 116, 85, 54, 23, 241,
  210, 179, 148, 117, 86, 55, 24, 242, 211, 180, 149, 118, 87, 56, 25,
  243, 212, 181, 150, 119, 88, 57, 26, 244, 213, 182, 151, 120, 89, 58,
  27, 245, 214, 183, 152, 121, 90, 59, 28, 246, 215, 184, 153, 122, 91,
  60, 29, 247, 216, 185, 154, 123, 92, 61, 30, 248, 217, 186, 155, 124,
  93, 62, 31, 249, 218, 187, 156, 125, 94, 63, 250, 219, 188, 157, 126,
  95, 251, 220, 189, 158, 127, 252, 221, 190, 159, 253, 222, 191, 254, 223,
  255];


// 9.3. Conversion tables
const Mi_Width_Log2 = [
  0, 0, 1, 1, 1, 2, 2, 2, 3, 3, 3,
  4, 4, 4, 5, 5, 0, 2, 1, 3, 2, 4];
const Mi_Height_Log2 = [
  0, 1, 0, 1, 2, 1, 2, 3, 2, 3, 4,
  3, 4, 5, 4, 5, 2, 0, 3, 1, 4, 2];
const Num_4x4_Blocks_Wide = [
  1, 1, 2, 2, 2, 4, 4, 4, 8, 8, 8,
  16, 16, 16, 32, 32, 1, 4, 2, 8, 4, 16];
const Num_4x4_Blocks_High = [
  1, 2, 1, 2, 4, 2, 4, 8, 4, 8, 16,
  8, 16, 32, 16, 32, 4, 1, 8, 2, 16, 4];
const Block_Width = Num_4x4_Blocks_Wide.map((n) => 4 * n);
const Block_Height = Num_4x4_Blocks_High.map((n) => 4 * n);
const Size_Group = [
  0, 0, 0, 1, 1, 1, 2, 2, 2, 3, 3,
  3, 3, 3, 3, 3, 0, 0, 1, 1, 2, 2];
const Max_Tx_Size_Rect = [
  TX_4X4, TX_4X8, TX_8X4, TX_8X8,
  TX_8X16, TX_16X8, TX_16X16, TX_16X32,
  TX_32X16, TX_32X32, TX_32X64, TX_64X32,
  TX_64X64, TX_64X64, TX_64X64, TX_64X64,
  TX_4X16, TX_16X4, TX_8X32, TX_32X8,
  TX_16X64, TX_64X16];
const Partition_Subsize = [
  [
    BLOCK_4X4,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_8X8,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_16X16,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_32X32,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_64X64,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_128X128,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_INVALID,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_INVALID
  ], [
    BLOCK_INVALID,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_8X4,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_16X8,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_32X16,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_64X32,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_128X64,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_INVALID,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_INVALID
  ], [
    BLOCK_INVALID,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_4X8,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_8X16,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_16X32,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_32X64,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_64X128,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_INVALID,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_INVALID
  ], [
    BLOCK_INVALID,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_4X4,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_8X8,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_16X16,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_32X32,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_64X64,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_INVALID,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_INVALID
  ], [
    BLOCK_INVALID,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_8X4,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_16X8,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_32X16,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_64X32,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_128X64,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_INVALID,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_INVALID
  ], [
    BLOCK_INVALID,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_8X4,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_16X8,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_32X16,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_64X32,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_128X64,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_INVALID,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_INVALID
  ], [
    BLOCK_INVALID,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_4X8,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_8X16,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_16X32,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_32X64,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_64X128,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_INVALID,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_INVALID
  ], [
    BLOCK_INVALID,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_4X8,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_8X16,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_16X32,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_32X64,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_64X128,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_INVALID,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_INVALID
  ], [
    BLOCK_INVALID,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_INVALID,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_16X4,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_32X8,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_64X16,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_INVALID,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_INVALID,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_INVALID
  ], [
    BLOCK_INVALID,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_INVALID,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_4X16,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_8X32,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_16X64,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_INVALID,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_INVALID,
    BLOCK_INVALID, BLOCK_INVALID, BLOCK_INVALID
  ]
];
const Split_Tx_Size = [
  TX_4X4,
  TX_4X4,
  TX_8X8,
  TX_16X16,
  TX_32X32,
  TX_4X4,
  TX_4X4,
  TX_8X8,
  TX_8X8,
  TX_16X16,
  TX_16X16,
  TX_32X32,
  TX_32X32,
  TX_8X4,
  TX_8X16,
  TX_16X8,
  TX_16X32,
  TX_32X16
];
const Mode_To_Txfm = [
  DCT_DCT, // DC_PRED
  ADST_DCT, // V_PRED
  DCT_ADST, // H_PRED
  DCT_DCT, // D45_PRED
  ADST_ADST, // D135_PRED
  ADST_DCT, // D113_PRED
  DCT_ADST, // D157_PRED
  DCT_ADST, // D203_PRED
  ADST_DCT, // D67_PRED
  ADST_ADST, // SMOOTH_PRED
  ADST_DCT, // SMOOTH_V_PRED
  DCT_ADST, // SMOOTH_H_PRED
  ADST_ADST, // PAETH_PRED
  DCT_DCT, // UV_CFL_PRED
];
const Palette_Color_Context =
  [-1, -1, 0, -1, -1, 4, 3, 2, 1];
const Palette_Color_Hash_Multipliers = [1, 2, 2];
const Sm_Weights_Tx_4x4 = [255, 149, 85, 64];
const Sm_Weights_Tx_8x8 = [255, 197, 146, 105, 73, 50, 37, 32];
const Sm_Weights_Tx_16x16 = [255, 225, 196, 170, 145, 123, 102, 84, 68, 54, 43, 33, 26, 20, 17, 16];
const Sm_Weights_Tx_32x32 = [255, 240, 225, 210, 196, 182, 169, 157, 145, 133, 122, 111, 101, 92, 83, 74, 66, 59, 52, 45, 39, 34, 29, 25, 21, 17, 14, 12, 10, 9, 8, 8];
const Sm_Weights_Tx_64x64 = [255, 248, 240, 233, 225, 218, 210, 203, 196, 189, 182, 176, 169, 163, 156,
  150, 144, 138, 133, 127, 121, 116, 111, 106, 101, 96, 91, 86, 82, 77, 73, 69,
  65, 61, 57, 54, 50, 47, 44, 41, 38, 35, 32, 29, 27, 25, 22, 20, 18, 16, 15,
  13, 12, 10, 9, 8, 7, 6, 6, 5, 5, 4, 4, 4];
const Mode_To_Angle = [0, 90, 180, 45, 135, 113, 157, 203, 67, 0, 0, 0, 0];
const Dr_Intra_Derivative = [
  0, 0, 0, 1023, 0, 0, 547, 0, 0, 372, 0, 0, 0, 0,
  273, 0, 0, 215, 0, 0, 178, 0, 0, 151, 0, 0, 132, 0, 0,
  116, 0, 0, 102, 0, 0, 0, 90, 0, 0, 80, 0, 0, 71, 0, 0,
  64, 0, 0, 57, 0, 0, 51, 0, 0, 45, 0, 0, 0, 40, 0, 0,
  35, 0, 0, 31, 0, 0, 27, 0, 0, 23, 0, 0, 19, 0, 0,
  15, 0, 0, 0, 0, 11, 0, 0, 7, 0, 0, 3, 0, 0];
const Intra_Filter_Taps = [
  [
    [-6, 10, 0, 0, 0, 12, 0],
    [-5, 2, 10, 0, 0, 9, 0],
    [-3, 1, 1, 10, 0, 7, 0],
    [-3, 1, 1, 2, 10, 5, 0],
    [-4, 6, 0, 0, 0, 2, 12],
    [-3, 2, 6, 0, 0, 2, 9],
    [-3, 2, 2, 6, 0, 2, 7],
    [-3, 1, 2, 2, 6, 3, 5],
  ],
  [
    [-10, 16, 0, 0, 0, 10, 0],
    [-6, 0, 16, 0, 0, 6, 0],
    [-4, 0, 0, 16, 0, 4, 0],
    [-2, 0, 0, 0, 16, 2, 0],
    [-10, 16, 0, 0, 0, 0, 10],
    [-6, 0, 16, 0, 0, 0, 6],
    [-4, 0, 0, 16, 0, 0, 4],
    [-2, 0, 0, 0, 16, 0, 2],
  ],
  [
    [-8, 8, 0, 0, 0, 16, 0],
    [-8, 0, 8, 0, 0, 16, 0],
    [-8, 0, 0, 8, 0, 16, 0],
    [-8, 0, 0, 0, 8, 16, 0],
    [-4, 4, 0, 0, 0, 0, 16],
    [-4, 0, 4, 0, 0, 0, 16],
    [-4, 0, 0, 4, 0, 0, 16],
    [-4, 0, 0, 0, 4, 0, 16],
  ],
  [
    [-2, 8, 0, 0, 0, 10, 0],
    [-1, 3, 8, 0, 0, 6, 0],
    [-1, 2, 3, 8, 0, 4, 0],
    [0, 1, 2, 3, 8, 2, 0],
    [-1, 4, 0, 0, 0, 3, 10],
    [-1, 3, 4, 0, 0, 4, 6],
    [-1, 2, 3, 4, 0, 4, 4],
    [-1, 2, 2, 3, 4, 3, 3],
  ],
  [
    [-12, 14, 0, 0, 0, 14, 0],
    [-10, 0, 14, 0, 0, 12, 0],
    [-9, 0, 0, 14, 0, 11, 0],
    [-8, 0, 0, 0, 14, 10, 0],
    [-10, 12, 0, 0, 0, 0, 14],
    [-9, 1, 12, 0, 0, 0, 12],
    [-8, 0, 0, 12, 0, 1, 11],
    [-7, 0, 0, 1, 12, 1, 9],
  ]
];
const Tx_Size_Sqr = [
  TX_4X4,
  TX_8X8,
  TX_16X16,
  TX_32X32,
  TX_64X64,
  TX_4X4,
  TX_4X4,
  TX_8X8,
  TX_8X8,
  TX_16X16,
  TX_16X16,
  TX_32X32,
  TX_32X32,
  TX_4X4,
  TX_4X4,
  TX_8X8,
  TX_8X8,
  TX_16X16,
  TX_16X16
];
const Tx_Size_Sqr_Up = [
  TX_4X4,
  TX_8X8,
  TX_16X16,
  TX_32X32,
  TX_64X64,
  TX_8X8,
  TX_8X8,
  TX_16X16,
  TX_16X16,
  TX_32X32,
  TX_32X32,
  TX_64X64,
  TX_64X64,
  TX_16X16,
  TX_16X16,
  TX_32X32,
  TX_32X32,
  TX_64X64,
  TX_64X64
];
const Tx_Width = [
  4, 8, 16, 32, 64, 4, 8, 8, 16, 16, 32, 32, 64, 4, 16, 8, 32, 16, 64];
const Tx_Height = [
  4, 8, 16, 32, 64, 8, 4, 16, 8, 32, 16, 64, 32, 16, 4, 32, 8, 64, 16];
const Tx_Width_Log2 = [
  2, 3, 4, 5, 6, 2, 3, 3, 4, 4, 5, 5, 6, 2, 4, 3, 5, 4, 6];
const Tx_Height_Log2 = [
  2, 3, 4, 5, 6, 3, 2, 4, 3, 5, 4, 6, 5, 4, 2, 5, 3, 6, 4];
const Wedge_Bits = [
  0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 0,
  0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0];
const Sig_Ref_Diff_Offset = [
  [
    [0, 1], [1, 0], [1, 1], [0, 2], [2, 0]
  ],
  [
    [0, 1], [1, 0], [0, 2], [0, 3], [0, 4]
  ],
  [
    [0, 1], [1, 0], [2, 0], [3, 0], [4, 0]
  ]
];
const Adjusted_Tx_Size = [
  TX_4X4,
  TX_8X8,
  TX_16X16,
  TX_32X32,
  TX_32X32,
  TX_4X8,
  TX_8X4,
  TX_8X16,
  TX_16X8,
  TX_16X32,
  TX_32X16,
  TX_32X32,
  TX_32X32,
  TX_4X16,
  TX_16X4,
  TX_8X32,
  TX_32X8,
  TX_16X32,
  TX_32X16
];


export class OBU {
  seq_header: any;
  SeenFrameHeader: number;
  RefFrameType: any[];

  constructor() {
    this.SeenFrameHeader = 0;
    this.RefFrameType = new Array(NUM_REF_FRAMES);
  }

  parse(buffer: Uint8Array, offset: number) {
    let obu: any[] = [];
    let b = new BitReader(buffer);
    while (buffer.length > b.get_position() / 8) {
      let h: any = {};

      let bitOffset = b.get_position();
      let bitPos = this.open_bitstream_unit(buffer.length - bitOffset / 8, { b, h });

      if (h.obu_type == OBU_SEQUENCE_HEADER) {
        this.seq_header = h;
      }

      h['@offset'] = bitOffset / 8 + offset;
      h['@length'] = (bitPos - bitOffset) / 8 + h.obu_size;
      obu.push(h);
      this.update_frame_buffers({ h });
      b.seek(bitPos + h.obu_size * 8);
    }
    return obu;
  }

  // 5.3.1. General OBU syntax
  open_bitstream_unit(sz: number, { b, h }: { b: BitReader, h: any }) {
    this.obu_header({ b, h });
    if (h.obu_has_size_field) {
      h.obu_size = b.leb128();
    } else {
      h.obu_size = sz - 1 - h.obu_extension_flag;
    }
    let startPosition = b.get_position();

    if (h.obu_type == OBU_SEQUENCE_HEADER) {
      this.sequence_header_obu({ b, h });
      h['@type'] = "OBU_SEQUENCE_HEADER";
    } else if (h.obu_type == OBU_TEMPORAL_DELIMITER) {
      h['@type'] = "OBU_TEMPORAL_DELIMITER";
    } else if (h.obu_type == OBU_FRAME_HEADER) {
      this.frame_header_obu({ b, h });
      h['@type'] = "OBU_FRAME_HEADER";
    } else if (h.obu_type == OBU_TILE_GROUP) {
      this.tile_group_obu(h.obu_size, { b, h });
      h['@type'] = "OBU_TILE_GROUP";
    } else if (h.obu_type == OBU_METADATA) {
      h['@type'] = "OBU_METADATA";
    } else if (h.obu_type == OBU_FRAME) {
      this.frame_obu(h.obu_size, { b, h });
      h['@type'] = "OBU_FRAME";
    } else if (h.obu_type == OBU_REDUNDANT_FRAME_HEADER) {
      this.frame_header_obu({ b, h });
      h['@type'] = "OBU_REDUNDANT_FRAME_HEADER";
    } else if (h.obu_type == OBU_TILE_LIST) {
      h['@type'] = "OBU_TILE_LIST";
    } else if (h.obu_type == OBU_PADDING) {
      h['@type'] = "OBU_PADDING";
    } else {
      h['@type'] = "Reserved";
    }

    return startPosition;
  }

  // 5.3.2. OBU header syntax
  obu_header({ b, h }: { b: BitReader, h: any }) {
    h.obu_forbidden_bit = b.u(1);
    if (h.obu_forbidden_bit) {
      throw Error("obu_forbidden_bit Must not be set");
    }
    h.obu_type = b.u(4);
    h.obu_extension_flag = b.u(1);  // 扩展头标志
    h.obu_has_size_field = b.u(1);  // obu大小字段
    h.obu_reserved_1bit = b.u(1);
    if (h.obu_extension_flag) {
      this.obu_extension_header({ b, h });
    } else {
      h.temporal_id = 0;  // 时间层
      h.spatial_id = 0;   // 空间层
    }
  };

  // 5.3.3. OBU extension header syntax
  obu_extension_header({ b, h }: { b: BitReader, h: any }) {
    h.temporal_id = b.u(3); // 时间层
    h.spatial_id = b.u(2);  // 空间层
    h.extension_header_reserved_3bits = b.u(3);
  }

  // 5.5.1. General sequence header OBU syntax
  sequence_header_obu({ b, h }: { b: BitReader, h: any }) {
    /** +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     *  | seq_profile | BitDepth  | Monochrome support|        Chroma subsampling       |
     *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     *  |      0      |  8 or 10  |        yes        |            YUV 4:2:0            |
     *  |      1      |  8 or 10  |        no         |            YUV 4:4:4            |
     *  |      2      |  8 or 10  |        yes        |            YUV 4:2:2            |
     *  |      2      |    12     |        yes        | YUV 4:2:0, YUV 4:2:2, YUV 4:4:4 |
     *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     */
    h.seq_profile = b.u(3); // seq_params->profile
    if (h.seq_profile > 2) {
      throw Error("The given bitstream is not supported");
    }

    // 如果reduced_still_picture_header=1，则still_picture=1是比特流一致性的要求。
    h.still_picture = b.u(1); // =1表示编码视频序列只包含一个编码帧；=0指定编码视频序列包含一个或多个编码帧。seq_params->still_picture
    h.reduced_still_picture_header = b.u(1); // 指定省略静态图片不需要的语法元素。seq_params->reduced_still_picture_hdr
    if (!h.still_picture && h.reduced_still_picture_hdr) {
      throw Error("The given bitstream is not supported");
    }

    if (h.reduced_still_picture_header) {
      h.timing_info_present_flag = 0;           // 指定编码视频序列中是否存在定时信息。seq_params->timing_info_present
      h.decoder_model_info_present_flag = 0;    // 表示编码视频序列中是否存在解码器模型信息。seq_params->decoder_model_info_present_flag
      h.initial_display_delay_present_flag = 0; // 指定初始显示延迟信息是否出现在编码视频序列中。seq_params->display_model_info_present_flag
      h.operating_points_cnt_minus_1 = 0;       // 表示编码视频序列中存在的工作点数；操作点指定应该解码哪些空间层和时间层。seq_params->operating_points_cnt_minus_1
      h['operating_point_idc[0]'] = 0;          // 表示操作点i需要解码的空间层和时间层，时间层0~7，空间层(0~3)+8。seq_params->operating_point_idc
      h['seq_level_idx[0]'] = b.u(5);           // 选择工作点i时编码视频序列所符合的级别。seq_params->seq_level_idx
      this.is_valid_seq_level_idx(h['seq_level_idx[0]']);
      h['seq_tier[0]'] = 0;                     // 选择工作点i时，编码视频序列所遵从的层数。seq_params->tier
      h['decoder_model_present_for_this_op[0]'] = 0;  // =1表示存在与操作点i关联的解码器模型。seq_params->op_params[i].decoder_model_param_present_flag
      h['initial_display_delay_present_for_this_op[0]'] = 0;  // =1表示指定了initial_display_delay_minus_1。seq_params->op_params[i].display_model_param_present_flag
    } else {
      h.timing_info_present_flag = b.u(1);
      if (h.timing_info_present_flag) {
        this.timing_info({ b, h });
        h.decoder_model_info_present_flag = b.u(1);
        if (h.decoder_model_info_present_flag) {
          this.decoder_model_info({ b, h });
        }
      } else {
        h.decoder_model_info_present_flag = 0;
      }
      h.initial_display_delay_present_flag = b.u(1);
      h.operating_points_cnt_minus_1 = b.u(5);
      for (let i = 0; i <= h.operating_points_cnt_minus_1; i++) {
        h[`operating_point_idc[${i}]`] = b.u(12);
        h[`seq_level_idx[${i}]`] = b.u(5);
        this.is_valid_seq_level_idx(h[`seq_level_idx[${i}]`]);
        if (h[`seq_level_idx[${i}]`] > 7) {
          h[`seq_tier[${i}]`] = b.u(1);
        } else {
          h[`seq_tier[${i}]`] = 0;
        }
        if (h.decoder_model_info_present_flag) {
          h[`decoder_model_present_for_this_op[${i}]`] = b.u(1);
          if (h[`decoder_model_present_for_this_op[${i}]`]) {
            this.operating_parameters_info(i, { b, h });
          }
        } else {
          h[`decoder_model_present_for_this_op[${i}]`] = 0;
        }

        if (h.initial_display_delay_present_flag) {
          h[`initial_display_delay_present_for_this_op[${i}]`] = b.u(1);
          if (h[`initial_display_delay_present_for_this_op[${i}]`]) {
            h[`initial_display_delay_minus_1[${i}]`] = b.u(4); // 对于操作点i，在显示第一个可呈现的帧之前，缓冲池中应该出现的解码帧的数量。seq_params->op_params[i].initial_display_delay
            if (h[`initial_display_delay_minus_1[${i}]`] > 9) {
              console.error("AV1 does not support more than 10 decoded frames delay");
            }
          }
        } else {
          h[`initial_display_delay_minus_1[${i}]`] = 9;
        }
      }
    }
    h.frame_width_bits_minus_1 = b.u(4);
    h.frame_height_bits_minus_1 = b.u(4);
    h.max_frame_width_minus_1 = b.u(h.frame_width_bits_minus_1 + 1);    // 指定该seq报头表示的帧的最大帧宽。seq_params->max_frame_width
    h.max_frame_height_minus_1 = b.u(h.frame_height_bits_minus_1 + 1);  // 指定该seq报头表示的帧的最大帧高。seq_params->max_frame_height
    if (h.reduced_still_picture_header) {
      h.frame_id_numbers_present_flag = 0;      // 指定帧id号是否出现在编码视频序列中。seq_params->frame_id_numbers_present_flag
    } else {
      h.frame_id_numbers_present_flag = b.u(1);
    }
    if (h.frame_id_numbers_present_flag) {
      h.delta_frame_id_length_minus_2 = b.u(4);       // 用于编码delta_frame_id语法元素的位数。seq_params->delta_frame_id_length
      h.additional_frame_id_length_minus_1 = b.u(3);  // 计算用于编码frame_id语法元素的位数。seq_params->frame_id_length
      if (h.additional_frame_id_length_minus_1 + h.delta_frame_id_length_minus_2 > 13) {
        console.error("Invalid frame_id_length");
      }
    }
    h.use_128x128_superblock = b.u(1);  // =1时，表示超级块包含128x128个luma样本。seq_params->sb_size
    h.enable_filter_intra = b.u(1);     // =1指定可以存在use_filter_intra语法元素。seq_params->enable_filter_intra
    h.enable_intra_edge_filter = b.u(1);  // 是否开启内部边缘过滤。seq_params->enable_intra_edge_filter
    if (h.reduced_still_picture_header) {
      h.enable_interintra_compound = 0; // =1指定inter blocks的模式信息可以包含语法元素interintra。seq_params->enable_interintra_compound
      h.enable_masked_compound = 0;     // =1指定块间的模式信息可以包含语法元素compound_type。seq_params->enable_masked_compound
      h.enable_warped_motion = 0;       // =1表示可能存在allow_warped_motion语法元素。seq_params->enable_warped_motion
      h.enable_dual_filter = 0;         // =1表示可以在水平方向和垂直方向独立指定内部预测过滤器类型；如果标志等于0，则只能指定一种过滤器类型，然后在两个方向上使用。seq_params->enable_dual_filter
      h.enable_order_hint = 0;          // =1表示可以使用基于订单提示值的工具。seq_params->order_hint_info.enable_order_hint
      h.enable_jnt_comp = 0;            // =1表示可以使用距离权重过程进行内部预测。seq_params->order_hint_info.enable_dist_wtd_comp
      h.enable_ref_frame_mvs = 0;       // =1表示可能存在use_ref_frame_mvs语法元素。seq_params->order_hint_info.enable_ref_frame_mvs
      h.seq_force_screen_content_tools = SELECT_SCREEN_CONTENT_TOOLS; // =SELECT_SCREEN_CONTENT_TOOLS表示allow_screen_content_tools语法元素将出现在帧头中；否则包含allow_screen_content_tools的值。seq_params->force_screen_content_tools
      h.seq_force_integer_mv = SELECT_INTEGER_MV; // =SELECT_INTEGER_MV表示force_integer_mv语法元素将出现在帧头中；否则包含force_integer_mv的值。seq_params->force_integer_mv
      h['OrderHintBits'] = 0;
    } else {
      h.enable_interintra_compound = b.u(1);
      h.enable_masked_compound = b.u(1);
      h.enable_warped_motion = b.u(1);
      h.enable_dual_filter = b.u(1);
      h.enable_order_hint = b.u(1);
      if (h.enable_order_hint) {
        h.enable_jnt_comp = b.u(1);
        h.enable_ref_frame_mvs = b.u(1);
      } else {
        h.enable_jnt_comp = 0;
        h.enable_ref_frame_mvs = 0;
      }
      h.seq_choose_screen_content_tools = b.u(1); // temp
      if (h.seq_choose_screen_content_tools) {
        h.seq_force_screen_content_tools = SELECT_SCREEN_CONTENT_TOOLS;
      } else {
        h.seq_force_screen_content_tools = b.u(1);
      }
      if (h.seq_force_screen_content_tools > 0) {
        h.seq_choose_integer_mv = b.u(1); // temp
        if (h.seq_choose_integer_mv) {
          h.seq_force_integer_mv = SELECT_INTEGER_MV;
        } else {
          h.seq_force_integer_mv = b.u(1);
        }
      } else {
        h.seq_force_integer_mv = SELECT_INTEGER_MV;
      }
      if (h.enable_order_hint) {
        h.order_hint_bits_minus_1 = b.u(3);
        h['OrderHintBits'] = h.order_hint_bits_minus_1 + 1; // 指定用于order_hint语法元素的位数。seq_params->order_hint_info.order_hint_bits_minus_1
      } else {
        h['OrderHintBits'] = 0;
      }
    }
    h.enable_superres = b.u(1);     // =1指定use_superres语法元素将出现在未压缩的头文件中。seq_params->enable_superres
    h.enable_cdef = b.u(1);         // =1指定可以启用cdef过滤。seq_params->enable_cdef
    h.enable_restoration = b.u(1);  // =1表示可以启用环路恢复过滤。seq_params->enable_restoration

    this.color_config({ b, h });
    h.film_grain_params_present = b.u(1); // 指定胶片颗粒参数是否出现在编码视频序列中。seq_params->film_grain_params_present
    return h;
  };

  // 5.5.2. Color config syntax
  color_config({ b, h }: { b: BitReader, h: any }) {
    h.high_bitdepth = b.u(1); // high_bitdepth和twelve_bit是语法元素，它们与seq_profile一起决定位深度。
    if (h.seq_profile == 2 && h.high_bitdepth) {
      h.twelve_bit = b.u(1);
      h['BitDepth'] = h.twelve_bit ? 12 : 10; // seq_params->bit_depth
    } else if (h.seq_profile <= 2) {
      h['BitDepth'] = h.high_bitdepth ? 10 : 8;
    } else {
      console.error("Unsupported profile/bit-depth combination");
    }
    if (h.seq_profile == 1) {
      h.mono_chrome = 0;  // =1表示视频不包含U和V色平面。seq_params->monochrome
    } else {
      h.mono_chrome = b.u(1);
    }
    h['NumPlanes'] = h.mono_chrome ? 1 : 3;
    h.color_description_present_flag = b.u(1);  // temp
    if (h.color_description_present_flag) {
      h.color_primaries = b.u(8);           // 6.4.2. ISO/IEC 23091-4/ITU-T H.273。seq_params->color_primaries
      h.transfer_characteristics = b.u(8);  // 6.4.2. ISO/IEC 23091-4/ITU-T H.273。seq_params->transfer_characteristics
      h.matrix_coefficients = b.u(8);       // 6.4.2. ISO/IEC 23091-4/ITU-T H.273。seq_params->matrix_coefficients
    } else {
      h.color_primaries = CP_UNSPECIFIED;
      h.transfer_characteristics = TC_UNSPECIFIED;
      h.matrix_coefficients = MC_UNSPECIFIED;
    }
    if (h.mono_chrome) {
      h.color_range = b.u(1); // 6.4.2. ISO/IEC 23091-4/ITU-T H.273。seq_params->color_range
      /** +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       *  | subsampling_x | subsampling_y | mono_chrome |   Description   |
       *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       *  |       0       |       0       |      0      |    YUV 4:4:4    |
       *  |       1       |       0       |      0      |    YUV 4:2:2    |
       *  |       1       |       1       |      0      |    YUV 4:2:0    |
       *  |       1       |       1       |      1      | Monochrome 4:0:0|
       *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       */
      h.subsampling_x = 1;  // seq_params->subsampling_x
      h.subsampling_y = 1;  // seq_params->subsampling_y
      h.chroma_sample_position = CSP_UNKNOWN; // CSP_VERTICAL水平位置与(0,0)亮度样本同处，垂直位置在两个亮度样本中间；CSP_COLOCATED与(0,0)亮度样本共定位。seq_params->chroma_sample_position
      h.separate_uv_delta_q = 0;  // // =1表示U和V平面可以有单独的增量量化器值；=0表示U和V平面将共享相同的增量量化器值。seq_params->separate_uv_delta_q
      return;
    } else if (
      h.color_primaries == CP_BT_709 && h.transfer_characteristics == TC_SRGB &&
      h.matrix_coefficients == MC_IDENTITY) {
      h.color_range = 1;
      h.subsampling_x = 0;
      h.subsampling_y = 0;
      if (!(h.seq_profile == 1 ||
        (h.seq_profile == 2 && h['BitDepth'] == 12))) {
        console.error("sRGB colorspace not compatible with specified profile");
      }
    } else {
      h.color_range = b.u(1);
      if (h.seq_profile == 0) {
        h.subsampling_x = 1;
        h.subsampling_y = 1;
      } else if (h.seq_profile == 1) {
        h.subsampling_x = 0;
        h.subsampling_y = 0;
      } else {
        if (h['BitDepth'] == 12) {
          h.subsampling_x = b.u(1);
          if (h.subsampling_x)
            h.subsampling_y = b.u(1);
          else
            h.subsampling_y = 0;
        } else {
          h.subsampling_x = 1;
          h.subsampling_y = 0;
        }
      }
      if (h.matrix_coefficients == MC_IDENTITY &&
        (h.subsampling_x || h.subsampling_y)) {
        console.error("Identity CICP Matrix incompatible with non 4:4:4 color sampling");
      }
      if (h.subsampling_x && h.subsampling_y) {
        h.chroma_sample_position = b.u(2);
      }
    }
    h.separate_uv_delta_q = b.u(1);
  };

  // 5.5.3. Timing info syntax
  timing_info({ b, h }: { b: BitReader, h: any }) {
    h.num_units_in_display_tick = b.u(32);  // num_units_in_display_tic/time_scale以秒为单位。timing_info->num_units_in_display_tick
    h.time_scale = b.u(32);                 // 一秒钟的滴答数。timing_info->time_scale
    if (h.num_units_in_display_tick == 0 || h.time_scale == 0) {
      console.error("num_units_in_display_tick and time_scale must be greater than 0.");
    }
    h.equal_picture_interval = b.u(1);  // =1表示图片应该按照它们的输出顺序显示，两个连续图片之间的滴答数(不掉帧)由num_ticks_per_picture_minus_1指定。timing_info->equal_picture_interval
    if (h.equal_picture_interval) {
      h.num_ticks_per_picture_minus_1 = b.uvlc(); // 指定输出顺序中两个连续图片之间的输出时间对应的时钟滴答数。timing_info->num_ticks_per_picture
      if (h.num_ticks_per_picture_minus_1 == 4294967295) {
        console.error("num_ticks_per_picture_minus_1 cannot be (1 << 32) - 1.");
      }
    }
  }

  // 5.5.4. Decoder model info syntax
  decoder_model_info({ b, h }: { b: BitReader, h: any }) {
    h.buffer_delay_length_minus_1 = b.u(5); // 指定decoder_buffer_delay和encoder_buffer_delay语法元素的长度。decoder_model_info->encoder_decoder_buffer_delay_length
    h.num_units_in_decoding_tick = b.u(32); // 解码时间在频率，num_units_in_decoding_tick/time_scale以秒为单位。decoder_model_info->num_units_in_decoding_tick
    h.buffer_removal_time_length_minus_1 = b.u(5);  // 指定buffer_removal_time语法元素的长度。decoder_model_info->buffer_removal_time_length
    h.frame_presentation_time_length_minus_1 = b.u(5);  // 指定frame_presentation_time语法元素的长度。decoder_model_info->frame_presentation_time_length
  }

  // 5.5.5. Operating parameters info syntax
  operating_parameters_info(op: number, { b, h }: { b: BitReader, h: any }) {
    let n = h.buffer_delay_length_minus_1 + 1;
    h[`decoder_buffer_delay[${op}]`] = b.u(n);  // 指定平滑缓冲区中的第一个比特到达和随后属于第一个编码帧的数据的移除之间的时间间隔，用于操作点op，以1/90000秒为单位。op_params->decoder_buffer_delay
    h[`encoder_buffer_delay[${op}]`] = b.u(n);  // 指定要解码到平滑缓冲区的帧的第一个比特到达时间，以1/90000秒为单位。op_params->encoder_buffer_delay
    h[`low_delay_mode_flag[${op}]`] = b.u(1);   // =1表示平滑缓冲区对操作点op以低延迟模式运行，在低延迟模式下，允许延迟解码时间和缓冲区底流；=0表示平滑缓冲区在严格模式下运行，不允许缓冲区下溢。op_params->low_delay_mode_flag
  }

  // 5.6. Temporal delimiter obu syntax
  temporal_delimiter_obu({ b, h }: { b: BitReader, h: any }) {
    this.SeenFrameHeader = 0; // 用于标记当前帧的帧头是否已被接收。
  }

  // 5.9.1. General frame header OBU syntax
  frame_header_obu({ b, h }: { b: BitReader, h: any }) {
    if (h.SeenFrameHeader == 1) {

    } else {
      h.SeenFrameHeader = 1;
      this.uncompressed_header({ b, h });
      if (h.show_existing_frame) {
        this.decode_frame_wrapup({ b, h });
        h.SeenFrameHeader = 0;
      } else {
        h['TileNum'] = 0;
        h.SeenFrameHeader = 1;
      }
    }
  };

  // 5.9.2. Uncompressed header syntax  
  uncompressed_header({ b, h }: { b: BitReader, h: any }) {
    let idLen;
    if (this.seq_header.frame_id_numbers_present_flag) {
      idLen =
        this.seq_header.additional_frame_id_length_minus_1 +
        this.seq_header.delta_frame_id_length_minus_2 + 3;
    }
    let allFrames = (1 << NUM_REF_FRAMES) - 1;
    if (this.seq_header.reduced_still_picture_header) {
      h.show_existing_frame = 0;  // =1，表示输出由frame_to_show_map_idx索引的帧；=0表示需要进一步处理。cm->show_existing_frame
      h.frame_type = KEY_FRAME;   // current_frame->frame_type
      h['FrameIsIntra'] = 1;
      h.show_frame = 1;           // =1指定解码后立即输出该帧。cm->show_frame
      h.showable_frame = 0;       // =1指定可以使用show_existing_frame机制输出帧。cm->showable_frame
    } else {
      h.show_existing_frame = b.u(1);
      if (h.show_existing_frame == 1) {
        h.frame_to_show_map_idx = b.u(3); // 指定要输出的帧。temp
        if (this.seq_header.decoder_model_info_present_flag &&
          !this.seq_header.equal_picture_interval) {
          this.temporal_point_info({ b, h });
        }
        h.refresh_frame_flags = 0;  // current_frame->refresh_frame_flags
        if (this.seq_header.frame_id_numbers_present_flag) {
          h.display_frame_id = b.u(idLen);  // 要输出的帧提供帧id号。temp
        }

        let ref_frame = this.RefFrameType[h.frame_to_show_map_idx];
        if (!ref_frame) {
          throw Error("Buffer does not contain a decoded frame");
        }
        h.frame_type = ref_frame.frame_type;  // frame_to_show->frame_type

        if (h.frame_type == KEY_FRAME) {
          h.refresh_frame_flags = allFrames;
        }
        if (this.seq_header.film_grain_params_present) {
          this.load_grain_params(h.frame_to_show_map_idx, { b, h });
        }
        return;
      }
      h.frame_type = b.u(2);
      h['FrameIsIntra'] =
        (h.frame_type == INTRA_ONLY_FRAME ||
          h.frame_type == KEY_FRAME)
      h.show_frame = b.u(1);
      if (this.seq_header.still_picture &&
        (h.frame_type != KEY_FRAME || !h.show_frame)) {
        console.error("Still pictures must be coded as shown keyframes");
      }
      if (h.show_frame && this.seq_header.decoder_model_info_present_flag &&
        !this.seq_header.equal_picture_interval) {
        this.temporal_point_info({ b, h });
      }
      if (h.show_frame) {
        h.showable_frame = Number(h.frame_type != KEY_FRAME);
      } else {
        h.showable_frame = b.u(1);
      }
      if (h.frame_type == SWITCH_FRAME ||
        (h.frame_type == KEY_FRAME && h.show_frame))
        h.error_resilient_mode = 1;     // =1表示启用错误弹性模式。features->error_resilient_mode
      else
        h.error_resilient_mode = b.u(1);
    }
    if (h.frame_type == KEY_FRAME && h.show_frame) {
      for (let i = 0; i < NUM_REF_FRAMES; i++) {
        h[`RefValid[${i}]`] = 0;
        h[`RefOrderHint[${i}]`] = 0;
      }
      for (let i = 0; i < REFS_PER_FRAME; i++) {
        h[`OrderHints[${LAST_FRAME + i}]`] = 0;
      }
    }

    h.disable_cdf_update = b.u(1);  // 指定是否禁用符号解码过程中的CDF更新。features->disable_cdf_update
    if (this.seq_header.seq_force_screen_content_tools == SELECT_SCREEN_CONTENT_TOOLS) {
      h.allow_screen_content_tools = b.u(1);  // =1表示内部块可以使用调色板编码。features->allow_screen_content_tools
    } else {
      h.allow_screen_content_tools = this.seq_header.seq_force_screen_content_tools;
    }
    if (h.allow_screen_content_tools) {
      if (this.seq_header.seq_force_integer_mv == SELECT_INTEGER_MV) {
        h.force_integer_mv = b.u(1);  // = 1指定运动向量将始终是整数；=0指定运动向量可以包含小数位。features->cur_frame_force_integer_mv
      } else {
        h.force_integer_mv = this.seq_header.seq_force_integer_mv;
      }
    } else {
      h.force_integer_mv = 0;
    }
    if (h['FrameIsIntra']) {
      h.force_integer_mv = 1;
    }
    if (this.seq_header.frame_id_numbers_present_flag) {
      h['PrevFrameID'] = h.current_frame_id;
      h.current_frame_id = b.u(idLen);  // 指定当前帧的帧id号。cm->current_frame_id
      this.mark_ref_frames(idLen, { b, h });
    } else {
      h.current_frame_id = 0;
    }
    if (h.frame_type == SWITCH_FRAME)
      h.frame_size_override_flag = 1; // =0指定帧大小等于序列报头中的大小；=1指定帧大小将指定为其中一个参考帧的大小，或者从frame_width_minus_1和frame_height_minus_1语法元素计算。frame_size_override_flag
    else if (this.seq_header.reduced_still_picture_header)
      h.frame_size_override_flag = 0;
    else
      h.frame_size_override_flag = b.u(1);
    h.order_hint = b.u(this.seq_header['OrderHintBits']);
    h['OrderHint'] = h.order_hint;  // 此帧预期输出顺序的最低有效位。current_frame->order_hint
    if (h['FrameIsIntra'] || h.error_resilient_mode) {
      h.primary_ref_frame = PRIMARY_REF_NONE; // 指定哪个参考帧包含CDF值和其他应该在帧开始时加载的状态。features->primary_ref_frame
    } else {
      h.primary_ref_frame = b.u(3);
    }
    if (this.seq_header.decoder_model_info_present_flag) {
      h.buffer_removal_time_present_flag = b.u(1);  // =1表示存在buffer_removal_time。pbi->buffer_removal_time_present
      if (h.buffer_removal_time_present_flag) {
        for (let opNum = 0; opNum <= this.seq_header.operating_points_cnt_minus_1; opNum++) {
          if (this.seq_header[`decoder_model_present_for_this_op[${opNum}]`]) {
            let opPtIdc = this.seq_header[`operating_point_idc[${opNum} ]`];
            let inTemporalLayer = (opPtIdc >> h.temporal_id) & 1;
            let inSpatialLayer = (opPtIdc >> (h.spatial_id + 8)) & 1;
            if (opPtIdc == 0 || (inTemporalLayer && inSpatialLayer)) {
              let n = this.seq_header.buffer_removal_time_length_minus_1 + 1;
              h[`buffer_removal_time[${opNum}]`] = b.u(n);  // 指定帧移除时间，单位为从操作点opNum的最后一个随机接入点移除时间开始计算的DecCT时钟节拍。cm->buffer_removal_times
            }
          }
        }
      }
    }
    h.allow_high_precision_mv = 0;  // =0指定运动矢量指定为四分之一精度；=1指定运动向量被指定为8像素精度。features->allow_high_precision_mv
    h.use_ref_frame_mvs = 0;
    h.allow_intrabc = 0;  // =1表示可以在该帧中使用intra块复制。features->allow_intrabc
    if (h.frame_type == SWITCH_FRAME ||
      (h.frame_type == KEY_FRAME && h.show_frame)) {
      h.refresh_frame_flags = allFrames;  // 包含一个位掩码，该位掩码指定在解码后哪些参考帧槽将使用当前帧更新。current_frame->refresh_frame_flags
    } else {
      h.refresh_frame_flags = b.u(8);
    }
    if (!h['FrameIsIntra'] || h.refresh_frame_flags != allFrames) {
      if (h.error_resilient_mode &&
        this.seq_header.enable_order_hint) {
        for (let i = 0; i < NUM_REF_FRAMES; i++) {
          h[`ref_order_hint[${i}]`] = b.u(this.seq_header['OrderHintBits']); // 指定每个参考帧的预期输出顺序提示。buf->order_hint
          if (h[`ref_order_hint[${i}]`])
            h[`RefValid[${i}]`] = 0;
        }
      }
    }

    if (h['FrameIsIntra']) {
      this.frame_size({ b, h });
      this.render_size({ b, h });
      if (this.seq_header.allow_screen_content_tools &&
        h['UpscaledWidth'] == h['FrameWidth']) {
        h.allow_intrabc = b.u(1);
      }
    } else {
      if (!this.seq_header.enable_order_hint) {
        h.frame_refs_short_signaling = 0; // =1表示只有两个参考帧显式地发出信号；=0表示所有参考帧都显式地发出信号。frame_refs_short_signaling
      } else {
        h.frame_refs_short_signaling = b.u(1);
        if (h.frame_refs_short_signaling) {
          h.last_frame_idx = b.u(3);  // 指定要用于LAST_FRAME的参考帧。lst_ref
          h.gold_frame_idx = b.u(3);  // 指定GOLDEN_FRAME使用的参考帧。gld_ref
          this.set_frame_refs({ b, h });
        }
      }
      for (let i = 0; i < REFS_PER_FRAME; i++) {
        if (!h.frame_refs_short_signaling)
          h[`ref_frame_idx[${i}]`] = b.u(3);  // 指定帧间使用哪些参考帧。
        if (this.seq_header.frame_id_numbers_present_flag) {
          let n = this.seq_header.delta_frame_id_length_minus_2 + 2;
          h.delta_frame_id_minus_1 = b.u(n);
          h['DeltaFrameId'] = h.delta_frame_id_minus_1 + 1; // 指定参考帧到帧id的距离。
        }
      }

      if (this.seq_header.frame_size_override_flag &&
        !this.seq_header.error_resilient_mode) {
        this.frame_size_with_refs({ b, h });
      } else {
        this.frame_size({ b, h });
        this.render_size({ b, h });
      }

      if (h.force_integer_mv) {
        h.allow_high_precision_mv = 0;
      } else {
        h.allow_high_precision_mv = b.u(1);
      }
      this.read_interpolation_filter({ b, h });
      h.is_motion_mode_switchable = b.u(1); // =0指定只使用SIMPLE运动模式。features->switchable_motion_mode
      if (this.seq_header.error_resilient_mode ||
        !this.seq_header.enable_ref_frame_mvs) {
        h.use_ref_frame_mvs = 0;  // = 1指定在解码当前帧时可以使用前一帧的运动矢量信息。features->allow_ref_frame_mvs
      } else {
        h.use_ref_frame_mvs = b.u(1);
      }
      for (let i = 0; i < REFS_PER_FRAME; i++) {
        let refFrame = LAST_FRAME + i;
        let refFrameIdx = h[`ref_frame_idx[${i}]`];
        let hint = h[`RefOrderHint[${refFrameIdx}]`];
        h[`OrderHints[${refFrame}]`] = hint;  // 指定每个参考帧的预期输出顺序。
        if (!this.seq_header.enable_order_hint) {
          h[`RefFrameSignBias[${refFrame}]`] = 0; // 指定每个参考帧的运动矢量在时间上的预期方向。符号偏差等于0表示参考帧是向前参考(即参考帧预计在当前帧之前输出)；符号偏差等于1表示参考系是向后参考系。
        } else {
          h[`RefFrameSignBias[${refFrame}]`] = this.get_relative_dist(hint, h['OrderHint']) > 0;
        }
      }
    }

    if (this.seq_header.reduced_still_picture_header ||
      h.disable_cdf_update)
      h.disable_frame_end_update_cdf = 1; // =0表示启用帧结束CDF更新。features->refresh_frame_context
    else
      h.disable_frame_end_update_cdf = b.u(1);

    if (h.primary_ref_frame == PRIMARY_REF_NONE) {
      this.init_non_coeff_cdfs({ b, h });
      this.setup_past_independence({ b, h });
    } else {
      this.load_cdfs(h[`ref_frame_idx[${h.primary_ref_frame}]`], { b, h });
      this.load_previous();
    }
    if (h.use_ref_frame_mvs == 1)
      this.motion_field_estimation({ b, h });
    this.tile_info({ b, h });
    this.quantization_params({ b, h });
    this.segmentation_params({ b, h });
    this.delta_q_params({ b, h });
    this.delta_lf_params({ b, h });
    if (h.primary_ref_frame == PRIMARY_REF_NONE) {
      this.init_coeff_cdfs({ b, h });
    } else {
      this.load_previous_segment_ids({ b, h });
    }
    h['CodedLossless'] = 1; // 是一个变量，当所有片段都使用无损编码时，该变量等于1；在这种情况下，循环过滤器和CDEF过滤器被禁用。
    for (let segmentId = 0; segmentId < MAX_SEGMENTS; segmentId++) {
      let qindex = this.get_qindex({ h }, 1, segmentId);
      h[`LosslessArray[${segmentId}]`] = qindex == 0 && h['DeltaQYDc'] == 0 &&
        h['DeltaQUAc'] == 0 && h['DeltaQUDc'] == 0 &&
        h['DeltaQVAc'] == 0 && h['DeltaQVDc'] == 0;
      if (!h[`LosslessArray[${segmentId}]`]) {
        h['CodedLossless'] = 0;
      }
      if (h.using_qmatrix) {
        if (h[`LosslessArray[${segmentId}]`]) {
          h[`SegQMLevel[0][${segmentId}]`] = 15;
          h[`SegQMLevel[1][${segmentId}]`] = 15;
          h[`SegQMLevel[2][${segmentId}]`] = 15;
        } else {
          h[`SegQMLevel[0][${segmentId}]`] = h.qm_y;
          h[`SegQMLevel[1][${segmentId}]`] = h.qm_u;
          h[`SegQMLevel[2][${segmentId}]`] = h.qm_v;
        }
      }
      h[`qindex[${segmentId}]`] = qindex; // xd->qindex
    }
    h['AllLossless'] = h['CodedLossless'] && (h['FrameWidth'] == h['UpscaledWidth']);
    this.loop_filter_params({ b, h });
    this.cdef_params({ b, h });
    this.lr_params({ b, h });
    this.read_tx_mode({ b, h });
    this.frame_reference_mode({ b, h });
    this.skip_mode_params({ b, h });
    if (h['FrameIsIntra'] || h.error_resilient_mode ||
      !this.seq_header.enable_warped_motion)
      h.allow_warped_motion = 0;  // =1表示可能存在语法元素motion_mode。features->allow_warped_motion
    else
      h.allow_warped_motion = b.u(1);
    h.reduced_tx_set = b.u(1);  //  =1指定帧被限制为转换类型的完整集合的简化子集。features->reduced_tx_set_used
    if (h.use_ref_frame_mvs &&
      !(!h.error_resilient_mode &&
        this.seq_header.enable_ref_frame_mvs &&
        this.seq_header.enable_order_hint &&
        !(h.frame_type == KEY_FRAME || h.frame_type == INTRA_ONLY_FRAME))) {
      console.error("Frame wrongly requests reference frame MVs");
    }
    this.global_motion_params({ b, h });
    this.film_grain_params({ b, h });
  };

  // 5.9.3. Get relative distance function
  get_relative_dist(a: number, b: number) {
    if (!this.seq_header.enable_order_hint)
      return 0;
    let diff = a - b;
    let m = 1 << (this.seq_header['OrderHintBits'] - 1);
    diff = (diff & (m - 1)) - (diff & m);
    return diff;
  };

  // 5.9.4. Reference frame marking function
  mark_ref_frames(idLen: number, { b, h }: { b: BitReader, h: any }) {
    let diffLen = h.delta_frame_id_length_minus_2 + 2;
    for (let i = 0; i < NUM_REF_FRAMES; i++) {
      if (h.current_frame_id > (1 << diffLen)) {
        if (h[`RefFrameId[${i}]`] > h.current_frame_id ||
          h[`RefFrameId[${i}]`] < (h.current_frame_id - (1 << diffLen)))
          h[`RefValid[${i}]`] = 0;  // 数组中的值为1表示对应的参考图片槽可以作为参考图片使用。pbi->valid_for_referencing
      } else {
        if (h[`RefFrameId[${i}]`] > h.current_frame_id &&
          h[`RefFrameId[${i}]`] < ((1 << idLen) +
            h.current_frame_id -
            (1 << diffLen)))
          h[`RefValid[${i}]`] = 0;
      }
    }
  }

  // 5.9.5. Frame size syntax
  frame_size({ b, h }: { b: BitReader, h: any }) {
    if (h.frame_size_override_flag) {
      let n = this.seq_header.frame_width_bits_minus_1 + 1;
      h.frame_width_minus_1 = b.u(n);
      n = this.seq_header.frame_height_bits_minus_1 + 1;
      h.frame_height_minus_1 = b.u(n);
      h['FrameWidth'] = h.frame_width_minus_1 + 1;    // 亮度样本中帧的宽。cm->superres_upscaled_width
      h['FrameHeight'] = h.frame_height_minus_1 + 1;  // 亮度样本中帧的高。cm->superres_upscaled_height
      if (h.frame_width_minus_1 > this.seq_header.max_frame_width_minus_1 ||
        h.frame_height_minus_1 > this.seq_header.max_frame_height_minus_1) {
        console.error("Frame dimensions are larger than the maximum values");
      }
    } else {
      h['FrameWidth'] = this.seq_header.max_frame_width_minus_1 + 1;
      h['FrameHeight'] = this.seq_header.max_frame_height_minus_1 + 1;
    }

    this.superres_params({ b, h });
    this.compute_image_size({ b, h });
  };

  // 5.9.6. Render size syntax
  // 呈现大小作为提示提供给应用程序关于所需的显示大小。它对解码过程没有影响。
  render_size({ b, h }: { b: BitReader, h: any }) {
    h.render_and_frame_size_different = b.u(1);         //  =0意味着渲染宽度和高度是从帧宽度和高度推断出来的。temp
    if (h.render_and_frame_size_different == 1) {
      h.render_width_minus_1 = b.u(16);
      h.render_height_minus_1 = b.u(16);
      h['RenderWidth'] = h.render_width_minus_1 + 1;    // 亮度样本中帧的渲染宽度。cm->render_width
      h['RenderHeight'] = h.render_height_minus_1 + 1;  // 亮度样本中帧的渲染高度。cm->render_height
    } else {
      h['RenderWidth'] = h['UpscaledWidth'];
      h['RenderHeight'] = h['FrameHeight'];
    }
  };

  // 5.9.7. Frame size with refs syntax
  // 对于帧间，帧大小要么被设置为等于参考帧的大小，要么可以显式发送。
  frame_size_with_refs({ b, h }: { b: BitReader, h: any }) {
    for (let i = 0; i < REFS_PER_FRAME; i++) {
      h.found_ref = b.u(1); // = 1表示可以从参考帧I推断出帧的尺寸。temp
      if (h.found_ref == 1) {
        let ref_frame_idx = h[`ref_frame_idx[${i}]`];
        h['UpscaledWidth'] = h[`RefUpscaledWidth[${ref_frame_idx}]`];
        h['FrameWidth'] = h['UpscaledWidth'];
        h['FrameHeight'] = h[`RefFrameHeight[${ref_frame_idx}]`];
        h['RenderWidth'] = h[`RefRenderWidth[${ref_frame_idx}]`];
        h['RenderHeight'] = h[`RefRenderHeight[${ref_frame_idx}]`];
        break;
      }
    }
    if (h.found_ref == 0) {
      this.frame_size({ b, h });
      this.render_size({ b, h });
    } else {
      this.superres_params({ b, h });
      this.compute_image_size({ b, h });
    }
  }

  // 5.9.8. Superres params syntax
  superres_params({ b, h }: { b: BitReader, h: any }) {
    if (this.seq_header.enable_superres)
      h.use_superres = b.u(1);  // =0表示不需要升级。temp
    else
      h.use_superres = 0;
    if (h.use_superres) {
      h.coded_denom = b.u(SUPERRES_DENOM_BITS); // 用于计算升级的数量。
      h['SuperresDenom'] = h.coded_denom + SUPERRES_DENOM_MIN;
    } else {
      h['SuperresDenom'] = SUPERRES_NUM;  // 是一个分数的分母，它指定了升级前后超级块宽度之间的比率。这个分数的分子等于常量SUPERRES_NUM。cm->superres_scale_denominator
    }
    h['UpscaledWidth'] = h['FrameWidth'];
    h['FrameWidth'] = ((h['UpscaledWidth'] * SUPERRES_NUM +
      (h['SuperresDenom'] / 2)) / h['SuperresDenom']);
  };

  // 5.9.9. Compute image size function
  compute_image_size({ b, h }: { b: BitReader, h: any }) {
    h['MiCols'] = 2 * ((h['FrameWidth'] + 7) >> 3);   // 是框架中4x4块列的数量。
    h['MiRows'] = 2 * ((h['FrameHeight'] + 7) >> 3);  // 是框架中4x4块行的数量
  }

  // 5.9.10. Interpolation filter syntax
  read_interpolation_filter({ b, h }: { b: BitReader, h: any }) {
    h.is_filter_switchable = b.u(1);  // =1表示过滤器选择在块级发出信号；=0表示在帧级发出过滤器选择的信号。temp
    if (h.is_filter_switchable == 1) {
      h.interpolation_filter = SWITCHABLE;  // features->interp_filter
    } else {
      h.interpolation_filter = b.u(2);
    }
  }

  // 5.9.11. Loop filter params syntax
  loop_filter_params({ b, h }: { b: BitReader, h: any }) {
    if (h['CodedLossless'] || h.allow_intrabc) {
      h['loop_filter_level[0]'] = 0;                    // 包含循环过滤器强度值的数组；根据要过滤的图像平面和要过滤的边缘方向(垂直或水平)，使用来自阵列的不同环路滤波器强度值。lf->filter_level[0]
      h['loop_filter_level[1]'] = 0;                    // lf->filter_level[1]
      h[`loop_filter_ref_deltas[${INTRA_FRAME}]`] = 1;
      h[`loop_filter_ref_deltas[${LAST_FRAME}]`] = 0;
      h[`loop_filter_ref_deltas[${LAST2_FRAME}]`] = 0;
      h[`loop_filter_ref_deltas[${LAST3_FRAME}]`] = 0;
      h[`loop_filter_ref_deltas[${BWDREF_FRAME}]`] = 0;
      h[`loop_filter_ref_deltas[${GOLDEN_FRAME}]`] = -1;
      h[`loop_filter_ref_deltas[${ALTREF_FRAME}]`] = -1;
      h[`loop_filter_ref_deltas[${ALTREF2_FRAME}]`] = -1;
      for (let i = 0; i < 2; i++) {
        h[`loop_filter_mode_deltas[${i}]`] = 0;
      }
      return;
    }
    h['loop_filter_level[0]'] = b.u(6);
    h['loop_filter_level[1]'] = b.u(6);
    if (this.seq_header['NumPlanes'] > 1) {
      if (h['loop_filter_level[0]'] || h['loop_filter_level[1]']) {
        h['loop_filter_level[2]'] = b.u(6); // lf->filter_level_u
        h['loop_filter_level[3]'] = b.u(6); // lf->filter_level_v
      }
    }
    h.loop_filter_sharpness = b.u(3);       // 表示锐度级别。loop_filter_level和loop_filter_sharpness一起决定何时对块边缘进行过滤，以及过滤可以改变采样值的程度。lf->sharpness_level
    h.loop_filter_delta_enabled = b.u(1);   // =1意味着过滤器级别取决于用于预测块的模式和参考帧。lf->mode_ref_delta_enabled
    if (h.loop_filter_delta_enabled) {
      h.loop_filter_delta_update = b.u(1);  // =1意味着存在额外的语法元素，指定要更新哪个模式和参考框架增量。lf->mode_ref_delta_update
      if (h.loop_filter_delta_update) {
        for (let i = 0; i < TOTAL_REFS_PER_FRAME; i++) {
          let update_ref_delta = b.u(1);  // temp
          if (update_ref_delta) {
            h[`loop_filter_ref_deltas[${i}]`] = b.su(1 + 6);  // 包含基于所选参考框架的过滤器级别所需的调整；如果此语法元素不存在，则保持其先前的值。lf->ref_deltas
          }
          h[`update_ref_delta[${i}]`] = update_ref_delta;
        }
        for (let i = 0; i < 2; i++) {
          let update_mode_delta = b.u(1); // temp
          if (update_mode_delta) {
            h[`loop_filter_mode_deltas[${i}]`] = b.su(1 + 6); // 包含基于所选模式的过滤器级别所需的调整；如果此语法元素不存在，则保持其先前的值。lf->mode_deltas
          }
          h[`update_mode_delta[${i}]`] = update_mode_delta;
        }
      }
    }
  };

  // 5.9.12. Quantization params syntax
  // 残差是通过解码系数来确定的，这些解码系数在应用逆变换之前由四个量化参数之一进行调整。选择取决于平面(Y或UV)和系数位置(DC/AC系数)。第7.12节规定了去量化过程。
  quantization_params({ b, h }: { b: BitReader, h: any }) {
    h.base_q_idx = b.u(8);                        // 表示基帧qindex；这用于Y AC系数，并作为其他量化器的基值。quant_params->base_qindex
    h['DeltaQYDc'] = this.read_delta_q({ b, h }); // 表示相对于base_q_idx的Y DC量化器。quant_params->y_dc_delta_q
    if (this.seq_header['NumPlanes'] > 1) {
      if (this.seq_header.separate_uv_delta_q)
        h.diff_uv_delta = b.u(1); // =1表示U和V增量量化器值分别编码。=0表示U和V增量量化器值共享一个公共值。temp
      else
        h.diff_uv_delta = 0;
      h['DeltaQUDc'] = this.read_delta_q({ b, h }); // 表示相对于base_q_idx的U DC量化器。quant_params->u_dc_delta_q
      h['DeltaQUAc'] = this.read_delta_q({ b, h }); // 表示相对于base_q_idx的U AC量化器。quant_params->u_ac_delta_q
      if (h.diff_uv_delta) {
        h['DeltaQVDc'] = this.read_delta_q({ b, h }); // 表示相对于base_q_idx的V DC量化器。quant_params->v_dc_delta_q
        h['DeltaQVAc'] = this.read_delta_q({ b, h }); // 表示相对于base_q_idx的V AC量化器。quant_params->v_ac_delta_q
      } else {
        h['DeltaQVDc'] = h['DeltaQUDc'];
        h['DeltaQVAc'] = h['DeltaQUAc'];
      }
    } else {
      h['DeltaQUDc'] = 0;
      h['DeltaQUAc'] = 0;
      h['DeltaQVDc'] = 0;
      h['DeltaQVAc'] = 0;
    }
    h.using_qmatrix = b.u(1); // 指定量化器矩阵将用于计算量化器。quant_params->using_qmatrix
    if (h.using_qmatrix) {
      h.qm_y = b.u(4);    // 指定量化器矩阵中应该用于亮度平面解码的级别。quant_params->qmatrix_level_y
      h.qm_u = b.u(4);    // 指定量化器矩阵中应该用于色度U平面解码的级别。quant_params->qmatrix_level_u
      if (!this.seq_header.separate_uv_delta_q)
        h.qm_v = h.qm_u;  // 指定量化器矩阵中应该用于色度V平面解码的级别。quant_params->qmatrix_level_v
      else
        h.qm_v = b.u(4);
    }
  };

  // 5.9.13. Delta quantizer syntax
  read_delta_q({ b, h }: { b: BitReader, h: any }) {
    let delta_q = 0;
    let delta_coded = b.u(1);
    if (delta_coded) delta_q = b.su(1 + 6);
    return delta_q;
  };

  // 5.9.14. Segmentation params syntax
  /* AV1提供了一种分割图像的方法，然后在分割级别应用各种调整。
    对于任何给定的帧，最多可以指定8个片段。对于这些部分，可以指定:
      1.量化器(绝对值或增量)。
      2.环路滤波器强度(绝对值或增量)。
      3.预测参考系。
      4.一种块跳过模式，意味着使用(0,0)运动向量，并且没有残差将被编码。
    每个片段的这些数据值都可以在帧级单独更新。如果一个值在给定的帧中没有更新，那么前一帧的值将保持不变。例外情况是关键帧、内部帧或其他需要独立于过去帧值的帧(例如，启用错误恢复能力)。在这种情况下，所有值都按照setup_past_independence语义中的描述进行重置。
    段关联(分段映射)以4x4块的分辨率存储。如果没有为块的段关联编码显式更新，那么它将从一帧持续到另一帧(直到通过调用setup_past_independence重置)。
   */
  segmentation_params({ b, h }: { b: BitReader, h: any }) {
    const Segmentation_Feature_Bits = [8, 6, 6, 6, 6, 3, 0, 0];
    const Segmentation_Feature_Signed = [1, 1, 1, 1, 1, 0, 0, 0];
    const Segmentation_Feature_Max = [255, MAX_LOOP_FILTER, MAX_LOOP_FILTER, MAX_LOOP_FILTER, MAX_LOOP_FILTER, 7, 0, 0];

    h.segmentation_enabled = b.u(1);  // =1表示此帧使用分段。seg->enabled
    if (h.segmentation_enabled == 1) {
      if (h.primary_ref_frame == PRIMARY_REF_NONE) {
        h.segmentation_update_map = 1;      // =1表示在该帧的解码过程中更新了分段映射；=0表示使用前一帧的分段映射。seg->update_map
        h.segmentation_temporal_update = 0; // =1表示对分段映射的更新是相对于现有分段映射进行编码的；=0表示在不引用现有分段映射的情况下对新的分段映射进行编码。seg->temporal_update
        h.segmentation_update_data = 1;     // =1表示即将为每个段指定新参数；=0表示分割参数应保持其现有值。seg->update_data
      } else {
        h.segmentation_update_map = b.u(1);
        if (h.segmentation_update_map == 1)
          h.segmentation_temporal_update = b.u(1);
        h.segmentation_update_data = b.u(1);
      }
      if (h.segmentation_update_data == 1) {
        for (let i = 0; i < MAX_SEGMENTS; i++) {
          for (let j = 0; j < SEG_LVL_MAX; j++) {
            let feature_value = 0;  // 指定段特征的特征数据
            let feature_enabled = b.u(1); // temp
            h[`FeatureEnabled[${i}][${j}]`] = feature_enabled;
            let clippedValue = 0;
            if (feature_enabled) {
              let bitsToRead = Segmentation_Feature_Bits[j];
              let limit = Segmentation_Feature_Max[j];
              if (Segmentation_Feature_Signed[j] == 1) {
                feature_value = b.su(1 + bitsToRead);
                clippedValue = this.Clip3(-limit, limit, feature_value);
              } else {
                feature_value = b.u(bitsToRead);
                clippedValue = this.Clip3(0, limit, feature_value);
              }
            }
            h[`FeatureData[${i}][${j}]`] = clippedValue;  // seg->feature_data
            h[`feature_value[${i}][${j}]`] = feature_value;
            h[`feature_enabled[${i}][${j}]`] = feature_enabled;
          }
        }
      }
    } else {
      for (let i = 0; i < MAX_SEGMENTS; i++) {
        for (let j = 0; j < SEG_LVL_MAX; j++) {
          h[`FeatureEnabled[${i}][${j}]`] = 0;
          h[`FeatureData[${i}][${j}]`] = 0;
        }
      }
    }
    h['SegIdPreSkip'] = 0;    // =1表示将在跳过语法元素之前读取段id。=0表示将首先读取跳过语法元素。
    h['LastActiveSegId'] = 0; // 表示已启用某些特性的最高编号段id。这在解码段id时使用，只解码与使用的段对应的选择。
    for (let i = 0; i < MAX_SEGMENTS; i++) {
      for (let j = 0; j < SEG_LVL_MAX; j++) {
        if (h[`FeatureEnabled[${i}][${j}]`]) {
          h['LastActiveSegId'] = i;
          if (j >= SEG_LVL_REF_FRAME) {
            h['SegIdPreSkip'] = 1;
          }
        }
      }
    }
  };

  // 5.9.15. Tile info syntax
  tile_info({ b, h }: { b: BitReader, h: any }) {
    let sbCols = this.seq_header.use_128x128_superblock ? ((h['MiCols'] + 31) >> 5) : ((h['MiCols'] + 15) >> 4);
    let sbRows = this.seq_header.use_128x128_superblock ? ((h['MiRows'] + 31) >> 5) : ((h['MiRows'] + 15) >> 4);
    let sbShift = this.seq_header.use_128x128_superblock ? 5 : 4
    let sbSize = sbShift + 2;
    let maxTileWidthSb = MAX_TILE_WIDTH >> sbSize;
    let maxTileAreaSb = MAX_TILE_AREA >> (2 * sbSize);
    let minLog2TileCols = this.tile_log2(maxTileWidthSb, sbCols);             // tiles->min_log2_cols
    let maxLog2TileCols = this.tile_log2(1, Math.min(sbCols, MAX_TILE_COLS)); // tiles->max_log2_cols
    let maxLog2TileRows = this.tile_log2(1, Math.min(sbRows, MAX_TILE_ROWS)); // tiles->max_log2_rows
    let minLog2Tiles =
      Math.max(minLog2TileCols, this.tile_log2(maxTileAreaSb, sbRows * sbCols))

    h.uniform_tile_spacing_flag = b.u(1); // =1表示贴图在整个框架中均匀间隔(换句话说，所有的贴图都是相同的大小，除了右边和底部边缘的那些可以更小)；=0意味着贴图的大小是编码的。tiles->uniform_spacing
    if (h.uniform_tile_spacing_flag) {
      h['TileColsLog2'] = minLog2TileCols;
      while (h['TileColsLog2'] < maxLog2TileCols) {
        let increment_tile_cols_log2 = b.u(1);  // temp
        if (increment_tile_cols_log2 == 1)
          h['TileColsLog2']++;  // 指定整个框架所需的贴图数的以2为底的对数。tiles->log2_cols
        else
          break;
      }
      let tileWidthSb = (sbCols + (1 << h['TileColsLog2']) - 1) >> h['TileColsLog2']; // 用于以超级块为单位指定每个块的宽度。小于maxTileWidthSb是位流一致性的要求。
      let i = 0;
      for (let startSb = 0; startSb < sbCols; startSb += tileWidthSb) {
        h[`MiColStarts[${i}]`] = startSb << sbShift;  // 指定图像上每个贴图的开始列(以4x4亮度样本为单位)。
        i += 1;
      }
      h[`MiColStarts[${i}]`] = h['MiCols'];
      h['TileCols'] = i;  // 指定整个框架的贴图数量；比特流一致性的要求是TileCols小于或等于MAX_TILE_COLS。

      let minLog2TileRows = Math.max(minLog2Tiles - h['TileColsLog2'], 0);  // tiles->min_log2_rows
      h['TileRowsLog2'] = minLog2TileRows;
      while (h['TileRowsLog2'] < maxLog2TileRows) {
        let increment_tile_rows_log2 = b.u(1);  // temp
        if (increment_tile_rows_log2 == 1)
          h['TileRowsLog2']++;  // 指定在框架中所需的贴图数的以2为底的对数。tiles->log2_rows
        else
          break;
      }
      let tileHeightSb = (sbRows + (1 << h['TileRowsLog2']) - 1) >> h['TileRowsLog2'];  // 用于以超级块为单位指定每个贴图的高度。tileWidthSb*tileHeightSb小于maxTileAreaSb是位流一致性的要求。
      i = 0;
      for (let startSb = 0; startSb < sbRows; startSb += tileHeightSb) {
        h[`MiRowStarts[${i}]`] = startSb << sbShift;  // 指定图像中每个贴图的起始行(以4x4亮度样本为单位)。
        i += 1;
      }
      h[`MiRowStarts[${i}]`] = h['MiRows'];
      h['TileRows'] = i;  // 指定了整个框架的瓷砖数量。bitstream一致性要求TileRows小于或等于MAX_TILE_ROWS。
    } else {
      let widestTileSb = 0;
      let startSb = 0;
      let sizeSb = 0;
      let i;
      for (i = 0; startSb < sbCols; i++) {
        h[`MiColStarts[${i}]`] = startSb << sbShift;
        let maxWidth = Math.min(sbCols - startSb, maxTileWidthSb);
        h.width_in_sbs_minus_1 = b.ns(maxWidth);  // 指定贴图的宽度，以超级块为单位。
        let sizeSb = h.width_in_sbs_minus_1 + 1;
        widestTileSb = Math.max(sizeSb, widestTileSb);
        startSb += sizeSb;
      }
      h[`MiColStarts[${i}]`] = h['MiCols'];
      h['TileCols'] = i;
      h['TileColsLog2'] = this.tile_log2(1, h['TileCols']);

      let maxTileAreaSb = 0;
      if (minLog2Tiles > 0)
        maxTileAreaSb = (sbRows * sbCols) >> (minLog2Tiles + 1);
      else
        maxTileAreaSb = sbRows * sbCols;
      let maxTileHeightSb = Math.max(maxTileAreaSb / widestTileSb, 1);  // 指定可用于瓷砖的最大高度(以超级块为单位)(以避免制作面积过大的瓷砖)。

      startSb = 0;
      for (i = 0; startSb < sbRows; i++) {
        h[`MiRowStarts[${i}]`] = startSb << sbShift;
        let maxHeight = Math.min(sbRows - startSb, maxTileHeightSb);
        h.height_in_sbs_minus_1 = b.ns(maxHeight);  // 指定贴图的高度，以超级块为单位。
        sizeSb = h.height_in_sbs_minus_1 + 1;
        startSb += sizeSb;
      }
      h[`MiRowStarts[${i}]`] = h['MiRows'];
      h['TileRows'] = i;
      h['TileRowsLog2'] = this.tile_log2(1, h['TileRows']);
    }
    if (h['TileColsLog2'] > 0 || h['TileRowsLog2'] > 0) {
      h.context_update_tile_id = b.u(h['TileRowsLog2'] + h['TileColsLog2']);  // 指定要为CDF更新使用哪个tile
      h.tile_size_bytes_minus_1 = b.u(2);
      h['TileSizeBytes'] = h.tile_size_bytes_minus_1 + 1; // 指定编码每个贴图大小所需的字节数。
    } else {
      h.context_update_tile_id = 0;
    }
  };

  // 5.9.16. Tile size calculation function
  tile_log2(blkSize: number, target: number) {
    let k = 0;
    for (k = 0; (blkSize << k) < target; k++) {
    }
    return k;
  };

  // 5.9.17. Quantizer index delta parameters syntax
  delta_q_params({ b, h }: { b: BitReader, h: any }) {
    h.delta_q_res = 0;
    h.delta_q_present = 0;  // 指定量化器索引增量值是否存在。cm->delta_q_info.delta_q_present_flag
    if (h.base_q_idx > 0) {
      h.delta_q_present = b.u(1);
    }
    if (h.delta_q_present) {
      h.delta_q_res = b.u(2);     // 指定应应用于解码量化器索引增量值的左移。cm->delta_q_info.delta_q_res
    }
  };

  // 5.9.18. Loop filter delta parameters syntax
  delta_lf_params({ b, h }: { b: BitReader, h: any }) {
    h.delta_lf_present = 0; // 指定是否存在循环过滤器的增量值。
    h.delta_lf_res = 0;     // 指定应应用于解码循环滤波器增量值的左移。
    h.delta_lf_multi = 0;   // =1指定为水平亮度边缘、垂直亮度边缘、U边缘和V边缘发送单独的环路滤波器；=0指定对所有边使用相同的环路滤波器delta。
    if (h.delta_q_present) {
      if (!h.allow_intrabc) {
        h.delta_lf_present = b.u(1);  // cm->delta_q_info.delta_lf_present_flag
      }
      if (h.delta_lf_present) {
        h.delta_lf_res = b.u(2);    // cm->delta_q_info.delta_lf_res
        h.delta_lf_multi = b.u(1);  // cm->delta_q_info.delta_lf_multi
      }
    }
  };

  // 5.9.19. CDEF params syntax
  cdef_params({ b, h }: { b: BitReader, h: any }) {
    if (h['CodedLossless'] || h.allow_intrabc ||
      !this.seq_header.enable_cdef) {
      h.cdef_bits = 0;
      h['cdef_y_pri_strength[0]'] = 0;  // 指定主过滤器的强度。
      h['cdef_y_sec_strength[0]'] = 0;  // 指定二级过滤器的强度。
      h['cdef_uv_pri_strength[0]'] = 0; // 指定主过滤器的强度。
      h['cdef_uv_sec_strength[0]'] = 0; // 指定二级过滤器的强度。
      h['CdefDamping'] = 3;
      return;
    }
    h.cdef_damping_minus_3 = b.u(2);
    h['CdefDamping'] = h.cdef_damping_minus_3 + 3;  // 控制衰减滤波器中的阻尼量。cdef_info->cdef_damping
    h.cdef_bits = b.u(2); // 定指定应用哪个CDEF过滤器所需的位数。cdef_info->cdef_bits
    for (let i = 0; i < (1 << h.cdef_bits); i++) {
      h[`cdef_y_pri_strength[${i}]`] = b.u(4);  // cdef_info->cdef_strengths
      h[`cdef_y_sec_strength[${i}]`] = b.u(2);  // cdef_info->cdef_strengths
      if (h[`cdef_y_sec_strength[${i}]`] == 3) {
        h[`cdef_y_sec_strength[${i}]`] += 1;
      }
      if (this.seq_header['NumPlanes'] > 1) {
        h[`cdef_uv_pri_strength[${i}]`] = b.u(4); // cdef_info->cdef_uv_strengths
        h[`cdef_uv_sec_strength[${i}]`] = b.u(2); // cdef_info->cdef_uv_strengths
        if (h[`cdef_uv_sec_strength[${i}]`] == 3) {
          h[`cdef_uv_sec_strength[${i}]`] += 1;
        }
      }
    }
  };

  // 5.9.20. Loop restoration params syntax
  lr_params({ b, h }: { b: BitReader, h: any }) {
    if (h['AllLossless'] || h.allow_intrabc ||
      !this.seq_header.enable_restoration) {
      h['FrameRestorationType[0]'] = RESTORE_NONE;
      h['FrameRestorationType[1]'] = RESTORE_NONE;
      h['FrameRestorationType[2]'] = RESTORE_NONE;
      h['UsesLr'] = 0;
      return;
    }
    const Remap_Lr_Type = [RESTORE_NONE, RESTORE_SWITCHABLE, RESTORE_WIENER, RESTORE_SGRPROJ];
    h['UsesLr'] = 0;  // 表示是否有平面使用环路恢复。
    let usesChromaLr = 0;
    for (let i = 0; i < this.seq_header['NumPlanes']; i++) {
      /** +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       *  | lr_type | FrameRestorationType| Name of FrameRestorationType|
       *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       *  |    0    |          0          |      RESTORE_NONE           |
       *  |    1    |          3          |      RESTORE_SWITCHABLE     |
       *  |    2    |          1          |      RESTORE_WIENER         |
       *  |    3    |          2          |      RESTORE_SGRPROJ        |
       *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       */
      let lr_type = b.u(2);
      h[`FrameRestorationType[${i}]`] = Remap_Lr_Type[lr_type]; // rsi->frame_restoration_type
      if (h[`FrameRestorationType[${i}]`] != RESTORE_NONE) {
        h['UsesLr'] = 1;
        if (i > 0) {
          usesChromaLr = 1
        }
      }
      h[`lr_type[${i}]`] = lr_type;
    }
    if (h['UsesLr']) {
      if (this.seq_header.use_128x128_superblock) {
        h.lr_unit_shift = b.u(1); // rsi->restoration_unit_size
        h.lr_unit_shift++;
      } else {
        h.lr_unit_shift = b.u(1);
        if (h.lr_unit_shift) {
          h.lr_unit_extra_shift = b.u(1); // 指定亮度恢复大小是否应该再次减半。
          h.lr_unit_shift += h.lr_unit_extra_shift;
        }
      }
      h['LoopRestorationSize[0]'] = RESTORATION_TILESIZE_MAX >> (2 - h.lr_unit_shift);
      if (this.seq_header.subsampling_x && this.seq_header.subsampling_y && usesChromaLr) {
        h.lr_uv_shift = b.u(1); // 仅适用于4:2:0格式，并指定色度大小是否应该是亮度大小的一半。
      } else {
        h.lr_uv_shift = 0;
      }
      h['LoopRestorationSize[1]'] = h['LoopRestorationSize[0]'] >> h.lr_uv_shift; // 指定当前平面中以样本为单位的环路恢复单元的大小。
      h['LoopRestorationSize[2]'] = h['LoopRestorationSize[0]'] >> h.lr_uv_shift;
    }
  };

  // 5.9.21. TX mode syntax
  read_tx_mode({ b, h }: { b: BitReader, h: any }) {
    if (h['CodedLossless'] == 1) {
      h['TxMode'] = ONLY_4X4; // eatures->tx_mode
    } else {
      h.tx_mode_select = b.u(1);  // temp
      if (h.tx_mode_select) {
        h['TxMode'] = TX_MODE_SELECT;
      } else {
        h['TxMode'] = TX_MODE_LARGEST;
      }
    }
  }

  // 5.9.22. Skip mode params syntax
  skip_mode_params({ b, h }: { b: BitReader, h: any }) {
    let skipModeAllowed;
    if (h['FrameIsIntra'] || !h.reference_select || !this.seq_header.enable_order_hint) {
      skipModeAllowed = 0;
    } else {
      let forwardIdx = -1;
      let backwardIdx = -1;
      let forwardHint = -1;
      let backwardHint = 0;
      for (let i = 0; i < REFS_PER_FRAME; i++) {
        let refFrameIdx = h[`ref_frame_idx[${i}`];
        let refHint = h[`RefOrderHint[${refFrameIdx}]`];
        if (this.get_relative_dist(refHint, h['OrderHint']) < 0) {
          if (forwardIdx < 0 ||
            this.get_relative_dist(refHint, forwardHint) > 0) {
            forwardIdx = i;
            forwardHint = refHint;
          }
        } else if (this.get_relative_dist(refHint, h['OrderHint']) > 0) {
          if (backwardIdx < 0 ||
            this.get_relative_dist(refHint, backwardHint) < 0) {
            backwardIdx = i;
            backwardHint = refHint;
          }
        }
      }
      if (forwardIdx < 0) {
        skipModeAllowed = 0;
      } else if (backwardIdx >= 0) {
        skipModeAllowed = 1;
        h['SkipModeFrame[0]'] = LAST_FRAME + Math.min(forwardIdx, backwardIdx); // 指定了当skip_mode等于1时用于复合预测的帧。
        h['SkipModeFrame[1]'] = LAST_FRAME + Math.max(forwardIdx, backwardIdx)
      } else {
        let secondForwardIdx = -1;
        let secondForwardHint = -1;
        for (let i = 0; i < REFS_PER_FRAME; i++) {
          let refFrameIdx = h[`ref_frame_idx${i}`];
          let refHint = h[`RefOrderHint[${refFrameIdx}]`];
          if (this.get_relative_dist(refHint, forwardHint) < 0) {
            if (secondForwardIdx < 0 ||
              this.get_relative_dist(refHint, secondForwardHint) > 0) {
              secondForwardIdx = i;
              secondForwardHint = refHint;
            }
          }
        }
        if (secondForwardIdx < 0) {
          skipModeAllowed = 0;
        } else {
          skipModeAllowed = 1;
          h['SkipModeFrame[0]'] = LAST_FRAME + Math.min(forwardIdx, secondForwardIdx);
          h['SkipModeFrame[1]'] = LAST_FRAME + Math.max(forwardIdx, secondForwardIdx);
        }
      }
    }
    if (skipModeAllowed) {
      h.skip_mode_present = b.u(1); // =1指定语法元素skip_mode将出现；=0指定skip_mode不用于此帧。current_frame->skip_mode_info.skip_mode_flag
    } else {
      h.skip_mode_present = 0;
    }
  };

  // 5.9.23. Frame reference mode syntax
  frame_reference_mode({ b, h }: { b: BitReader, h: any }) {
    if (h['FrameIsIntra']) {
      h.reference_select = 0; // =1指定块间的模式信息包含语法元素comp_mode，该元素指示是使用单个引用预测还是复合引用预测。=0指定所有inter block将使用单个预测。
    } else {
      h.reference_select = b.u(1);  // current_frame->reference_mode
    }
  }

  // 5.9.24. Global motion params syntax
  global_motion_params({ b, h }: { b: BitReader, h: any }) {
    for (let ref = LAST_FRAME; ref <= ALTREF_FRAME; ref++) {
      h[`GmType[${ref}]`] = IDENTITY;
      for (let i = 0; i < 6; i++) {
        h[`gm_params[${ref}][${i}]`] = ((i % 3 == 2) ? 1 << WARPEDMODEL_PREC_BITS : 0);
      }
    }
    if (h['FrameIsIntra']) {
      return;
    }
    for (let ref = LAST_FRAME; ref <= ALTREF_FRAME; ref++) {
      h[`is_global[${ref}]`] = b.u(1);  // 指定是否存在特定参考帧的全局运动参数。
      let type; // params->wmtype
      if (h[`is_global[${ref}]`]) {
        h[`is_rot_zoom[${ref}]`] = b.u(1);  // 指定特定参考帧是否使用旋转和缩放全局运动。temp
        if (h[`is_rot_zoom[${ref}]`]) {
          type = ROTZOOM;
        } else {
          h[`is_translation[${ref}]`] = b.u(1); // 指定一个特定的参考系是否使用平移全局运动。temp
          type = h[`is_translation[${ref}]`] ? TRANSLATION : AFFINE;
        }
      } else {
        type = IDENTITY;
      }
      h[`GmType[${ref}]`] = type;
      if (type >= ROTZOOM) {
        this.read_global_param(type, ref, 2, { b, h });
        this.read_global_param(type, ref, 3, { b, h });
        if (type == AFFINE) {
          this.read_global_param(type, ref, 4, { b, h });
          this.read_global_param(type, ref, 5, { b, h });
        } else {
          h[`gm_params[${ref}][4]`] = -h[`gm_params[${ref}][3]`];
          h[`gm_params[${ref}][5]`] = h[`gm_params[${ref}][2]`];
        }
      }
      if (type >= TRANSLATION) {
        this.read_global_param(type, ref, 0, { b, h });
        this.read_global_param(type, ref, 1, { b, h });
      }
    }
  };

  // 5.9.25. Global param syntax
  read_global_param(type: number, ref: number, idx: number, { b, h }: { b: BitReader, h: any }) {
    let absBits = GM_ABS_ALPHA_BITS;    // 用来计算gm_params[ref][idx]的取值范围。
    let precBits = GM_ALPHA_PREC_BITS;  // 指定用于表示gm_params[ref][idx]的小数位数。所有全局运动参数都以WARPEDMODEL_PREC_BITS小数位数存储在模型中，但是参数的编码精度较低。
    if (idx < 2) {
      if (type == TRANSLATION) {
        absBits = GM_ABS_TRANS_ONLY_BITS - (1 - h.allow_high_precision_mv);
        precBits = GM_TRANS_ONLY_PREC_BITS - (1 - h.allow_high_precision_mv);
      } else {
        absBits = GM_ABS_TRANS_BITS;
        precBits = GM_TRANS_PREC_BITS;
      }
    }
    let precDiff = WARPEDMODEL_PREC_BITS - precBits;
    let round = (idx % 3) == 2 ? (1 << WARPEDMODEL_PREC_BITS) : 0;
    let sub = (idx % 3) == 2 ? (1 << precBits) : 0;
    let mx = (1 << absBits);
    let r = (h[`PrevGmParams[${ref}][${idx}]`] >> precDiff) - sub;
    h[`gm_params[${ref}][${idx}]`] =
      (this.decode_signed_subexp_with_ref(-mx, mx + 1, r, { b, h }) << precDiff) + round;
  };

  // 5.9.26. Decode signed subexp with ref syntax
  decode_signed_subexp_with_ref(low: number, high: number, r: number, { b, h }: { b: BitReader, h: any }) {
    let x = this.decode_unsigned_subexp_with_ref(high - low, r - low, { b, h });
    return x + low;
  };

  // 5.9.27. Decode unsigned subexp with ref syntax
  decode_unsigned_subexp_with_ref(mx: number, r: number, { b, h }: { b: BitReader, h: any }) {
    let v = this.decode_subexp(mx, { b, h });
    if ((r << 1) <= mx) {
      return this.inverse_recenter(r, v);
    } else {
      return mx - 1 - this.inverse_recenter(mx - 1 - r, v);
    }
  };

  // 5.9.28. Decode subexp syntax
  decode_subexp(numSyms: number, { b, h }: { b: BitReader, h: any }) {
    let i = 0;
    let mk = 0;
    let k = 3;
    let n = 0;
    while (1) {
      let b2 = i ? k + i - 1 : k;
      let a = 1 << b2;
      if (numSyms <= mk + 3 * a) {
        h[`subexp_final_bits[${n}]`] = b.ns(numSyms - mk);  // 提供一旦确定了适当的范围就读取的最终位。
        return h[`subexp_final_bits[${n}]`] + mk;
      } else {
        h[`subexp_more_bits[${n}]`] = b.u(1); // =0表示参数范围在mk到mk+a-1之间。=1表示该参数大于mk+a-1。
        if (h[`subexp_more_bits[${n}]`]) {
          i++;
          mk += a;
        } else {
          h[`subexp_bits[${n}]`] = b.u(b2); // 指定参数减去mk的值。
          return h[`subexp_bits[${n}]`] + mk;
        }
      }
      ++n;
    }
  };

  // 5.9.29. Inverse recenter function
  inverse_recenter(r: number, v: number) {
    if (v > 2 * r)
      return v;
    else if (v & 1)
      return r - ((v + 1) >> 1);
    else
      return r + (v >> 1);
  };

  // 5.9.30. Film grain params syntax
  film_grain_params({ b, h }: { b: BitReader, h: any }) {
    if (!this.seq_header.film_grain_params_present ||
      (!h.show_frame && !h.showable_frame)) {
      this.reset_grain_params({ b, h });
      return;
    }
    h.apply_grain = b.u(1); // =1指定应该将胶片颗粒添加到该帧。pars->apply_grain
    if (!h.apply_grain) {
      this.reset_grain_params({ b, h });
      return;
    }
    h.grain_seed = b.u(16); // 指定在胶片颗粒合成过程中使用的伪随机数的起始值。pars->random_seed
    if (h.frame_type == INTER_FRAME)
      h.update_grain = b.u(1);  // =1表示应该发送一组新的参数；=0意味着应该使用前一组参数。pars->update_parameters
    else
      h.update_grain = 1;
    if (!h.update_grain) {
      h.film_grain_params_ref_idx = b.u(3); // 表示哪个参考帧包含用于该帧的电影颗粒参数；等于ref_frame_idx[j]是位流一致性的要求。film_grain_params_ref_idx
      let tempGrainSeed = h.grain_seed;
      this.load_grain_params(h.film_grain_params_ref_idx, { b, h });
      h.grain_seed = tempGrainSeed;
      return;
    }
    h.num_y_points = b.u(4);  // 指定luma组件的逐块线性缩放函数的点数。pars->num_y_points
    if (h.num_y_points > 14) {
      console.error("Number of points for film grain luma scaling function exceeds the maximum value.");
    }
    for (let i = 0; i < h.num_y_points; i++) {
      h[`point_y_value[${i}]`] = b.u(8);    // 表示亮度分量分段线性缩放函数第I点的x(亮度值)坐标。这些值以0..255的范围表示。(如果是10位视频，这些值对应于亮度值除以4。如果是12位视频，这些值对应于亮度值除以16。)pars->scaling_points_y[i][0]
      if (i && h[`point_y_value[${i - 1}]`] >= h[`point_y_value[${i}]`]) {
        console.error("First coordinate of the scaling function points shall be increasing.");
      }
      h[`point_y_scaling[${i}]`] = b.u(8);  // 表示亮度分量分段线性缩放函数第I点的缩放(输出)值。pars->scaling_points_y[i][1]
    }
    if (this.seq_header.mono_chrome) {
      h.chroma_scaling_from_luma = 0; // 指定从亮度缩放推断色度缩放。pars->chroma_scaling_from_luma
    } else {
      h.chroma_scaling_from_luma = b.u(1);
    }
    if (this.seq_header.mono_chrome || this.seq_header.chroma_scaling_from_luma ||
      (this.seq_header.subsampling_x == 1 && this.seq_header.subsampling_y == 1 &&
        h.num_y_points == 0)) {
      h.num_cb_points = 0;  // 指定cb组件的分段线性缩放函数的点数。pars->num_cb_points
      h.num_cr_points = 0;  // pars->num_cr_points
    } else {
      h.num_cb_points = b.u(4);
      if (h.num_cb_points > 10) {
        console.error("Number of points for film grain cb scaling function exceeds the maximum value.");
      }
      for (let i = 0; i < h.num_cb_points; i++) {
        h[`point_cb_value[${i}]`] = b.u(8); // 表示cb分量分段线性缩放函数第I点的x坐标。这些值以0..255的范围表示。
        if (i && h[`point_cb_value[${i - 1}]`] >= h[`point_cb_value[${i}]`]) {
          console.error("First coordinate of the scaling function points shall be increasing.");
        }
        h[`point_cb_scaling[${i}]`] = b.u(8); // 表示cb分量分段线性缩放函数第I点的缩放(输出)值。
      }
      h.num_cr_points = b.u(4); // 指定表示cr组件的逐块线性缩放函数的点数。pars->num_cr_points
      if (h.num_cr_points > 10) {
        console.error("Number of points for film grain cr scaling function exceeds the maximum value.");
      }
      for (let i = 0; i < h.num_cr_points; i++) {
        h[`point_cr_value[${i}]`] = b.u(8); // 表示cr分量分段线性缩放函数第I点的x坐标。这些值以0..255的范围表示
        if (i && h[`point_cr_value[${i - 1}]`] >= h[`point_cr_value[${i}]`]) {
          console.error("First coordinate of the scaling function points shall be increasing.");
        }
        h[`point_cr_scaling[${i}]`] = b.u(8); // 表示cr分量分段线性缩放函数第I点的缩放(输出)值。
      }
      if ((this.seq_header.subsampling_x == 1) && (this.seq_header.subsampling_y == 1) &&
        (((h.num_cb_points == 0) && (h.num_cr_points != 0)) ||
          ((h.num_cb_points != 0) && (h.num_cr_points == 0)))) {
        console.error("In YCbCr 4:2:0, film grain shall be applied to both chroma components or neither.");
      }
    }
    h.grain_scaling_minus_8 = b.u(2); // 应用于色度组件的值；可以取0..3、确定膜粒标准差的范围和量化步骤。pars->scaling_shift
    h.ar_coeff_lag = b.u(2);          // 指定亮度和色度的自回归系数的数量。pars->ar_coeff_lag
    let numPosLuma = 2 * h.ar_coeff_lag * (h.ar_coeff_lag + 1);
    let numPosChroma;
    if (h.num_y_points) {
      numPosChroma = numPosLuma + 1;
      for (let i = 0; i < numPosLuma; i++)
        h[`ar_coeffs_y_plus_128[${i}]`] = b.u(8); // 指定用于Y平面的自回归系数。pars->ar_coeffs_y
    } else {
      numPosChroma = numPosLuma;
    }
    if (h.chroma_scaling_from_luma || h.num_cb_points) {
      for (let i = 0; i < numPosChroma; i++)
        h[`ar_coeffs_cb_plus_128[${i}]`] = b.u(8);  // 指定用于U平面的自回归系数。pars->ar_coeffs_cb
    }
    if (h.chroma_scaling_from_luma || h.num_cr_points) {
      for (let i = 0; i < numPosChroma; i++)
        h[`ar_coeffs_cr_plus_128[${i}]`] = b.u(8);  // 指定用于V平面的自回归系数。pars->ar_coeffs_cr
    }
    h.ar_coeff_shift_minus_6 = b.u(2);  // 指定自回归系数的范围。0、1、2和3的值分别对应于自回归系数[-2,2)、[-1,1)、[-0.5,0.5)和[-0.25,0.25)的范围。pars->ar_coeff_shift
    h.grain_scale_shift = b.u(2);       // 指定在颗粒合成过程中高斯随机数应该按比例缩小多少。pars->grain_scale_shift
    if (h.num_cb_points) {
      h.cb_mult = b.u(8);       // 表示cb分量的乘法器，用于推导cb分量标度函数的输入索引。pars->cb_mult
      h.cb_luma_mult = b.u(8);  // 表示用于推导cb分量缩放函数的输入索引的平均luma分量的乘法器。pars->cb_luma_mult
      h.cb_offset = b.u(9);     // 表示在推导cb分量缩放函数的输入索引时使用的偏移量。pars->cb_offset
    }
    if (h.num_cr_points) {
      h.cr_mult = b.u(8);       // 表示cr分量的乘法器，用于推导cr分量缩放函数的输入索引。pars->cr_mult
      h.cr_luma_mult = b.u(8);  // 表示用于推导cr分量缩放函数的输入索引的平均luma分量的乘法器。pars->cr_luma_mult 
      h.cr_offset = b.u(9);     // 表示在推导cr分量缩放函数的输入索引时使用的偏移量。pars->cr_offset 
    }
    h.overlap_flag = b.u(1);              // =1表示膜粒块之间需要重叠；=0表示膜粒块之间不能重叠。pars->overlap_flag
    h.clip_to_restricted_range = b.u(1);  // =1表示在加入胶片颗粒后，对采样值进行限制(studio)范围的裁剪(studio swing的解释参见color_range的语义)；=0表示加入膜粒后对采样值进行全范围裁剪。pars->clip_to_restricted_range
  };

  // 5.9.31. Temporal point info syntax
  temporal_point_info({ b, h }: { b: BitReader, h: any }) {
    let n = h.frame_presentation_time_length_minus_1 + 1;
    h.frame_presentation_time = b.u(n); // 指定帧的表示时间(以时钟节拍为单位)。DispCT从正在解码的操作点的最后一个随机接入点的移除时间开始计数。语法元素被标记为一个固定长度的无符号整数，其长度由Frame_presentation_time_length_minus_1 + 1。frame_presentation_time是模数1 <<的余数。(frame_presentation_time_length_minus_1 + 1)计数器。
  }

  // 5.10. Frame OBU syntax
  frame_obu(sz: number, { b, h }: { b: BitReader, h: any }) {
    let startBitPos = b.get_position();
    this.frame_header_obu({ b, h });
    b.byte_alignment();
    let endBitPos = b.get_position();
    let headerBytes = (endBitPos - startBitPos) / 8;
    sz = sz - headerBytes;
    this.tile_group_obu(sz, { b, h });
  };

  // 5.11.1. General tile group OBU syntax
  tile_group_obu(sz: number, { b, h }: { b: BitReader, h: any }) {
    h['NumTiles'] = h['TileCols'] * h['TileRows'];  // 指定帧中tile的总数。
    let startBitPos = b.get_position();
    h.tile_start_and_end_present_flag = 0;
    if (h['NumTiles'] > 1)
      h.tile_start_and_end_present_flag = b.u(1);
    if (h['NumTiles'] == 1 || !h.tile_start_and_end_present_flag) {
      h.tg_start = 0; // 指定当前tile组中第一个tile的从零开始的索引。
      h.tg_end = h['NumTiles'] - 1; // 指定当前tile组中最后一个tile的从零开始的索引。
    } else {
      let tileBits = h['TileColsLog2'] + h['TileRowsLog2'];
      h.tg_start = b.u(tileBits);
      h.tg_end = b.u(tileBits);
    }
    b.byte_alignment();
    let endBitPos = b.get_position();
    let headerBytes = (endBitPos - startBitPos) / 8;
    sz -= headerBytes;
    let tileSize = 0; // 以字节为单位指定下一个编码贴图的大小。
    for (h['TileNum'] = h.tg_start; h['TileNum'] <= h.tg_end; h['TileNum']++) {
      let tileRow = h['TileNum'] / h['TileCols'];
      let tileCol = h['TileNum'] % h['TileCols'];
      let lastTile = h['TileNum'] == h.tg_end;
      if (lastTile) {
        tileSize = sz;
      } else {
        h.tile_size_minus_1 = b.le(h['TileSizeBytes']);
        tileSize = h.tile_size_minus_1 + 1;
        sz -= tileSize + h['TileSizeBytes'];
      }
      h['MiRowStart'] = h[`MiRowStarts[${tileRow}]`];
      h['MiRowEnd'] = h[`MiRowStarts[${tileRow + 1}]`];
      h['MiColStart'] = h[`MiColStarts[${tileCol}]`];
      h['MiColEnd'] = h[`MiColStarts[${tileCol + 1}]`];
      h['CurrentQIndex'] = h.base_q_idx;
      this.init_symbol(tileSize, { b, h });
      this.decode_tile({ b, h });
      this.exit_symbol({ b, h });
    }
    if (h.tg_end == h['NumTiles'] - 1) {
      if (!h.disable_frame_end_update_cdf) {
        this.frame_end_update_cdf({ b, h });
      }
      this.decode_frame_wrapup({ b, h });
      h.SeenFrameHeader = 0;
    }

  };

  // 5.11.2. Decode tile syntax
  decode_tile({ b, h }: { b: BitReader, h: any }) {
    let clear_above_context = function () {
      h[`AboveLevelContext[0][0]`] = 0;
      h[`AboveDcContext[0][0]`] = 0;
      h[`AboveSegPredContext[0]`] = 0;
    }
    let clear_left_context = function () {
      h[`LeftLevelContext[0][0]`] = 0;
      h[`LeftDcContext[0][0]`] = 0;
      h[`LeftSegPredContext[0][0]`] = 0;
    }
    const Wiener_Taps_Mid = [3, -7, 15];
    const Sgrproj_Xqd_Mid = [-32, 31];

    clear_above_context();
    for (let i = 0; i < FRAME_LF_COUNT; i++)
      h[`DeltaLF[${i}]`] = 0;
    for (let plane = 0; plane < h['NumPlanes']; plane++) {
      for (let pass = 0; pass < 2; pass++) {
        h[`RefSgrXqd[${plane}][${pass}]`] = Sgrproj_Xqd_Mid[pass];
        for (let i = 0; i < WIENER_COEFFS; i++) {
          h[`RefLrWiener[${plane}][${pass}][${i}]`] = Wiener_Taps_Mid[i];
        }
      }
    }
    let sbSize = this.seq_header.use_128x128_superblock ? BLOCK_128X128 : BLOCK_64X64;
    let sbSize4 = Num_4x4_Blocks_Wide[sbSize];
    for (let r = h['MiRowStart']; r < h['MiRowEnd']; r += sbSize4) {
      clear_left_context();
      for (let c = h['MiColStart']; c < h['MiColEnd']; c += sbSize4) {
        h['ReadDeltas'] = h.delta_q_present;
        this.clear_cdef({ b, h }, r, c);
        this.clear_block_decoded_flags({ b, h }, r, c, sbSize4);
        this.read_lr({ b, h }, r, c, sbSize);
        this.decode_partition({ b, h }, r, c, sbSize);
      }
    }
  }

  // 5.11.3. Clear block decoded flags function
  clear_block_decoded_flags({ b, h }: { b: BitReader, h: any }, r: number, c: number, sbSize4: number) {
    for (let plane = 0; plane < h['NumPlanes']; plane++) {
      let subX = (plane > 0) ? this.seq_header.subsampling_x : 0;
      let subY = (plane > 0) ? this.seq_header.subsampling_y : 0;
      let sbWidth4 = (h['MiColEnd'] - c) >> subX;
      let sbHeight4 = (h['MiRowEnd'] - r) >> subY;
      for (let y = -1; y <= (sbSize4 >> subY); y++)
        for (let x = -1; x <= (sbSize4 >> subX); x++) {
          if (y < 0 && x < sbWidth4)
            h[`BlockDecoded[${plane}][${y}][${x}]`] = 1;
          else if (x < 0 && y < sbHeight4)
            h[`BlockDecoded[${plane}][${y}][${x}]`] = 1;
          else
            h[`BlockDecoded[${plane}][${y}][${x}]`] = 0;
        }
      h[`BlockDecoded[${plane}][${sbSize4 >> subY}][-1]`] = 0;
    }
  }

  // 5.11.4. Decode partition syntax
  decode_partition({ b, h }: { b: BitReader, h: any }, r: number, c: number, bSize: number) {
    if (r >= h['MiRows'] || c >= h['MiCols'])
      return 0;
    h['AvailU'] = this.is_inside({ b, h }, r - 1, c);
    h['AvailL'] = this.is_inside({ b, h }, r, c - 1);
    let num4x4 = Num_4x4_Blocks_Wide[bSize];
    let halfBlock4x4 = num4x4 >> 1;
    let quarterBlock4x4 = halfBlock4x4 >> 1;
    let hasRows = (r + halfBlock4x4) < h['MiRows'];
    let hasCols = (c + halfBlock4x4) < h['MiCols'];
    if (bSize < BLOCK_8X8) {
      h.partition = PARTITION_NONE;
    } else if (hasRows && hasCols) {
      h.partition = b.S();
    } else if (hasCols) {
      h.split_or_horz = b.S();
      h.partition = h.split_or_horz ? PARTITION_SPLIT : PARTITION_HORZ;
    } else if (hasRows) {
      h.split_or_vert = b.S();
      h.partition = h.split_or_vert ? PARTITION_SPLIT : PARTITION_VERT;
    } else {
      h.partition = PARTITION_SPLIT;
    }
    let subSize = Partition_Subsize[h.partition][bSize];
    let splitSize = Partition_Subsize[PARTITION_SPLIT][bSize]
    if (h.partition == PARTITION_NONE) {
      this.decode_block({ b, h }, r, c, subSize)
    } else if (h.partition == PARTITION_HORZ) {
      this.decode_block({ b, h }, r, c, subSize)
      if (hasRows)
        this.decode_block({ b, h }, r + halfBlock4x4, c, subSize)
    } else if (h.partition == PARTITION_VERT) {
      this.decode_block({ b, h }, r, c, subSize)
      if (hasCols)
        this.decode_block({ b, h }, r, c + halfBlock4x4, subSize)
    } else if (h.partition == PARTITION_SPLIT) {
      this.decode_partition({ b, h }, r, c, subSize)
      this.decode_partition({ b, h }, r, c + halfBlock4x4, subSize)
      this.decode_partition({ b, h }, r + halfBlock4x4, c, subSize)
      this.decode_partition({ b, h }, r + halfBlock4x4, c + halfBlock4x4, subSize)
    } else if (h.partition == PARTITION_HORZ_A) {
      this.decode_block({ b, h }, r, c, splitSize)
      this.decode_block({ b, h }, r, c + halfBlock4x4, splitSize)
      this.decode_block({ b, h }, r + halfBlock4x4, c, subSize)
    } else if (h.partition == PARTITION_HORZ_B) {
      this.decode_block({ b, h }, r, c, subSize)
      this.decode_block({ b, h }, r + halfBlock4x4, c, splitSize)
      this.decode_block({ b, h }, r + halfBlock4x4, c + halfBlock4x4, splitSize)
    } else if (h.partition == PARTITION_VERT_A) {
      this.decode_block({ b, h }, r, c, splitSize)
      this.decode_block({ b, h }, r + halfBlock4x4, c, splitSize)
      this.decode_block({ b, h }, r, c + halfBlock4x4, subSize)
    } else if (h.partition == PARTITION_VERT_B) {
      this.decode_block({ b, h }, r, c, subSize)
      this.decode_block({ b, h }, r, c + halfBlock4x4, splitSize)
      this.decode_block({ b, h }, r + halfBlock4x4, c + halfBlock4x4, splitSize)
    } else if (h.partition == PARTITION_HORZ_4) {
      this.decode_block({ b, h }, r + quarterBlock4x4 * 0, c, subSize)
      this.decode_block({ b, h }, r + quarterBlock4x4 * 1, c, subSize)
      this.decode_block({ b, h }, r + quarterBlock4x4 * 2, c, subSize)
      if (r + quarterBlock4x4 * 3 < h['MiRows'])
        this.decode_block({ b, h }, r + quarterBlock4x4 * 3, c, subSize)
    } else {
      this.decode_block({ b, h }, r, c + quarterBlock4x4 * 0, subSize)
      this.decode_block({ b, h }, r, c + quarterBlock4x4 * 1, subSize)
      this.decode_block({ b, h }, r, c + quarterBlock4x4 * 2, subSize)
      if (c + quarterBlock4x4 * 3 < h['MiCols'])
        this.decode_block({ b, h }, r, c + quarterBlock4x4 * 3, subSize)
    }
  }


  // 5.11.5. Decode block syntax
  decode_block({ b, h }: { b: BitReader, h: any }, r: number, c: number, subSize: number) {
    let reset_block_context = function (bw4: number, bh4: number, seq_header: any) {
      for (let plane = 0; plane < 1 + 2 * h['HasChroma']; plane++) {
        let subX = (plane > 0) ? seq_header.subsampling_x : 0;
        let subY = (plane > 0) ? seq_header.subsampling_y : 0;
        for (let i = h['MiCol'] >> subX; i < ((h['MiCol'] + bw4) >> subX); i++) {
          h[`AboveLevelContext[${plane}][${i}]`] = 0;
          h[`AboveDcContext[${plane}][${i}]`] = 0;
        }
        for (let i = h['MiRow'] >> subY; i < ((h['MiRow'] + bh4) >> subY); i++) {
          h[`LeftLevelContext[${plane}][${i}]`] = 0;
          h[`LeftDcContext[${plane}][${i}]`] = 0;
        }
      }
    }

    h['MiRow'] = r;
    h['MiCol'] = c;
    h['MiSize'] = subSize;
    let bw4 = Num_4x4_Blocks_Wide[subSize];
    let bh4 = Num_4x4_Blocks_High[subSize];
    if (bh4 == 1 && this.seq_header.subsampling_y && (h['MiRow'] & 1) == 0)
      h['HasChroma'] = 0;
    else if (bw4 == 1 && this.seq_header.subsampling_x && (h['MiCol'] & 1) == 0)
      h['HasChroma'] = 0;
    else
      h['HasChroma'] = h['NumPlanes'] > 1;
    h['AvailU'] = this.is_inside({ b, h }, r - 1, c);
    h['AvailL'] = this.is_inside({ b, h }, r, c - 1);
    h['AvailUChroma'] = h['AvailU'];
    h['AvailLChroma'] = h['AvailL'];
    if (h['HasChroma']) {
      if (this.seq_header.subsampling_y && bh4 == 1)
        h['AvailUChroma'] = this.is_inside({ b, h }, r - 2, c);
      if (this.seq_header.subsampling_x && bw4 == 1)
        h['AvailLChroma'] = this.is_inside({ b, h }, r, c - 2);
    } else {
      h['AvailUChroma'] = 0;
      h['AvailLChroma'] = 0;
    }
    this.mode_info({ b, h });
    this.palette_tokens({ b, h });
    this.read_block_tx_size({ b, h });
    if (h.skip)
      reset_block_context(bw4, bh4, this.seq_header);
    let isCompound = Number(h['RefFrame[1]'] > INTRA_FRAME);
    for (let y = 0; y < bh4; y++) {
      for (let x = 0; x < bw4; x++) {
        h[`YModes[${r + y}][${c + x}]`] = h['YMode'];
        if (h['RefFrame[0]'] == INTRA_FRAME && h['HasChroma'])
          h[`UVModes[${r + y}][${c + x}]`] = h['UVMode'];
        for (let refList = 0; refList < 2; refList++)
          h[`RefFrames[${r + y}][${c + x}][${refList}]`] = h[`RefFrame[${refList}]`];
        if (h.is_inter) {
          if (!h.use_intrabc) {
            h[`CompGroupIdxs[${r + y}][${c + x}]`] = h.comp_group_idx;
            h[`CompoundIdxs[${r + y}][${c + x}]`] = h.compound_idx;
          }
          for (let dir = 0; dir < 2; dir++) {
            h[`InterpFilters[${r + y}][${c + x}][${dir}]`] = h[`interp_filter[${dir}]`];
          }
          for (let refList = 0; refList < 1 + isCompound; refList++) {
            h[`Mvs[${r + y}][${c + x}][${refList}]`] = h[`Mv[${refList}]`];
          }
        }
      }
    }
    this.compute_prediction({ b, h });
    this.residual({ b, h });
    for (let y = 0; y < bh4; y++) {
      for (let x = 0; x < bw4; x++) {
        h[`IsInters[${r + y}][${c + x}]`] = h.is_inter;
        h[`SkipModes[${r + y}][${c + x}]`] = h.skip_mode;
        h[`Skips[${r + y}][${c + x}]`] = h.skip;
        h[`TxSizes[${r + y}][${c + x}]`] = h['TxSize'];
        h[`MiSizes[${r + y}][${c + x}]`] = h['MiSize'];
        h[`SegmentIds[${r + y}][${c + x}]`] = h.segment_id;
        h[`PaletteSizes[0][${r + y}][${c + x}]`] = h['PaletteSizeY'];
        h[`PaletteSizes[1][${r + y}][${c + x}]`] = h['PaletteSizeUV'];
        for (let i = 0; i < h['PaletteSizeY']; i++)
          h[`PaletteColors[0][${r + y}][${c + x}][${i}]`] = h[`palette_colors_y[${i}]`];
        for (let i = 0; i < h['PaletteSizeUV']; i++)
          h[`PaletteColors[1][${r + y}][${c + x}][${i}]`] = h[`palette_colors_u[${i}]`];
        for (let i = 0; i < FRAME_LF_COUNT; i++)
          h[`DeltaLFs[r + y][c + x][i]`] = h[`DeltaLF[${i}]`];
      }
    }
  }

  // 5.11.6. Mode info syntax
  mode_info({ b, h }: { b: BitReader, h: any }) {
    if (h['FrameIsIntra'])
      this.intra_frame_mode_info({ b, h });
    else
      this.inter_frame_mode_info({ b, h });
  }

  // 5.11.7. Intra frame mode info syntax
  intra_frame_mode_info({ b, h }: { b: BitReader, h: any }) {
    h.skip = 0;
    if (h['SegIdPreSkip'])
      this.intra_segment_id({ b, h });
    h.skip_mode = 0;
    this.read_skip({ b, h });
    if (!h['SegIdPreSkip'])
      this.intra_segment_id({ b, h });
    this.read_cdef({ b, h });
    this.read_delta_qindex({ b, h });
    this.read_delta_lf({ b, h });
    h['ReadDeltas'] = 0;
    h[`RefFrame[0]`] = INTRA_FRAME;
    h[`RefFrame[1]`] = NONE;
    if (h.allow_intrabc) {
      h.use_intrabc = b.S();
    } else {
      h.use_intrabc = 0;
    }
    if (h.use_intrabc) {
      h.is_inter = 1;
      h['YMode'] = DC_PRED;
      h['UVMode'] = DC_PRED
      h.motion_mode = SIMPLE;
      h.compound_type = COMPOUND_AVERAGE;
      h['PaletteSizeY'] = 0;
      h['PaletteSizeUV'] = 0;
      h[`interp_filter[0]`] = BILINEAR;
      h[`interp_filter[1]`] = BILINEAR;
      this.find_mv_stack(0);
      this.assign_mv({ b, h }, 0);
    } else {
      h.is_inter = 0;
      h.intra_frame_y_mode = b.S();
      h['YMode'] = h.intra_frame_y_mode;
      this.intra_angle_info_y({ b, h });
      if (h['HasChroma']) {
        h.uv_mode = b.S();
        h['UVMode'] = h.uv_mode;
        if (h['UVMode'] == UV_CFL_PRED) {
          this.read_cfl_alphas({ b, h });
        }
        this.intra_angle_info_uv({ b, h });
      }
      h['PaletteSizeY'] = 0;
      h['PaletteSizeUV'] = 0;
      if (h['MiSize'] >= BLOCK_8X8 &&
        Block_Width[h['MiSize']] <= 64 &&
        Block_Height[h['MiSize']] <= 64 &&
        h.allow_screen_content_tools) {
        this.palette_mode_info({ b, h });
      }
      this.filter_intra_mode_info({ b, h });
    }
  }

  // 5.11.8. Intra segment ID syntax
  intra_segment_id({ b, h }: { b: BitReader, h: any }) {
    if (h.segmentation_enabled)
      this.read_segment_id({ b, h });
    else
      h.segment_id = 0;
    h['Lossless'] = h[`LosslessArray[${h.segment_id}]`];
  }

  // 5.11.9. Read segment ID syntax
  read_segment_id({ b, h }: { b: BitReader, h: any }) {
    let neg_deinterleave = function (diff: number, ref: number, max: number) {
      if (!ref)
        return diff
      if (ref >= (max - 1))
        return max - diff - 1
      if (2 * ref < max) {
        if (diff <= 2 * ref) {
          if (diff & 1)
            return ref + ((diff + 1) >> 1)
          else
            return ref - (diff >> 1)
        }
        return diff
      } else {
        if (diff <= 2 * (max - ref - 1)) {
          if (diff & 1)
            return ref + ((diff + 1) >> 1)
          else
            return ref - (diff >> 1)
        }
        return max - (diff + 1)
      }
    }

    let prevUL = -1;
    if (h['AvailU'] && h['AvailL'])
      prevUL = h[`SegmentIds[${h['MiRow'] - 1}][${h['MiCol'] - 1}]`];
    let prevU = -1;
    if (h['AvailU'])
      prevU = h[`SegmentIds[${h['MiRow'] - 1}][${h['MiCol']}]`];
    let prevL = -1;
    if (h['AvailL'])
      prevL = h[`SegmentIds[${h['MiRow']}][${h['MiCol']} - 1]`];
    if (prevU == -1)
      h.pred = (prevL == -1) ? 0 : prevL
    else if (prevL == -1)
      h.pred = prevU
    else
      h.pred = (prevUL == prevU) ? prevU : prevL
    if (h.skip) {
      h.segment_id = h.pred;
    } else {
      h.segment_id = b.S();
      h.segment_id = neg_deinterleave(h.segment_id, h.pred,
        h['LastActiveSegId'] + 1);
    }
  }

  // 5.11.10. Skip mode syntax
  read_skip_mode({ b, h }: { b: BitReader, h: any }) {
    if (this.seg_feature_active({ b, h }, SEG_LVL_SKIP) ||
      this.seg_feature_active({ b, h }, SEG_LVL_REF_FRAME) ||
      this.seg_feature_active({ b, h }, SEG_LVL_GLOBALMV) ||
      !h.skip_mode_present ||
      Block_Width[h['MiSize']] < 8 ||
      Block_Height[h['MiSize']] < 8) {
      h.skip_mode = 0;
    } else {
      h.skip_mode = b.S();
    }
  }

  // 5.11.11. Skip syntax
  read_skip({ b, h }: { b: BitReader, h: any }) {
    if (h['SegIdPreSkip'] && this.seg_feature_active({ b, h }, SEG_LVL_SKIP)) {
      h.skip = 1;
    } else {
      h.skip = b.S();
    }
  }

  // 5.11.12. Quantizer index delta syntax
  read_delta_qindex({ b, h }: { b: BitReader, h: any }) {
    let sbSize = h.use_128x128_superblock ? BLOCK_128X128 : BLOCK_64X64;
    if (h['MiSize'] == sbSize && h.skip)
      return;
    if (h['ReadDeltas']) {
      h.delta_q_abs = b.S();
      if (h.delta_q_abs == DELTA_Q_SMALL) {
        h.delta_q_rem_bits = b.L(3);
        h.delta_q_rem_bits++;
        h.delta_q_abs_bits = b.L(h.delta_q_rem_bits);
        h.delta_q_abs = h.delta_q_abs_bits + (1 << h.delta_q_rem_bits) + 1;
      }
      if (h.delta_q_abs) {
        h.delta_q_sign_bit = b.L(1);
        let reducedDeltaQIndex = h.delta_q_sign_bit ? -h.delta_q_abs : h.delta_q_abs;
        h['CurrentQIndex'] = this.Clip3(1, 255,
          h['CurrentQIndex'] + (reducedDeltaQIndex << h.delta_q_res));
      }
    }
  }

  // 5.11.13. Loop filter delta syntax
  read_delta_lf({ b, h }: { b: BitReader, h: any }) {
    let sbSize = h.use_128x128_superblock ? BLOCK_128X128 : BLOCK_64X64;
    if (h['MiSize'] == sbSize && h.skip)
      return;
    if (h['ReadDeltas'] && h.delta_lf_present) {
      let frameLfCount = 1;
      if (h.delta_lf_multi) {
        frameLfCount = (h['NumPlanes'] > 1) ? FRAME_LF_COUNT : (FRAME_LF_COUNT - 2);
      }
      for (let i = 0; i < frameLfCount; i++) {
        h.delta_lf_abs = b.S();
        let deltaLfAbs = h.delta_lf_abs;
        if (h.delta_lf_abs == DELTA_LF_SMALL) {
          h.delta_lf_rem_bits = b.L(3)
          let n = h.delta_lf_rem_bits + 1;
          h.delta_lf_abs_bits = b.L(n);
          let deltaLfAbs = h.delta_lf_abs_bits +
            (1 << n) + 1;
        }
        if (deltaLfAbs) {
          h.delta_lf_sign_bit = b.L(1);
          let reducedDeltaLfLevel = h.delta_lf_sign_bit ?
            -deltaLfAbs :
            deltaLfAbs;
          h[`DeltaLF[${i}]`] = this.Clip3(-MAX_LOOP_FILTER, MAX_LOOP_FILTER, h[`DeltaLF[${i}]`] +
            (reducedDeltaLfLevel << h.delta_lf_res))
        }
      }
    }
  }

  // 5.11.14. Segmentation feature active function
  seg_feature_active_idx({ b, h }: { b: BitReader, h: any }, idx: number, feature: number) {
    return h.segmentation_enabled && h[`FeatureEnabled[${idx}][${feature}]`];
  }
  seg_feature_active({ b, h }: { b: BitReader, h: any }, feature: number) {
    return this.seg_feature_active_idx({ b, h }, h.segment_id, feature);
  }

  // 5.11.15. TX size syntax
  read_tx_size({ b, h }: { b: BitReader, h: any }, allowSelect: number) {
    const Max_Tx_Depth = [
      0, 1, 1, 1,
      2, 2, 2, 3,
      3, 3, 4, 4,
      4, 4, 4, 4,
      2, 2, 3, 3,
      4, 4];
    if (h['Lossless']) {
      h['TxSize'] = TX_4X4;
      return;
    }
    let maxRectTxSize = Max_Tx_Size_Rect[h['MiSize']];
    let maxTxDepth = Max_Tx_Depth[h['MiSize']];
    h['TxSize'] = maxRectTxSize;
    if (h['MiSize'] > BLOCK_4X4 && allowSelect && h['TxMode'] == TX_MODE_SELECT) {
      h.tx_depth = b.S();
      for (let i = 0; i < h.tx_depth; i++)
        h['TxSize'] = Split_Tx_Size[h['TxSize']];
    }
  }


  // 5.11.16. Block TX size syntax
  read_block_tx_size({ b, h }: { b: BitReader, h: any }) {
    let bw4 = Num_4x4_Blocks_Wide[h['MiSize']];
    let bh4 = Num_4x4_Blocks_High[h['MiSize']];
    if (h['TxMode'] == TX_MODE_SELECT &&
      h['MiSize'] > BLOCK_4X4 && h.is_inter &&
      !h.skip && !h['Lossless']) {
      let maxTxSz = Max_Tx_Size_Rect[h['MiSize']];
      let txW4 = Tx_Width[maxTxSz] / MI_SIZE;
      let txH4 = Tx_Height[maxTxSz] / MI_SIZE;
      for (let row = h['MiRow']; row < h['MiRow'] + bh4; row += txH4)
        for (let col = h['MiCol']; col < h['MiCol'] + bw4; col += txW4)
          this.read_var_tx_size({ b, h }, row, col, maxTxSz, 0);
    } else {
      this.read_tx_size({ b, h }, Number(!h.skip || !h.is_inter));
      for (let row = h['MiRow']; row < h['MiRow'] + bh4; row++)
        for (let col = h['MiCol']; col < h['MiCol'] + bw4; col++)
          h[`InterTxSizes[${row}][${col}]`] = h['TxSize'];
    }
  }

  // 5.11.17. Var TX size syntax
  read_var_tx_size({ b, h }: { b: BitReader, h: any }, row: number, col: number, txSz: number, depth: number) {
    if (row >= h['MiRows'] || col >= h['MiCols'])
      return;
    if (txSz == TX_4X4 || depth == MAX_VARTX_DEPTH) {
      h.txfm_split = 0;
    } else {
      h.txfm_split = b.S();
    }
    let w4 = Tx_Width[txSz] / MI_SIZE;
    let h4 = Tx_Height[txSz] / MI_SIZE;
    if (h.txfm_split) {
      let subTxSz = Split_Tx_Size[txSz];
      let stepW = Tx_Width[subTxSz] / MI_SIZE;
      let stepH = Tx_Height[subTxSz] / MI_SIZE;
      for (let i = 0; i < h4; i += stepH)
        for (let j = 0; j < w4; j += stepW)
          this.read_var_tx_size({ b, h }, row + i, col + j, subTxSz, depth + 1);
    } else {
      for (let i = 0; i < h4; i++)
        for (let j = 0; j < w4; j++)
          h[`InterTxSizes[${row + i}][${col + j}]`] = txSz;
      h['TxSize'] = txSz;
    }
  }

  // 5.11.18. Inter frame mode info syntax
  inter_frame_mode_info({ b, h }: { b: BitReader, h: any }) {
    h.use_intrabc = 0
    h[`LeftRefFrame[0]`] = h['AvailL'] ? h[`RefFrames[${h['MiRow']}][${h['MiCol'] - 1}][0]`] : INTRA_FRAME;
    h[`AboveRefFrame[0]`] = h['AvailU'] ? h[`RefFrames[${h['MiRow'] - 1}][${h['MiCol']}][0]`] : INTRA_FRAME;
    h[`LeftRefFrame[1]`] = h['AvailL'] ? h[`RefFrames[${h['MiRow']}][${h['MiCol']} - 1][1]`] : NONE;
    h[`AboveRefFrame[1]`] = h['AvailU'] ? h[`RefFrames[${h['MiRow']} - 1][${h['MiCol']}][1]`] : NONE;
    h['LeftIntra'] = h[`LeftRefFrame[0]`] <= INTRA_FRAME;
    h['AboveIntra'] = h[`AboveRefFrame[0]`] <= INTRA_FRAME;
    h['LeftSingle'] = h[`LeftRefFrame[1]`] <= INTRA_FRAME;
    h['AboveSingle'] = h[`AboveRefFrame[1]`] <= INTRA_FRAME;
    h.skip = 0;
    this.inter_segment_id({ b, h }, 1);
    this.read_skip_mode({ b, h });
    if (h.skip_mode)
      h.skip = 1;
    else
      this.read_skip({ b, h });
    if (!h['SegIdPreSkip'])
      this.inter_segment_id({ b, h }, 0);
    h['Lossless'] = h[`LosslessArray[segment_id]`];
    this.read_cdef({ b, h });
    this.read_delta_qindex({ b, h });
    this.read_delta_lf({ b, h });
    h['ReadDeltas'] = 0;
    this.read_is_inter({ b, h });
    if (h.is_inter)
      this.inter_block_mode_info({ b, h });
    else
      this.intra_block_mode_info({ b, h });
  }

  // 5.11.19. Inter segment ID syntax
  inter_segment_id({ b, h }: { b: BitReader, h: any }, preSkip: number) {
    if (h.segmentation_enabled) {
      let predictedSegmentId = this.get_segment_id({ b, h });
      if (h.segmentation_update_map) {
        if (preSkip && !h['SegIdPreSkip']) {
          h.segment_id = 0;
          return;
        }
        if (!preSkip) {
          if (h.skip) {
            h.seg_id_predicted = 0;
            for (let i = 0; i < Num_4x4_Blocks_Wide[h['MiSize']]; i++)
              h[`AboveSegPredContext[${h['MiCol'] + i}]`] = h.seg_id_predicted;
            for (let i = 0; i < Num_4x4_Blocks_High[h['MiSize']]; i++)
              h[`LeftSegPredContext[${h['MiRow'] + i}]`] = h.seg_id_predicted;
            this.read_segment_id({ b, h });
            return
          }
        }
        if (h.segmentation_temporal_update == 1) {
          h.seg_id_predicted = b.S();
          if (h.seg_id_predicted)
            h.segment_id = predictedSegmentId;
          else
            this.read_segment_id({ b, h });
          for (let i = 0; i < Num_4x4_Blocks_Wide[h['MiSize']]; i++)
            h[`AboveSegPredContext[${h['MiCol'] + i}]`] = h.seg_id_predicted;
          for (let i = 0; i < Num_4x4_Blocks_High[h['MiSize']]; i++)
            h[`LeftSegPredContext[${h['MiRow'] + i}]`] = h.seg_id_predicted;
        } else {
          this.read_segment_id({ b, h });
        }
      } else {
        h.segment_id = predictedSegmentId;
      }
    } else {
      h.segment_id = 0;
    }
  }

  // 5.11.20. Is inter syntax
  read_is_inter({ b, h }: { b: BitReader, h: any }) {
    if (h.skip_mode) {
      h.is_inter = 1;
    } else if (this.seg_feature_active({ b, h }, SEG_LVL_REF_FRAME)) {
      h.is_inter = h[`FeatureData[${h.segment_id}][${SEG_LVL_REF_FRAME}]`] != INTRA_FRAME;
    } else if (this.seg_feature_active({ b, h }, SEG_LVL_GLOBALMV)) {
      h.is_inter = 1;
    } else {
      h.is_inter = b.S();
    }
  }

  // 5.11.21. Get segment ID function
  get_segment_id({ b, h }: { b: BitReader, h: any }) {
    let bw4 = Num_4x4_Blocks_Wide[h['MiSize']];
    let bh4 = Num_4x4_Blocks_High[h['MiSize']];
    let xMis = Math.min(h['MiCols'] - h['MiCol'], bw4);
    let yMis = Math.min(h['MiRows'] - h['MiRow'], bh4);
    let seg = 7;
    for (let y = 0; y < yMis; y++)
      for (let x = 0; x < xMis; x++)
        seg = Math.min(seg, h[`PrevSegmentIds[${h['MiRow'] + y}][${h['MiCol'] + x}]`]);
    return seg;
  }

  // 5.11.22. Intra block mode info syntax
  intra_block_mode_info({ b, h }: { b: BitReader, h: any }) {
    h[`RefFrame[0]`] = INTRA_FRAME;
    h[`RefFrame[1]`] = NONE;
    h.y_mode = b.S();
    h['YMode'] = h.y_mode;
    this.intra_angle_info_y({ b, h });
    if (h['HasChroma']) {
      h.uv_mode = b.S();
      h['UVMode'] = h.uv_mode;
      if (h['UVMode'] == UV_CFL_PRED) {
        this.read_cfl_alphas({ b, h });
      }
      this.intra_angle_info_uv({ b, h });
    }
    h['PaletteSizeY'] = 0;
    h['PaletteSizeUV'] = 0;
    if (h['MiSize'] >= BLOCK_8X8 &&
      Block_Width[h['MiSize']] <= 64 &&
      Block_Height[h['MiSize']] <= 64 &&
      h.allow_screen_content_tools)
      this.palette_mode_info({ b, h });
    this.filter_intra_mode_info({ b, h });
  }

  // 5.11.23. Inter block mode info syntax
  inter_block_mode_info({ b, h }: { b: BitReader, h: any }) {
    let has_nearmv = function () {
      return (h['YMode'] == NEARMV || h['YMode'] == NEAR_NEARMV
        || h['YMode'] == NEAR_NEWMV || h['YMode'] == NEW_NEARMV);
    }
    let needs_interp_filter = function () {
      let large = (Math.min(Block_Width[h['MiSize']], Block_Height[h['MiSize']]) >= 8)
      if (h.skip_mode || h.motion_mode == LOCALWARP) {
        return 0;
      } else if (large && h['YMode'] == GLOBALMV) {
        return h[`GmType[${h['RefFrame[0]']}]`] == TRANSLATION;
      } else if (large && h.YMode == GLOBAL_GLOBALMV) {
        return h[`GmType[${h['RefFrame[0]']}]`] == TRANSLATION || h[`GmType[${h['RefFrame[1]']}]`] == TRANSLATION;
      } else {
        return 1;
      }
    }
    h['PaletteSizeY'] = 0;
    h['PaletteSizeUV'] = 0;
    this.read_ref_frames({ b, h });
    let isCompound = Number(h[`RefFrame[1]`] > INTRA_FRAME);
    this.find_mv_stack(isCompound);
    if (h.skip_mode) {
      h['YMode'] = NEAREST_NEARESTMV;
    } else if (this.seg_feature_active({ b, h }, SEG_LVL_SKIP) ||
      this.seg_feature_active({ b, h }, SEG_LVL_GLOBALMV)) {
      h['YMode'] = GLOBALMV;
    } else if (isCompound) {
      h.compound_mode = b.S();
      h['YMode'] = NEAREST_NEARESTMV + h.compound_mode;
    } else {
      h.new_mv = b.S();
      if (h.new_mv == 0) {
        h['YMode'] = NEWMV;
      } else {
        h.zero_mv = b.S();
        if (h.zero_mv == 0) {
          h['YMode'] = GLOBALMV;
        } else {
          h.ref_mv = b.S();
          h['YMode'] = (h.ref_mv == 0) ? NEARESTMV : NEARMV;
        }
      }
    }
    h['RefMvIdx'] = 0;
    if (h['YMode'] == NEWMV || h['YMode'] == NEW_NEWMV) {
      for (let idx = 0; idx < 2; idx++) {
        if (h['NumMvFound'] > idx + 1) {
          h.drl_mode = b.S();
          if (h.drl_mode == 0) {
            h['RefMvIdx'] = idx;
            break;
          }
          h['RefMvIdx'] = idx + 1;
        }
      }
    } else if (has_nearmv()) {
      h['RefMvIdx'] = 1;
      for (let idx = 1; idx < 3; idx++) {
        if (h['NumMvFound'] > idx + 1) {
          h.drl_mode = b.S();
          if (h.drl_mode == 0) {
            h['RefMvIdx'] = idx;
            break;
          }
          h['RefMvIdx'] = idx + 1;
        }
      }
    }
    this.assign_mv({ b, h }, isCompound);
    this.read_interintra_mode({ b, h }, isCompound);
    this.read_motion_mode({ b, h }, isCompound);
    this.read_compound_type({ b, h }, isCompound);
    if (h.interpolation_filter == SWITCHABLE) {
      for (let dir = 0; dir < (h.enable_dual_filter ? 2 : 1); dir++) {
        if (needs_interp_filter()) {
          h.interp_filter[dir] = b.S();
        } else {
          h.interp_filter[dir] = EIGHTTAP;
        }
      }
      if (!h.enable_dual_filter)
        h[`interp_filter[1]`] = h[`interp_filter[0]`];
    } else {
      for (let dir = 0; dir < 2; dir++)
        h[`interp_filter[${dir}]`] = h.interpolation_filter;
    }
  }

  // 5.11.24. Filter intra mode info syntax
  filter_intra_mode_info({ b, h }: { b: BitReader, h: any }) {
    h.use_filter_intra = 0;
    if (h.enable_filter_intra &&
      h['YMode'] == DC_PRED && h['PaletteSizeY'] == 0 &&
      Math.max(Block_Width[h['MiSize']], Block_Height[h['MiSize']]) <= 32) {
      h.use_filter_intra = b.S();
      if (h.use_filter_intra) {
        h.filter_intra_mode = b.S();
      }
    }
  }

  // 5.11.25. Ref frames syntax
  read_ref_frames({ b, h }: { b: BitReader, h: any }) {
    if (h.skip_mode) {
      h[`RefFrame[0]`] = h[`SkipModeFrame[0]`];
      h[`RefFrame[1]`] = h[`SkipModeFrame[1]`];
    } else if (this.seg_feature_active({ b, h }, SEG_LVL_REF_FRAME)) {
      h[`RefFrame[0]`] = h[`FeatureData[${h.segment_id}][${SEG_LVL_REF_FRAME}]`];
      h[`RefFrame[1]`] = NONE;
    } else if (this.seg_feature_active({ b, h }, SEG_LVL_SKIP) ||
      this.seg_feature_active({ b, h }, SEG_LVL_GLOBALMV)) {
      h[`RefFrame[0]`] = LAST_FRAME;
      h[`RefFrame[1]`] = NONE;
    } else {
      let bw4 = Num_4x4_Blocks_Wide[h['MiSize']];
      let bh4 = Num_4x4_Blocks_High[h['MiSize']];
      if (h.reference_select && (Math.min(bw4, bh4) >= 2))
        h.comp_mode = b.S();
      else
        h.comp_mode = SINGLE_REFERENCE;
      if (h.comp_mode == COMPOUND_REFERENCE) {
        h.comp_ref_type = b.S();
        if (h.comp_ref_type == UNIDIR_COMP_REFERENCE) {
          h.uni_comp_ref = b.S();
          if (h.uni_comp_ref) {
            h[`RefFrame[0]`] = BWDREF_FRAME;
            h[`RefFrame[1]`] = ALTREF_FRAME;
          } else {
            h.uni_comp_ref_p1 = b.S();
            if (h.uni_comp_ref_p1) {
              h.uni_comp_ref_p2 = b.S();
              if (h.uni_comp_ref_p2) {
                h[`RefFrame[0]`] = LAST_FRAME;
                h[`RefFrame[1]`] = GOLDEN_FRAME;
              } else {
                h[`RefFrame[0]`] = LAST_FRAME;
                h[`RefFrame[1]`] = LAST3_FRAME;
              }
            } else {
              h[`RefFrame[0]`] = LAST_FRAME;
              h[`RefFrame[1]`] = LAST2_FRAME;
            }
          }
        } else {
          h.comp_ref = b.S();
          if (h.comp_ref == 0) {
            h.comp_ref_p1 = b.S();
            h[`RefFrame[0]`] = h.comp_ref_p1 ?
              LAST2_FRAME : LAST_FRAME;
          } else {
            h.comp_ref_p2 = b.S();
            h[`RefFrame[0]`] = h.comp_ref_p2 ?
              GOLDEN_FRAME : LAST3_FRAME;
          }
          h.comp_bwdref = b.S();
          if (h.comp_bwdref == 0) {
            h.comp_bwdref_p1 = b.S();
            h[`RefFrame[1]`] = h.comp_bwdref_p1 ?
              ALTREF2_FRAME : BWDREF_FRAME;
          } else {
            h[`RefFrame[1]`] = ALTREF_FRAME;
          }
        }
      } else {
        h.single_ref_p1 = b.S();
        if (h.single_ref_p1) {
          h.single_ref_p2 = b.S();
          if (h.single_ref_p2 == 0) {
            h.single_ref_p6 = b.S();
            h[`RefFrame[0]`] = h.single_ref_p6 ?
              ALTREF2_FRAME : BWDREF_FRAME;
          } else {
            h[`RefFrame[0]`] = ALTREF_FRAME;
          }
        } else {
          h.single_ref_p3 = b.S();
          if (h.single_ref_p3) {
            h.single_ref_p5 = b.S();
            h[`RefFrame[0]`] = h.single_ref_p5 ?
              GOLDEN_FRAME : LAST3_FRAME;
          } else {
            h.single_ref_p4 = b.S();
            h[`RefFrame[0]`] = h.single_ref_p4 ?
              LAST2_FRAME : LAST_FRAME;
          }
        }
        h[`RefFrame[1]`] = NONE;
      }
    }
  }

  // 5.11.26. Assign MV syntax
  assign_mv({ b, h }: { b: BitReader, h: any }, isCompound: number) {
    for (let i = 0; i < 1 + isCompound; i++) {
      let compMode = this.get_mode({ b, h }, i);
      if (h.use_intrabc) {
        compMode = NEWMV
      }
      if (h.use_intrabc) {
        h[`PredMv[0]`] = h[`RefStackMv[0][0]`];
        if (h[`PredMv[0][0]`] == 0 && h[`PredMv[0][1]`] == 0) {
          h[`PredMv[0]`] = h[`RefStackMv[1][0]`];
        }
        if (h[`PredMv[0][0]`] == 0 && h[`PredMv[0][1]`] == 0) {
          let sbSize = h.use_128x128_superblock ? BLOCK_128X128 : BLOCK_64X64;
          let sbSize4 = Num_4x4_Blocks_High[sbSize];
          if (h['MiRow'] - sbSize4 < h['MiRowStart']) {
            h[`PredMv[0][0]`] = 0;
            h[`PredMv[0][1]`] = -(sbSize4 * MI_SIZE + INTRABC_DELAY_PIXELS) * 8;
          } else {
            h[`PredMv[0][0]`] = -(sbSize4 * MI_SIZE * 8);
            h[`PredMv[0][1]`] = 0;
          }
        }
      } else if (compMode == GLOBALMV) {
        h[`PredMv[${i}]`] = h[`GlobalMvs[${i}]`];
      } else {
        let pos = (compMode == NEARESTMV) ? 0 : h['RefMvIdx'];
        if (compMode == NEWMV && h['NumMvFound'] <= 1)
          pos = 0
        h[`PredMv[${i}]`] = h[`RefStackMv[${pos}][${i}]`];
      }
      if (compMode == NEWMV) {
        this.read_mv({ b, h }, i);
      } else {
        h[`Mv[${i}]`] = h[`PredMv[${i}]`];
      }
    }
  }

  // 5.11.27. Read motion mode syntax
  read_motion_mode({ b, h }: { b: BitReader, h: any }, isCompound: number) {
    let is_scaled = function (refFrame: number) {
      let refIdx = h[`ref_frame_idx[${refFrame - LAST_FRAME}]`];
      let xScale = ((h[`RefUpscaledWidth[${refIdx}]`] << REF_SCALE_SHIFT) + (h['FrameWidth'] / 2)) / h['FrameWidth'];
      let yScale = ((h[`RefFrameHeight[${refIdx}]`] << REF_SCALE_SHIFT) + (h['FrameHeight'] / 2)) / h['FrameHeight'];
      let noScale = 1 << REF_SCALE_SHIFT;
      return xScale != noScale || yScale != noScale;
    }

    if (h.skip_mode) {
      h.motion_mode = SIMPLE;
      return;
    }
    if (!h.is_motion_mode_switchable) {
      h.motion_mode = SIMPLE;
      return;
    }
    if (Math.min(Block_Width[h['MiSize']],
      Block_Height[h['MiSize']]) < 8) {
      h.motion_mode = SIMPLE;
      return;
    }
    if (!h.force_integer_mv &&
      (h['YMode'] == GLOBALMV || h['YMode'] == GLOBAL_GLOBALMV)) {
      if (h[`GmType[${h['RefFrame[0]']}]`] > TRANSLATION) {
        h.motion_mode = SIMPLE;
        return;
      }
    }
    if (isCompound || h[`RefFrame[1]`] == INTRA_FRAME || !this.has_overlappable_candidates({ b, h })) {
      h.motion_mode = SIMPLE;
      return;
    }
    this.find_warp_samples();
    if (h.force_integer_mv || h['NumSamples'] == 0 ||
      !h.allow_warped_motion || is_scaled(h[`RefFrame[0]`])) {
      h.use_obmc = b.S();
      h.motion_mode = h.use_obmc ? OBMC : SIMPLE;
    } else {
      h.motion_mode = b.S();
    }
  }

  // 5.11.28. Read inter intra syntax
  read_interintra_mode({ b, h }: { b: BitReader, h: any }, isCompound: number) {
    if (!h.skip_mode && h.enable_interintra_compound && !isCompound &&
      h['MiSize'] >= BLOCK_8X8 && h['MiSize'] <= BLOCK_32X32) {
      h.interintra = b.S();
      if (h.interintra) {
        h.interintra_mode = b.S();
        h[`RefFrame[1]`] = INTRA_FRAME;
        h['AngleDeltaY'] = 0;
        h['AngleDeltaUV'] = 0;
        h.use_filter_intra = 0;
        h.wedge_interintra = b.S();
        if (h.wedge_interintra) {
          h.wedge_index = b.S();
          h.wedge_sign = 0;
        }
      }
    } else {
      h.interintra = 0;
    }
  }

  // 5.11.29. Read compound type syntax
  read_compound_type({ b, h }: { b: BitReader, h: any }, isCompound: number) {
    h.comp_group_idx = 0;
    h.compound_idx = 1;
    if (h.skip_mode) {
      h.compound_type = COMPOUND_AVERAGE;
      return;
    }
    if (isCompound) {
      let n = Wedge_Bits[h['MiSize']];
      if (h.enable_masked_compound) {
        h.comp_group_idx = b.S();
      }
      if (h.comp_group_idx == 0) {
        if (h.enable_jnt_comp) {
          h.compound_idx = b.S();
          h.compound_type = h.compound_idx ? COMPOUND_AVERAGE :
            COMPOUND_DISTANCE;
        } else {
          h.compound_type = COMPOUND_AVERAGE;
        }
      } else {
        if (n == 0) {
          h.compound_type = COMPOUND_DIFFWTD
        } else {
          h.compound_type = b.S();
        }
      }
      if (h.compound_type == COMPOUND_WEDGE) {
        h.wedge_index = b.S();
        h.wedge_sign = b.L(1);
      } else if (h.compound_type == COMPOUND_DIFFWTD) {
        h.mask_type = b.L(1);
      }
    } else {
      if (h.interintra) {
        h.compound_type = h.wedge_interintra ? COMPOUND_WEDGE : COMPOUND_INTRA;
      } else {
        h.compound_type = COMPOUND_AVERAGE;
      }
    }
  }

  // 5.11.30. Get mode function
  get_mode({ b, h }: { b: BitReader, h: any }, refList: number) {
    let compMode = GLOBALMV;
    if (refList == 0) {
      if (h['YMode'] < NEAREST_NEARESTMV)
        compMode = h['YMode'];
      else if (h['YMode'] == NEW_NEWMV || h['YMode'] == NEW_NEARESTMV || h['YMode'] == NEW_NEARMV)
        compMode = NEWMV;
      else if (h['YMode'] == NEAREST_NEARESTMV || h['YMode'] == NEAREST_NEWMV)
        compMode = NEARESTMV;
      else if (h['YMode'] == NEAR_NEARMV || h['YMode'] == NEAR_NEWMV)
        compMode = NEARMV;
      else
        compMode = GLOBALMV;
    } else {
      if (h['YMode'] == NEW_NEWMV || h['YMode'] == NEAREST_NEWMV || h['YMode'] == NEAR_NEWMV)
        compMode = NEWMV;
      else if (h['YMode'] == NEAREST_NEARESTMV || h['YMode'] == NEW_NEARESTMV)
        compMode = NEARESTMV;
      else if (h['YMode'] == NEAR_NEARMV || h['YMode'] == NEW_NEARMV)
        compMode = NEARMV;
      else
        compMode = GLOBALMV;
    }
    return compMode
  }

  // 5.11.31. MV syntax
  read_mv({ b, h }: { b: BitReader, h: any }, ref: number) {
    let diffMv = [0, 0];
    if (h.use_intrabc) {
      h['MvCtx'] = MV_INTRABC_CONTEXT;
    } else {
      h['MvCtx'] = 0;
    }
    h.mv_joint = b.S();
    if (h.mv_joint == MV_JOINT_HZVNZ || h.mv_joint == MV_JOINT_HNZVNZ)
      diffMv[0] = this.read_mv_component({ b, h }, 0);
    if (h.mv_joint == MV_JOINT_HNZVZ || h.mv_joint == MV_JOINT_HNZVNZ)
      diffMv[1] = this.read_mv_component({ b, h }, 1);
    h[`Mv[${ref}][0]`] = h[`PredMv[${ref}][0]`] + diffMv[0];
    h[`Mv[${ref}][1]`] = h[`PredMv[${ref}][1]`] + diffMv[1]
  }

  // 5.11.32. MV component syntax
  read_mv_component({ b, h }: { b: BitReader, h: any }, comp: number) {
    h.mv_sign = b.S();
    h.mv_class = b.S();
    let mag = 0;
    if (h.mv_class == MV_CLASS_0) {
      h.mv_class0_bit = b.S();
      if (h.force_integer_mv)
        h.mv_class0_fr = 3;
      else
        h.mv_class0_fr = b.S();
      if (h.allow_high_precision_mv)
        h.mv_class0_hp = h.S();
      else
        h.mv_class0_hp = 1;
      mag = ((h.mv_class0_bit << 3) |
        (h.mv_class0_fr << 1) |
        h.mv_class0_hp) + 1
    } else {
      let d = 0;
      for (let i = 0; i < h.mv_class; i++) {
        h.mv_bit = b.S();
        d |= h.mv_bit << i;
      }
      mag = CLASS0_SIZE << (h.mv_class + 2)
      if (h.force_integer_mv)
        h.mv_fr = 3;
      else
        h.mv_fr = b.S();
      if (h.allow_high_precision_mv)
        h.mv_hp = b.S();
      else
        h.mv_hp = 1;
      mag += ((d << 3) | (h.mv_fr << 1) | h.mv_hp) + 1;
    }
    return h.mv_sign ? -mag : mag;
  }

  // 5.11.33. Compute prediction syntax
  compute_prediction({ b, h }: { b: BitReader, h: any }) {
    let sbMask = h.use_128x128_superblock ? 31 : 15;
    let subBlockMiRow = h['MiRow'] & sbMask;
    let subBlockMiCol = h['MiCol'] & sbMask;
    for (let plane = 0; plane < 1 + h['HasChroma'] * 2; plane++) {
      let planeSz = this.get_plane_residual_size({ b, h }, h['MiSize'], plane);
      let num4x4W = Num_4x4_Blocks_Wide[planeSz];
      let num4x4H = Num_4x4_Blocks_High[planeSz];
      let log2W = MI_SIZE_LOG2 + Mi_Width_Log2[planeSz]
      let log2H = MI_SIZE_LOG2 + Mi_Height_Log2[planeSz]
      let subX = (plane > 0) ? h.subsampling_x : 0
      let subY = (plane > 0) ? h.subsampling_y : 0
      let baseX = (h['MiCol'] >> subX) * MI_SIZE
      let baseY = (h['MiRow'] >> subY) * MI_SIZE
      let candRow = (h.MiRow >> subY) << subY
      let candCol = (h.MiCol >> subX) << subX
      h.IsInterIntra = (h.is_inter && h[`RefFrame[1]`] == INTRA_FRAME)
      if (h.IsInterIntra) {
        if (h.interintra_mode == II_DC_PRED) h.mode = DC_PRED
        else if (h.interintra_mode == II_V_PRED) h.mode = V_PRED
        else if (h.interintra_mode == II_H_PRED) h.mode = H_PRED
        else h.mode = SMOOTH_PRED
        this.predict_intra(plane, baseX, baseY,
          plane == 0 ? h.AvailL : h.AvailLChroma,
          plane == 0 ? h.AvailU : h.AvailUChroma,
          h[`BlockDecoded[${plane}][${(subBlockMiRow >> subY) - 1}][${(subBlockMiCol >> subX) + num4x4W}]`],
          h[`BlockDecoded[${plane}][${(subBlockMiRow >> subY) + num4x4H}][${(subBlockMiCol >> subX) - 1}]`],
          h.mode,
          log2W, log2H)
      }
      if (h.is_inter) {
        let predW = Block_Width[h.MiSize] >> subX;
        let predH = Block_Height[h.MiSize] >> subY;
        let someUseIntra = 0;
        let r = 0;
        let c = 0;
        for (r = 0; r < (num4x4H << subY); r++)
          for (c = 0; c < (num4x4W << subX); c++)
            if (h[`RefFrames[${candRow + r}][${candCol + c}][0]`] == INTRA_FRAME)
              someUseIntra = 1;
        if (someUseIntra) {
          predW = num4x4W * 4;
          predH = num4x4H * 4;
          candRow = h.MiRow;
          candCol = h.MiCol;
        }
        r = 0
        for (let y = 0; y < num4x4H * 4; y += predH) {
          c = 0
          for (let x = 0; x < num4x4W * 4; x += predW) {
            this.predict_inter(plane, baseX + x, baseY + y,
              predW, predH,
              candRow + r, candCol + c)
            c++
          }
          r++
        }
      }
    }
  }

  // 5.11.34. Residual syntax
  residual({ b, h }: { b: BitReader, h: any }) {
    let sbMask = h.use_128x128_superblock ? 31 : 15;
    let widthChunks = Math.max(1, Block_Width[h.MiSize] >> 6);
    let heightChunks = Math.max(1, Block_Height[h.MiSize] >> 6);
    let miSizeChunk = (widthChunks > 1 || heightChunks > 1) ? BLOCK_64X64 : h.MiSize;
    for (let chunkY = 0; chunkY < heightChunks; chunkY++) {
      for (let chunkX = 0; chunkX < widthChunks; chunkX++) {
        let miRowChunk = h.MiRow + (chunkY << 4);
        let miColChunk = h.MiCol + (chunkX << 4);
        let subBlockMiRow = miRowChunk & sbMask;
        let subBlockMiCol = miColChunk & sbMask;
        for (let plane = 0; plane < 1 + h.HasChroma * 2; plane++) {
          let txSz = h.Lossless ? TX_4X4 : this.get_tx_size({ b, h }, plane, h.TxSize);
          let stepX = Tx_Width[txSz] >> 2;
          let stepY = Tx_Height[txSz] >> 2;
          let planeSz = this.get_plane_residual_size({ b, h }, miSizeChunk, plane);
          let num4x4W = Num_4x4_Blocks_Wide[planeSz];
          let num4x4H = Num_4x4_Blocks_High[planeSz];
          let subX = (plane > 0) ? h.subsampling_x : 0;
          let subY = (plane > 0) ? h.subsampling_y : 0;
          let baseX = (miColChunk >> subX) * MI_SIZE;
          let baseY = (miRowChunk >> subY) * MI_SIZE;
          if (h.is_inter && !h.Lossless && !plane) {
            this.transform_tree({ b, h }, baseX, baseY, num4x4W * 4, num4x4H * 4);
          } else {
            let baseXBlock = (h.MiCol >> subX) * MI_SIZE;
            let baseYBlock = (h.MiRow >> subY) * MI_SIZE;
            for (let y = 0; y < num4x4H; y += stepY)
              for (let x = 0; x < num4x4W; x += stepX)
                this.transform_block({ b, h }, plane, baseXBlock, baseYBlock, txSz,
                  x + ((chunkX << 4) >> subX),
                  y + ((chunkY << 4) >> subY));
          }
        }
      }
    }
  }

  // 5.11.35. Transform block syntax
  transform_block({ b, h }: { b: BitReader, h: any }, plane: number, baseX: number, baseY: number, txSz: number, x: number, y: number) {
    let startX = baseX + 4 * x;
    let startY = baseY + 4 * y;
    let subX = (plane > 0) ? h.subsampling_x : 0;
    let subY = (plane > 0) ? h.subsampling_y : 0;
    let row = (startY << subY) >> MI_SIZE_LOG2;
    let col = (startX << subX) >> MI_SIZE_LOG2;
    let sbMask = h.use_128x128_superblock ? 31 : 15;
    let subBlockMiRow = row & sbMask;
    let subBlockMiCol = col & sbMask;
    let stepX = Tx_Width[txSz] >> MI_SIZE_LOG2;
    let stepY = Tx_Height[txSz] >> MI_SIZE_LOG2;
    let maxX = (h.MiCols * MI_SIZE) >> subX;
    let maxY = (h.MiRows * MI_SIZE) >> subY;
    if (startX >= maxX || startY >= maxY) {
      return;
    }
    if (!h.is_inter) {
      if (((plane == 0) && h.PaletteSizeY) ||
        ((plane != 0) && h.PaletteSizeUV)) {
        this.predict_palette(plane, startX, startY, x, y, txSz);
      } else {
        let isCfl = (plane > 0 && h.UVMode == UV_CFL_PRED);
        if (plane == 0) {
          h.mode = h.YMode;
        } else {
          h.mode = (isCfl) ? DC_PRED : h.UVMode;
        }
        let log2W = Tx_Width_Log2[txSz];
        let log2H = Tx_Height_Log2[txSz];
        this.predict_intra(plane, startX, startY,
          (plane == 0 ? h.AvailL : h.AvailLChroma) || x > 0,
          (plane == 0 ? h.AvailU : h.AvailUChroma) || y > 0,
          h[`BlockDecoded[${plane}][${(subBlockMiRow >> subY) - 1}][${(subBlockMiCol >> subX) + stepX}]`],
          h[`BlockDecoded[${plane}][${(subBlockMiRow >> subY) + stepY}][${(subBlockMiCol >> subX) - 1}]`],
          h.mode,
          log2W, log2H);
        if (isCfl) {
          this.predict_chroma_from_luma(plane, startX, startY, txSz);
        }
      }
      if (plane == 0) {
        h.MaxLumaW = startX + stepX * 4;
        h.MaxLumaH = startY + stepY * 4;
      }
    }
    if (!h.skip) {
      let eob = this.coeffs({ b, h }, plane, startX, startY, txSz);
      if (eob > 0)
        this.reconstruct(plane, startX, startY, txSz);
    }
    for (let i = 0; i < stepY; i++) {
      for (let j = 0; j < stepX; j++) {
        h[`LoopfilterTxSizes[${plane}][${(row >> subY) + i}][${(col >> subX) + j}]`] = txSz;
        h[`BlockDecoded[${plane}][${(subBlockMiRow >> subY) + i}][${(subBlockMiCol >> subX) + j}]`] = 1;
      }
    }
  }

  // 5.11.36. Transform tree syntax
  transform_tree({ b, h }: { b: BitReader, h: any }, startX: number, startY: number, width: number, height: number) {
    let find_tx_size = function (w: number, h: number) {
      let txSz = 0;
      for (txSz = 0; txSz < TX_SIZES_ALL; txSz++)
        if (Tx_Width[txSz] == w && Tx_Height[txSz] == h)
          break;
      return txSz;
    }
    let maxX = h.MiCols * MI_SIZE;
    let maxY = h.MiRows * MI_SIZE;
    if (startX >= maxX || startY >= maxY) {
      return;
    }
    let row = startY >> MI_SIZE_LOG2;
    let col = startX >> MI_SIZE_LOG2;
    let lumaTxSz = h[`InterTxSizes[${row}][${col}]`];
    let lumaW = Tx_Width[lumaTxSz];
    let lumaH = Tx_Height[lumaTxSz];
    if (width <= lumaW && height <= lumaH) {
      let txSz = find_tx_size(width, height);
      this.transform_block({ b, h }, 0, startX, startY, txSz, 0, 0);
    } else {
      if (width > height) {
        this.transform_tree({ b, h }, startX, startY, width / 2, height)
        this.transform_tree({ b, h }, startX + width / 2, startY, width / 2, height)
      } else if (width < height) {
        this.transform_tree({ b, h }, startX, startY, width, height / 2)
        this.transform_tree({ b, h }, startX, startY + height / 2, width, height / 2)
      } else {
        this.transform_tree({ b, h }, startX, startY, width / 2, height / 2)
        this.transform_tree({ b, h }, startX + width / 2, startY, width / 2, height / 2)
        this.transform_tree({ b, h }, startX, startY + height / 2, width / 2, height / 2)
        this.transform_tree({ b, h }, startX + width / 2, startY + height / 2, width / 2, height / 2)
      }
    }
  }

  // 5.11.37. Get TX size function
  get_tx_size({ b, h }: { b: BitReader, h: any }, plane: number, txSz: number) {
    if (plane == 0)
      return txSz;
    let uvTx = Max_Tx_Size_Rect[this.get_plane_residual_size({ b, h }, h.MiSize, plane)];
    if (Tx_Width[uvTx] == 64 || Tx_Height[uvTx] == 64) {
      if (Tx_Width[uvTx] == 16) {
        return TX_16X32;
      }
      if (Tx_Height[uvTx] == 16) {
        return TX_32X16;
      }
      return TX_32X32;
    }
    return uvTx;
  }

  // 5.11.38. Get plane residual size function
  get_plane_residual_size({ b, h }: { b: BitReader, h: any }, subsize: number, plane: number) {
    const Subsampled_Size = [
      [[BLOCK_4X4, BLOCK_4X4], [BLOCK_4X4, BLOCK_4X4]],
      [[BLOCK_4X8, BLOCK_4X4], [BLOCK_INVALID, BLOCK_4X4]],
      [[BLOCK_8X4, BLOCK_INVALID], [BLOCK_4X4, BLOCK_4X4]],
      [[BLOCK_8X8, BLOCK_8X4], [BLOCK_4X8, BLOCK_4X4]],
      [[BLOCK_8X16, BLOCK_8X8], [BLOCK_INVALID, BLOCK_4X8]],
      [[BLOCK_16X8, BLOCK_INVALID], [BLOCK_8X8, BLOCK_8X4]],
      [[BLOCK_16X16, BLOCK_16X8], [BLOCK_8X16, BLOCK_8X8]],
      [[BLOCK_16X32, BLOCK_16X16], [BLOCK_INVALID, BLOCK_8X16]],
      [[BLOCK_32X16, BLOCK_INVALID], [BLOCK_16X16, BLOCK_16X8]],
      [[BLOCK_32X32, BLOCK_32X16], [BLOCK_16X32, BLOCK_16X16]],
      [[BLOCK_32X64, BLOCK_32X32], [BLOCK_INVALID, BLOCK_16X32]],
      [[BLOCK_64X32, BLOCK_INVALID], [BLOCK_32X32, BLOCK_32X16]],
      [[BLOCK_64X64, BLOCK_64X32], [BLOCK_32X64, BLOCK_32X32]],
      [[BLOCK_64X128, BLOCK_64X64], [BLOCK_INVALID, BLOCK_32X64]],
      [[BLOCK_128X64, BLOCK_INVALID], [BLOCK_64X64, BLOCK_64X32]],
      [[BLOCK_128X128, BLOCK_128X64], [BLOCK_64X128, BLOCK_64X64]],
      [[BLOCK_4X16, BLOCK_4X8], [BLOCK_INVALID, BLOCK_4X8]],
      [[BLOCK_16X4, BLOCK_INVALID], [BLOCK_8X4, BLOCK_8X4]],
      [[BLOCK_8X32, BLOCK_8X16], [BLOCK_INVALID, BLOCK_4X16]],
      [[BLOCK_32X8, BLOCK_INVALID], [BLOCK_16X8, BLOCK_16X4]],
      [[BLOCK_16X64, BLOCK_16X32], [BLOCK_INVALID, BLOCK_8X32]],
      [[BLOCK_64X16, BLOCK_INVALID], [BLOCK_32X16, BLOCK_32X8]],
    ];
    let subx = plane > 0 ? h.subsampling_x : 0;
    let suby = plane > 0 ? h.subsampling_y : 0;
    return Subsampled_Size[subsize][subx][suby]
  }

  // 5.11.39. Coefficients syntax
  coeffs({ b, h }: { b: BitReader, h: any }, plane: number, startX: number, startY: number, txSz: number) {
    let x4 = startX >> 2;
    let y4 = startY >> 2;
    let w4 = Tx_Width[txSz] >> 2;
    let h4 = Tx_Height[txSz] >> 2;
    let txSzCtx = (Tx_Size_Sqr[txSz] + Tx_Size_Sqr_Up[txSz] + 1) >> 1;
    let ptype = plane > 0;
    let segEob = (txSz == TX_16X64 || txSz == TX_64X16) ? 512 :
      Math.min(1024, Tx_Width[txSz] * Tx_Height[txSz]);
    for (let c = 0; c < segEob; c++)
      h[`Quant[${c}]`] = 0;
    for (let i = 0; i < 64; i++)
      for (let j = 0; j < 64; j++)
        h[`Dequant[${i}][${j}]`] = 0;
    let eob = 0;
    let culLevel = 0;
    let dcCategory = 0;
    h.all_zero = b.S();
    if (h.all_zero) {
      let c = 0;
      if (plane == 0) {
        for (let i = 0; i < w4; i++) {
          for (let j = 0; j < h4; j++) {
            h[`TxTypes[${y4 + j}][${x4 + i}]`] = DCT_DCT;
          }
        }
      }
    } else {
      if (plane == 0)
        this.transform_type({ b, h }, x4, y4, txSz);
      h.PlaneTxType = this.compute_tx_type({ b, h }, plane, txSz, x4, y4);
      let scan = this.get_scan({ b, h }, txSz);
      let eobMultisize = Math.min(Tx_Width_Log2[txSz], 5) + Math.min(Tx_Height_Log2[txSz], 5) - 4;
      let eobPt = 0;
      if (eobMultisize == 0) {
        h.eob_pt_16 = b.S();
        eobPt = h.eob_pt_16 + 1;
      } else if (eobMultisize == 1) {
        h.eob_pt_32 = b.S();
        eobPt = h.eob_pt_32 + 1;
      } else if (eobMultisize == 2) {
        h.eob_pt_64 = b.S();
        eobPt = h.eob_pt_64 + 1;
      } else if (eobMultisize == 3) {
        h.eob_pt_128 = b.S();
        eobPt = h.eob_pt_128 + 1;
      } else if (eobMultisize == 4) {
        h.eob_pt_256 = b.S();
        eobPt = h.eob_pt_256 + 1;
      } else if (eobMultisize == 5) {
        h.eob_pt_512 = b.S();
        eobPt = h.eob_pt_512 + 1;
      } else {
        h.eob_pt_1024 = b.S();
        eobPt = h.eob_pt_1024 + 1;
      }
      eob = (eobPt < 2) ? eobPt : ((1 << (eobPt - 2)) + 1);
      let eobShift = Math.max(-1, eobPt - 3);
      if (eobShift >= 0) {
        h.eob_extra = b.S();
        if (h.eob_extra) {
          eob += (1 << eobShift);
        }
        for (let i = 1; i < Math.max(0, eobPt - 2); i++) {
          eobShift = Math.max(0, eobPt - 2) - 1 - i;
          h.eob_extra_bit = b.L(1);
          if (h.eob_extra_bit) {
            eob += (1 << eobShift);
          }
        }
      }
      for (let c = eob - 1; c >= 0; c--) {
        let pos = scan[c];
        let level = 0;
        if (c == (eob - 1)) {
          h.coeff_base_eob = b.S();
          level = h.coeff_base_eob + 1;
        } else {
          h.coeff_base = b.S();
          level = h.coeff_base;
        }
        if (level > NUM_BASE_LEVELS) {
          for (let idx = 0;
            idx < COEFF_BASE_RANGE / (BR_CDF_SIZE - 1);
            idx++) {
            h.coeff_br = b.S();
            level += h.coeff_br;
            if (h.coeff_br < (BR_CDF_SIZE - 1))
              break;
          }
        }
        h[`Quant[${pos}]`] = level;
      }
      for (let c = 0; c < eob; c++) {
        let pos = scan[c]
        let sign = 0;
        if (h[`Quant[${pos}]`] != 0) {
          if (c == 0) {
            h.dc_sign = b.S();
            sign = h.dc_sign;
          } else {
            h.sign_bit = b.L(1);
            sign = h.sign_bit;
          }
        }
        if (h[`Quant[${pos}]`] >
          (NUM_BASE_LEVELS + COEFF_BASE_RANGE)) {
          let length = 0
          do {
            length++
            h.golomb_length_bit = b.L(1);
          } while (!h.golomb_length_bit)
          let x = 1;
          for (let i = length - 2; i >= 0; i--) {
            h.golomb_data_bit = b.L(1);
            x = (x << 1) | h.golomb_data_bit;
          }
          h[`Quant[${pos}]`] = x + COEFF_BASE_RANGE + NUM_BASE_LEVELS;
        }
        if (pos == 0 && h[`Quant[${pos}]`] > 0) {
          dcCategory = sign ? 1 : 2;
        }
        h[`Quant[${pos}]`] = h[`Quant[${pos}]`] & 0xFFFFF;
        culLevel += h[`Quant[${pos}]`];
        if (sign)
          h[`Quant[${pos}]`] = - h[`Quant[${pos}]`];
      }
      culLevel = Math.min(63, culLevel);
    }
    for (let i = 0; i < w4; i++) {
      h[`AboveLevelContext[${plane}][${x4 + i}]`] = culLevel;
      h[`AboveDcContext[${plane}][${x4 + i}]`] = dcCategory;
    }
    for (let i = 0; i < h4; i++) {
      h[`LeftLevelContext[${plane}][${y4 + i}]`] = culLevel;
      h[`LeftDcContext[${plane}][${y4 + i}]`] = dcCategory;
    }
    return eob;
  }

  // 5.11.40. Compute transform type function
  compute_tx_type({ b, h }: { b: BitReader, h: any }, plane: number, txSz: number, blockX: number, blockY: number) {
    let txSzSqrUp = Tx_Size_Sqr_Up[txSz];
    if (h.Lossless || txSzSqrUp > TX_32X32)
      return DCT_DCT;
    let txSet = this.get_tx_set({ b, h }, txSz);
    if (plane == 0) {
      return h[`TxTypes[${blockY}][${blockX}]`];
    }
    if (h.is_inter) {
      let x4 = Math.max(h.MiCol, blockX << h.subsampling_x);
      let y4 = Math.max(h.MiRow, blockY << h.subsampling_y);
      let txType = h[`TxTypes[${y4}][${x4}]`];
      if (!this.is_tx_type_in_set({ b, h }, txSet, txType))
        return DCT_DCT;
      return txType;
    }
    let txType = Mode_To_Txfm[h.UVMode]
    if (!this.is_tx_type_in_set({ b, h }, txSet, txType))
      return DCT_DCT;
    return txType;
  }

  is_tx_type_in_set({ b, h }: { b: BitReader, h: any }, txSet: number, txType: number) {
    const Tx_Type_In_Set_Intra = [
      [
        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      ],
      [
        1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0,
      ],
      [
        1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,
      ]
    ];
    const Tx_Type_In_Set_Inter = [
      [
        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      ],
      [
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
      ],
      [
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0,
      ],
      [
        1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,
      ]
    ];
    return h.is_inter ? Tx_Type_In_Set_Inter[txSet][txType] :
      Tx_Type_In_Set_Intra[txSet][txType];
  }

  // 5.11.41. Get scan function
  get_mrow_scan(txSz: number) {
    if (txSz == TX_4X4)
      return Mrow_Scan_4x4;
    else if (txSz == TX_4X8)
      return Mrow_Scan_4x8;
    else if (txSz == TX_8X4)
      return Mrow_Scan_8x4;
    else if (txSz == TX_8X8)
      return Mrow_Scan_8x8;
    else if (txSz == TX_8X16)
      return Mrow_Scan_8x16;
    else if (txSz == TX_16X8)
      return Mrow_Scan_16x8;
    else if (txSz == TX_16X16)
      return Mrow_Scan_16x16;
    else if (txSz == TX_4X16)
      return Mrow_Scan_4x16;
    return Mrow_Scan_16x4;
  }

  get_mcol_scan(txSz: number) {
    if (txSz == TX_4X4)
      return Mcol_Scan_4x4;
    else if (txSz == TX_4X8)
      return Mcol_Scan_4x8;
    else if (txSz == TX_8X4)
      return Mcol_Scan_8x4;
    else if (txSz == TX_8X8)
      return Mcol_Scan_8x8;
    else if (txSz == TX_8X16)
      return Mcol_Scan_8x16;
    else if (txSz == TX_16X8)
      return Mcol_Scan_16x8;
    else if (txSz == TX_16X16)
      return Mcol_Scan_16x16;
    else if (txSz == TX_4X16)
      return Mcol_Scan_4x16;
    return Mcol_Scan_16x4;
  }

  get_default_scan(txSz: number) {
    if (txSz == TX_4X4)
      return Default_Scan_4x4;
    else if (txSz == TX_4X8)
      return Default_Scan_4x8;
    else if (txSz == TX_8X4)
      return Default_Scan_8x4;
    else if (txSz == TX_8X8)
      return Default_Scan_8x8;
    else if (txSz == TX_8X16)
      return Default_Scan_8x16;
    else if (txSz == TX_16X8)
      return Default_Scan_16x8;
    else if (txSz == TX_16X16)
      return Default_Scan_16x16;
    else if (txSz == TX_16X32)
      return Default_Scan_16x32;
    else if (txSz == TX_32X16)
      return Default_Scan_32x16;
    else if (txSz == TX_4X16)
      return Default_Scan_4x16;
    else if (txSz == TX_16X4)
      return Default_Scan_16x4;
    else if (txSz == TX_8X32)
      return Default_Scan_8x32;
    else if (txSz == TX_32X8)
      return Default_Scan_32x8;
    return Default_Scan_32x32;
  }

  get_scan({ b, h }: { b: BitReader, h: any }, txSz: number) {
    if (txSz == TX_16X64) {
      return Default_Scan_16x32;
    }
    if (txSz == TX_64X16) {
      return Default_Scan_32x16;
    }
    if (Tx_Size_Sqr_Up[txSz] == TX_64X64) {
      return Default_Scan_32x32;
    }
    if (h.PlaneTxType == IDTX) {
      return this.get_default_scan(txSz);
    }
    let preferRow = (h.PlaneTxType == V_DCT ||
      h.PlaneTxType == V_ADST ||
      h.PlaneTxType == V_FLIPADST)
    let preferCol = (h.PlaneTxType == H_DCT ||
      h.PlaneTxType == H_ADST ||
      h.PlaneTxType == H_FLIPADST)
    if (preferRow) {
      return this.get_mrow_scan(txSz);
    } else if (preferCol) {
      return this.get_mcol_scan(txSz);
    }
    return this.get_default_scan(txSz);
  }

  // 5.11.42. Intra angle info luma syntax
  intra_angle_info_y({ b, h }: { b: BitReader, h: any }) {
    h.AngleDeltaY = 0;
    if (h.MiSize >= BLOCK_8X8) {
      if (this.is_directional_mode(h.YMode)) {
        h.angle_delta_y = b.S();
        h.AngleDeltaY = h.angle_delta_y - MAX_ANGLE_DELTA;
      }
    }
  }

  // 5.11.43. Intra angle info chroma syntax
  intra_angle_info_uv({ b, h }: { b: BitReader, h: any }) {
    h.AngleDeltaUV = 0;
    if (h.MiSize >= BLOCK_8X8) {
      if (this.is_directional_mode(h.UVMode)) {
        h.angle_delta_uv = b.S();
        h.AngleDeltaUV = h.angle_delta_uv - MAX_ANGLE_DELTA;
      }
    }
  }

  // 5.11.44. Is directional mode function
  is_directional_mode(mode: number) {
    if ((mode >= V_PRED) && (mode <= D67_PRED)) {
      return 1;
    }
    return 0;
  }

  // 5.11.45. Read CFL alphas syntax
  read_cfl_alphas({ b, h }: { b: BitReader, h: any }) {
    /** +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     *  | cfl_alpha_signs | Name of signU | Name of signV |
     *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     *  |        0        | CFL_SIGN_ZERO | CFL_SIGN_NEG  |
     *  |        1        | CFL_SIGN_ZERO | CFL_SIGN_POS  |
     *  |        2        | CFL_SIGN_NEG  | CFL_SIGN_ZERO |
     *  |        3        | CFL_SIGN_NEG  | CFL_SIGN_NEG  |
     *  |        4        | CFL_SIGN_NEG  | CFL_SIGN_POS  |
     *  |        5        | CFL_SIGN_POS  | CFL_SIGN_ZERO |
     *  |        6        | CFL_SIGN_POS  | CFL_SIGN_NEG  |
     *  |        7        | CFL_SIGN_POS  | CFL_SIGN_POS  |
     *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     */
    h.cfl_alpha_signs = b.S();
    let signU = (h.cfl_alpha_signs + 1) / 3;
    let signV = (h.cfl_alpha_signs + 1) % 3;
    if (signU != 0 && signU != 1) { // signU != CFL_SIGN_ZERO
      h.cfl_alpha_u = b.S();
      h.CflAlphaU = 1 + h.cfl_alpha_u;
      if (signU == CFL_SIGN_NEG)
        h.CflAlphaU = -h.CflAlphaU;
    } else {
      h.CflAlphaU = 0;
    }
    if (signV != CFL_SIGN_ZERO) {
      h.cfl_alpha_v = b.S();
      h.CflAlphaV = 1 + h.cfl_alpha_v;
      if (signV == CFL_SIGN_NEG)
        h.CflAlphaV = -h.CflAlphaV;
    } else {
      h.CflAlphaV = 0;
    }
  }

  // 5.11.46. Palette mode info syntax
  palette_mode_info({ b, h }: { b: BitReader, h: any }) {
    let bsizeCtx = Mi_Width_Log2[h.MiSize] + Mi_Height_Log2[h.MiSize] - 2;
    if (h.YMode == DC_PRED) {
      h.has_palette_y = b.S();
      if (h.has_palette_y) {
        h.palette_size_y_minus_2 = b.S();
        h.PaletteSizeY = h.palette_size_y_minus_2 + 2;
        let cacheN = this.get_palette_cache({ b, h }, 0);
        let idx = 0;
        for (let i = 0; i < cacheN && idx < h.PaletteSizeY; i++) {
          h.use_palette_color_cache_y = b.L(1);
          if (h.use_palette_color_cache_y) {
            h[`palette_colors_y[${idx}]`] = h[`PaletteCache[${i}]`];
            idx++;
          }
        }
        if (idx < h.PaletteSizeY) {
          h[`palette_colors_y[${idx}]`] = b.L(h.BitDepth);
          idx++;
        }
        let paletteBits = 0;
        if (idx < h.PaletteSizeY) {
          let minBits = h.BitDepth - 3;
          h.palette_num_extra_bits_y = b.L(2);
          paletteBits = minBits + h.palette_num_extra_bits_y;
        }
        while (idx < h.PaletteSizeY) {
          h.palette_delta_y = b.L(paletteBits);
          h.palette_delta_y++;
          h[`palette_colors_y[${idx}]`] =
            this.Clip1(h[`palette_colors_y[${idx - 1}]`] +
              h.palette_delta_y);
          let range = (1 << h.BitDepth) - h[`palette_colors_y[${idx}]`] - 1;
          paletteBits = Math.min(paletteBits, CeilLog2(range));
          idx++;
        }
        this.sort(h.palette_colors_y, 0, h.PaletteSizeY - 1);
      }
    }
    if (h.HasChroma && h.UVMode == DC_PRED) {
      h.has_palette_uv = b.S();
      if (h.has_palette_uv) {
        h.palette_size_uv_minus_2 = b.S();
        h.PaletteSizeUV = h.palette_size_uv_minus_2 + 2;
        let cacheN = this.get_palette_cache({ b, h }, 1);
        let idx = 0
        for (let i = 0; i < cacheN && idx < h.PaletteSizeUV; i++) {
          h.use_palette_color_cache_u = b.L(1);
          if (h.use_palette_color_cache_u) {
            h[`palette_colors_u[${idx}]`] = h[`PaletteCache[${i}]`];
            idx++;
          }
        }
        if (idx < h.PaletteSizeUV) {
          h[`palette_colors_u[${idx}]`] = b.L(h.BitDepth);
          idx++;
        }
        let paletteBits = 0;
        if (idx < h.PaletteSizeUV) {
          let minBits = h.BitDepth - 3;
          h.palette_num_extra_bits_u = b.L(2);
          paletteBits = minBits + h.palette_num_extra_bits_u;
        }
        while (idx < h.PaletteSizeUV) {
          h.palette_delta_u = b.L(paletteBits);
          h[`palette_colors_u[${idx}]`] =
            this.Clip1(h[`palette_colors_u[${idx - 1}]`] +
              h.palette_delta_u);
          let range = (1 << h.BitDepth) - h[`palette_colors_u[${idx}]`];
          paletteBits = Math.min(paletteBits, CeilLog2(range));
          idx++;
        }
        this.sort(h.palette_colors_u, 0, h.PaletteSizeUV - 1);
        h.delta_encode_palette_colors_v = b.L(1);
        if (h.delta_encode_palette_colors_v) {
          let minBits = h.BitDepth - 4;
          let maxVal = 1 << h.BitDepth;
          h.palette_num_extra_bits_v = b.L(2);
          paletteBits = minBits + h.palette_num_extra_bits_v;
          h[`palette_colors_v[0]`] = b.L(h.BitDepth);
          for (let idx = 1; idx < h.PaletteSizeUV; idx++) {
            h.palette_delta_v = b.L(paletteBits);
            if (h.palette_delta_v) {
              h.palette_delta_sign_bit_v = b.L(1);
              if (h.palette_delta_sign_bit_v) {
                h.palette_delta_v = -h.palette_delta_v;
              }
            }
            let val = h[`palette_colors_v[${idx - 1}]`] + h.palette_delta_v;
            if (val < 0) val += maxVal;
            if (val >= maxVal) val -= maxVal;
            h[`palette_colors_v[${idx}]`] = this.Clip1(val);
          }
        } else {
          for (idx = 0; idx < h.PaletteSizeUV; idx++) {
            h[`palette_colors_v[idx]`] = b.L(h.BitDepth);
          }
        }
      }
    }
  }

  get_palette_cache({ b, h }: { b: BitReader, h: any }, plane: number) {
    let aboveN = 0;
    if ((h.MiRow * MI_SIZE) % 64) {
      aboveN = h[`PaletteSizes[${plane}][${h.MiRow - 1}][${h.MiCol}]`];
    }
    let leftN = 0;
    if (h.AvailL) {
      leftN = h[`PaletteSizes[${plane}][${h.MiRow}][${h.MiCol - 1}]`];
    }
    let aboveIdx = 0;
    let leftIdx = 0;
    let n = 0
    while (aboveIdx < aboveN && leftIdx < leftN) {
      let aboveC = h[`PaletteColors[${plane}][${h.MiRow - 1}][${h.MiCol}][${aboveIdx}]`];
      let leftC = h[`PaletteColors[${plane}][${h.MiRow}][${h.MiCol - 1}][${leftIdx}]`];
      if (leftC < aboveC) {
        if (n == 0 || leftC != h[`PaletteCache[${n - 1}]`]) {
          h[`PaletteCache[${n}]`] = leftC;
          n++;
        }
        leftIdx++;
      } else {
        if (n == 0 || aboveC != h[`PaletteCache[${n - 1}]`]) {
          h[`PaletteCache[${n}]`] = aboveC;
          n++;
        }
        aboveIdx++;
        if (leftC == aboveC) {
          leftIdx++;
        }
      }
    }
    while (aboveIdx < aboveN) {
      let val = h[`PaletteColors[${plane}][${h.MiRow - 1}][${h.MiCol}][${aboveIdx}]`];
      aboveIdx++;
      if (n == 0 || val != h[`PaletteCache[${n - 1}]`]) {
        h[`PaletteCache[${n}]`] = val;
        n++;
      }
    }
    while (leftIdx < leftN) {
      let val = h[`PaletteColors[${plane}][${h.MiRow}][${h.MiCol - 1}][${leftIdx}]`];
      leftIdx++;
      if (n == 0 || val != h[`PaletteCache[${n - 1}]`]) {
        h[`PaletteCache[${n}]`] = val;
        n++;
      }
    }
    return n;
  }

  // 5.11.47. Transform type syntax
  transform_type({ b, h }: { b: BitReader, h: any }, x4: number, y4: number, txSz: number) {
    const Tx_Type_Intra_Inv_Set1 = [IDTX, DCT_DCT, V_DCT, H_DCT, ADST_ADST, ADST_DCT, DCT_ADST];
    const Tx_Type_Intra_Inv_Set2 = [IDTX, DCT_DCT, ADST_ADST, ADST_DCT, DCT_ADST];
    const Tx_Type_Inter_Inv_Set1 = [
      IDTX, V_DCT, H_DCT, V_ADST, H_ADST, V_FLIPADST, H_FLIPADST,
      DCT_DCT, ADST_DCT, DCT_ADST, FLIPADST_DCT, DCT_FLIPADST, ADST_ADST,
      FLIPADST_FLIPADST, ADST_FLIPADST, FLIPADST_ADST];
    const Tx_Type_Inter_Inv_Set2 = [
      IDTX, V_DCT, H_DCT, DCT_DCT, ADST_DCT, DCT_ADST, FLIPADST_DCT,
      DCT_FLIPADST, ADST_ADST, FLIPADST_FLIPADST, ADST_FLIPADST,
      FLIPADST_ADST];
    const Tx_Type_Inter_Inv_Set3 = [IDTX, DCT_DCT];

    let set = this.get_tx_set({ b, h }, txSz);
    if (set > 0 &&
      (h.segmentation_enabled ? this.get_qindex({ h }, 1, h.segment_id) : h.base_q_idx) > 0) {
      if (h.is_inter) {
        h.inter_tx_type = b.S();
        if (set == TX_SET_INTER_1)
          h.TxType = Tx_Type_Inter_Inv_Set1[h.inter_tx_type]
        else if (set == TX_SET_INTER_2)
          h.TxType = Tx_Type_Inter_Inv_Set2[h.inter_tx_type]
        else
          h.TxType = Tx_Type_Inter_Inv_Set3[h.inter_tx_type]
      } else {
        h.intra_tx_type = b.S();
        if (set == TX_SET_INTRA_1)
          h.TxType = Tx_Type_Intra_Inv_Set1[h.intra_tx_type]
        else
          h.TxType = Tx_Type_Intra_Inv_Set2[h.intra_tx_type]
      }
    } else {
      h.TxType = DCT_DCT
    }
    for (let i = 0; i < (Tx_Width[txSz] >> 2); i++) {
      for (let j = 0; j < (Tx_Height[txSz] >> 2); j++) {
        h[`TxTypes[${y4 + j}][${x4 + i}]`] = h.TxType;
      }
    }
  }

  // 5.11.48. Get transform set function
  get_tx_set({ b, h }: { b: BitReader, h: any }, txSz: number) {
    let txSzSqr = Tx_Size_Sqr[txSz];
    let txSzSqrUp = Tx_Size_Sqr_Up[txSz];
    if (txSzSqrUp > TX_32X32)
      return TX_SET_DCTONLY
    if (h.is_inter) {
      if (h.reduced_tx_set || txSzSqrUp == TX_32X32) return TX_SET_INTER_3;
      else if (txSzSqr == TX_16X16) return TX_SET_INTER_2
      return TX_SET_INTER_1;
    } else {
      if (txSzSqrUp == TX_32X32) return TX_SET_DCTONLY
      else if (h.reduced_tx_set) return TX_SET_INTRA_2
      else if (txSzSqr == TX_16X16) return TX_SET_INTRA_2
      return TX_SET_INTRA_1
    }
  }

  // 5.11.49. Palette tokens syntax
  palette_tokens({ b, h }: { b: BitReader, h: any }) {
    let blockHeight = Block_Height[h['MiSize']];
    let blockWidth = Block_Width[h['MiSize']];
    let onscreenHeight = Math.min(blockHeight, (h['MiRows'] - h['MiRow']) * MI_SIZE);
    let onscreenWidth = Math.min(blockWidth, (h['MiCols'] - h['MiCol']) * MI_SIZE);
    if (h['PaletteSizeY']) {
      h.color_index_map_y = b.NS(h['PaletteSizeY']);
      h[`ColorMapY[0][0]`] = h.color_index_map_y;
      for (let i = 1; i < onscreenHeight + onscreenWidth - 1; i++) {
        for (let j = Math.min(i, onscreenWidth - 1);
          j >= Math.max(0, i - onscreenHeight + 1); j--) {
          this.get_palette_color_context({ b, h },
            h['ColorMapY'], (i - j), j, h['PaletteSizeY']);
          h.palette_color_idx_y = b.S();
          h[`ColorMapY[${i - j}][${j}]`] = h[`ColorOrder[${h.palette_color_idx_y}]`];
        }
      }
      for (let i = 0; i < onscreenHeight; i++) {
        for (let j = onscreenWidth; j < blockWidth; j++) {
          h[`ColorMapY[${i}][${j}]`] = h[`ColorMapY[${i}][${onscreenWidth - 1}]`];
        }
      }
      for (let i = onscreenHeight; i < blockHeight; i++) {
        for (let j = 0; j < blockWidth; j++) {
          h[`ColorMapY[${i}][${j}]`] = h[`ColorMapY[${onscreenHeight - 1}][${j}]`]
        }
      }
    }
    if (h['PaletteSizeUV']) {
      h.color_index_map_uv = b.NS(h['PaletteSizeUV']);
      h[`ColorMapUV[0][0]`] = h.color_index_map_uv;
      blockHeight = blockHeight >> h.subsampling_y;
      blockWidth = blockWidth >> h.subsampling_x;
      onscreenHeight = onscreenHeight >> h.subsampling_y;
      onscreenWidth = onscreenWidth >> h.subsampling_x;
      if (blockWidth < 4) {
        blockWidth += 2;
        onscreenWidth += 2;
      }
      if (blockHeight < 4) {
        blockHeight += 2;
        onscreenHeight += 2;
      }
      for (let i = 1; i < onscreenHeight + onscreenWidth - 1; i++) {
        for (let j = Math.min(i, onscreenWidth - 1);
          j >= Math.max(0, i - onscreenHeight + 1); j--) {
          this.get_palette_color_context({ b, h },
            h['ColorMapUV'], (i - j), j, h['PaletteSizeUV']);
          h.palette_color_idx_uv = b.S();
          h[`ColorMapUV[${i - j}][${j}]`] = h[`ColorOrder[${h.palette_color_idx_uv}]`];
        }
      }
      for (let i = 0; i < onscreenHeight; i++) {
        for (let j = onscreenWidth; j < blockWidth; j++) {
          h[`ColorMapUV[${i}][${j}]`] = h[`ColorMapUV[${i}][${onscreenWidth - 1}]`];
        }
      }
      for (let i = onscreenHeight; i < blockHeight; i++) {
        for (let j = 0; j < blockWidth; j++) {
          h[`ColorMapUV[${i}][${j}]`] = h[`ColorMapUV[${onscreenHeight - 1}][${j}]`];
        }
      }
    }
  }

  // 5.11.50. Palette color context function
  get_palette_color_context({ b, h }: { b: BitReader, h: any }, colorMap: number[][], r: number, c: number, n: number) {
    let scores = [0, 0, 0, 0, 0, 0, 0, 0];
    for (let i = 0; i < PALETTE_COLORS; i++) {
      scores[i] = 0
      h[`ColorOrder[${i}]`] = i;
    }
    let neighbor = 0;
    if (c > 0) {
      neighbor = colorMap[r][c - 1]
      scores[neighbor] += 2
    }
    if ((r > 0) && (c > 0)) {
      neighbor = colorMap[r - 1][c - 1]
      scores[neighbor] += 1
    }
    if (r > 0) {
      neighbor = colorMap[r - 1][c]
      scores[neighbor] += 2
    }
    for (let i = 0; i < PALETTE_NUM_NEIGHBORS; i++) {
      let maxScore = scores[i];
      let maxIdx = i;
      for (let j = i + 1; j < n; j++) {
        if (scores[j] > maxScore) {
          maxScore = scores[j]
          maxIdx = j
        }
      }
      if (maxIdx != i) {
        maxScore = scores[maxIdx]
        let maxColorOrder = h[`ColorOrder[${maxIdx}]`];
        for (let k = maxIdx; k > i; k--) {
          scores[k] = scores[k - 1]
          h[`ColorOrder[${k}]`] = h[`ColorOrder[${k - 1}]`];
        }
        scores[i] = maxScore
        h[`ColorOrder[${i}]`] = maxColorOrder;
      }
    }
    h.ColorContextHash = 0;
    for (let i = 0; i < PALETTE_NUM_NEIGHBORS; i++) {
      h.ColorContextHash += scores[i] * Palette_Color_Hash_Multipliers[i]
    }
  }

  // 5.11.51. Is inside function
  is_inside({ b, h }: { b: BitReader, h: any }, candidateR: number, candidateC: number) {
    return (candidateC >= h['MiColStart'] &&
      candidateC < h['MiColEnd'] &&
      candidateR >= h['MiRowStart'] &&
      candidateR < h['MiRowEnd']);
  }

  // 5.11.52. Is inside filter region function
  is_inside_filter_region({ b, h }: { b: BitReader, h: any }, candidateR: number, candidateC: number) {
    let colStart = 0;
    let colEnd = h.MiCols;
    let rowStart = 0;
    let rowEnd = h.MiRows;
    return (candidateC >= colStart &&
      candidateC < colEnd &&
      candidateR >= rowStart &&
      candidateR < rowEnd);
  }

  // 5.11.53. Clamp MV row function
  clamp_mv_row({ b, h }: { b: BitReader, h: any }, mvec: number, border: number) {
    let bh4 = Num_4x4_Blocks_High[h.MiSize]
    let mbToTopEdge = -((h.MiRow * MI_SIZE) * 8);
    let mbToBottomEdge = ((h.MiRows - bh4 - h.MiRow) * MI_SIZE) * 8;
    return this.Clip3(mbToTopEdge - border, mbToBottomEdge + border, mvec);
  }

  // 5.11.54. Clamp MV col function
  clamp_mv_col({ b, h }: { b: BitReader, h: any }, mvec: number, border: number) {
    let bw4 = Num_4x4_Blocks_Wide[h.MiSize];
    let mbToLeftEdge = -((h.MiCol * MI_SIZE) * 8);
    let mbToRightEdge = ((h.MiCols - bw4 - h.MiCol) * MI_SIZE) * 8;
    return this.Clip3(mbToLeftEdge - border, mbToRightEdge + border, mvec);
  }

  // 5.11.55. Clear CDEF function
  clear_cdef({ b, h }: { b: BitReader, h: any }, r: number, c: number) {
    h[`cdef_idx[${r}][${c}]`] = -1; // 定对于特定的64×64块应该使用哪些CDEF过滤参数。值-1表示对该块禁用CDEF
    if (this.seq_header.use_128x128_superblock) {
      let cdefSize4 = Num_4x4_Blocks_Wide[BLOCK_64X64];
      h[`cdef_idx[${r}][${c + cdefSize4}]`] = -1;
      h[`cdef_idx[${r + cdefSize4}][${c}]`] = -1;
      h[`cdef_idx[${r + cdefSize4}][${c + cdefSize4}]`] = -1;
    }
  }

  // 5.11.56. Read CDEF syntax
  read_cdef({ b, h }: { b: BitReader, h: any }) {
    if (h.skip || h.CodedLossless || !h.enable_cdef || h.allow_intrabc) {
      return;
    }
    let cdefSize4 = Num_4x4_Blocks_Wide[BLOCK_64X64];
    let cdefMask4 = ~(cdefSize4 - 1);
    let r = h.MiRow & cdefMask4;
    let c = h.MiCol & cdefMask4;
    if (h[`cdef_idx[${r}][${c}]`] == -1) {
      h[`cdef_idx[${r}][${c}]`] = b.L(h.cdef_bits);
      let w4 = Num_4x4_Blocks_Wide[h.MiSize];
      let h4 = Num_4x4_Blocks_High[h.MiSize];
      for (let i = r; i < r + h4; i += cdefSize4) {
        for (let j = c; j < c + w4; j += cdefSize4) {
          h[`cdef_idx[${i}][${j}]`] = h[`cdef_idx[${r}][${c}]`];
        }
      }
    }
  }

  // 5.11.57. Read loop restoration syntax
  read_lr({ b, h }: { b: BitReader, h: any }, r: number, c: number, bSize: number) {
    let count_units_in_frame = function (unitSize: number, frameSize: number) {
      return Math.max((frameSize + (unitSize >> 1)) / unitSize, 1);
    }
    if (h.allow_intrabc) {
      return;
    }
    let wide = Num_4x4_Blocks_Wide[bSize];
    let high = Num_4x4_Blocks_High[bSize];
    for (let plane = 0; plane < h['NumPlanes']; plane++) {
      if (h[`FrameRestorationType[${plane}]`] != RESTORE_NONE) {
        let subX = (plane == 0) ? 0 : this.seq_header.subsampling_x;
        let subY = (plane == 0) ? 0 : this.seq_header.subsampling_y;
        let unitSize = h[`LoopRestorationSize[${plane}]`];

        let unitRows = count_units_in_frame(unitSize, Round2(h.FrameHeight, subY));
        let unitCols = count_units_in_frame(unitSize, Round2(h.UpscaledWidth, subX));
        let unitRowStart = (r * (MI_SIZE >> subY) +
          unitSize - 1) / unitSize;
        let unitRowEnd = Math.min(unitRows, ((r + high) * (MI_SIZE >> subY) +
          unitSize - 1) / unitSize);
        let numerator = 0;
        let denominator = 0;
        if (h.use_superres) {
          numerator = (MI_SIZE >> subX) * h['SuperresDenom'];
          denominator = unitSize * SUPERRES_NUM;
        } else {
          numerator = MI_SIZE >> subX;
          denominator = unitSize;
        }
        let unitColStart = (c * numerator + denominator - 1) / denominator
        let unitColEnd = Math.min(unitCols, ((c + wide) * numerator +
          denominator - 1) / denominator);
        for (let unitRow = unitRowStart; unitRow < unitRowEnd; unitRow++) {
          for (let unitCol = unitColStart; unitCol < unitColEnd; unitCol++) {
            this.read_lr_unit({ b, h }, plane, unitRow, unitCol)
          }
        }
      }
    }
  }

  // 5.11.58. Read loop restoration unit syntax
  read_lr_unit({ b, h }: { b: BitReader, h: any }, plane: number, unitRow: number, unitCol: number) {
    const Wiener_Taps_Min = [-5, -23, -17];
    const Wiener_Taps_Max = [10, 8, 46];
    const Wiener_Taps_K = [1, 2, 3];
    const Sgrproj_Xqd_Min = [-96, -32];
    const Sgrproj_Xqd_Max = [31, 95];
    const Sgr_Params = [
      [2, 12, 1, 4], [2, 15, 1, 6], [2, 18, 1, 8], [2, 21, 1, 9],
      [2, 24, 1, 10], [2, 29, 1, 11], [2, 36, 1, 12], [2, 45, 1, 13],
      [2, 56, 1, 14], [2, 68, 1, 15], [0, 0, 1, 5], [0, 0, 1, 8],
      [0, 0, 1, 11], [0, 0, 1, 14], [2, 30, 0, 0], [2, 75, 0, 0]
    ];

    if (h[`FrameRestorationType[${plane}]`] == RESTORE_WIENER) {
      h.use_wiener = b.S();
      h.restoration_type = h.use_wiener ? RESTORE_WIENER : RESTORE_NONE;
    } else if (h[`FrameRestorationType[${plane}]`] == RESTORE_SGRPROJ) {
      h.use_sgrproj = b.S();
      h.restoration_type = h.use_sgrproj ? RESTORE_SGRPROJ : RESTORE_NONE;
    } else {
      h.restoration_type = b.S();
    }
    h[`LrType[${plane}][${unitRow}][${unitCol}]`] = h.restoration_type;
    if (h.restoration_type == RESTORE_WIENER) {
      for (let pass = 0; pass < 2; pass++) {
        let firstCoeff = 0;
        if (plane) {
          firstCoeff = 1;
          h[`LrWiener[plane][unitRow][unitCol][pass][0]`] = 0;
        } else {
          firstCoeff = 0;
        }
        for (let j = firstCoeff; j < 3; j++) {
          let min = Wiener_Taps_Min[j];
          let max = Wiener_Taps_Max[j];
          let k = Wiener_Taps_K[j];
          let v = this.decode_signed_subexp_with_ref_bool({ b, h },
            min, max + 1, k, h[`RefLrWiener[${plane}][${pass}][${j}]`]);
          h[`LrWiener[${plane}][${unitRow}][${unitCol}][${pass}][${j}]`] = v;
          h[`RefLrWiener[${plane}][${pass}][${j}]`] = v;
        }
      }
    } else if (h.restoration_type == RESTORE_SGRPROJ) {
      h.lr_sgr_set = b.L(SGRPROJ_PARAMS_BITS);
      h[`LrSgrSet[${plane}][${unitRow}][${unitCol}]`] = h.lr_sgr_set;
      for (let i = 0; i < 2; i++) {
        let radius = Sgr_Params[h.lr_sgr_set][i * 2];
        let min = Sgrproj_Xqd_Min[i];
        let max = Sgrproj_Xqd_Max[i];
        let v = 0;
        if (radius) {
          v = this.decode_signed_subexp_with_ref_bool({ b, h },
            min, max + 1, SGRPROJ_PRJ_SUBEXP_K,
            h[`RefSgrXqd[${plane}][${i}]`]);
        } else {
          v = 0;
          if (i == 1) {
            v = this.Clip3(min, max, (1 << SGRPROJ_PRJ_BITS) -
              h[`RefSgrXqd[${plane}][0]`])
          }
        }
        h[`LrSgrXqd[${plane}][${unitRow}][${unitCol}][${i}]`] = v;
        h[`RefSgrXqd[${plane}][${i}]`] = v;
      }
    }
  }

  decode_signed_subexp_with_ref_bool({ b, h }: { b: BitReader, h: any }, low: number, high: number, k: number, r: number) {
    let x = this.decode_unsigned_subexp_with_ref_bool({ b, h }, high - low, k, r - low)
    return x + low;
  }

  decode_unsigned_subexp_with_ref_bool({ b, h }: { b: BitReader, h: any }, mx: number, k: number, r: number) {
    let v = this.decode_subexp_bool({ b, h }, mx, k);
    if ((r << 1) <= mx) {
      return this.inverse_recenter(r, v);
    } else {
      return mx - 1 - this.inverse_recenter(mx - 1 - r, v);
    }
  }

  decode_subexp_bool({ b, h }: { b: BitReader, h: any }, numSyms: number, k: number) {
    let i = 0;
    let mk = 0;
    while (1) {
      let b2 = i ? k + i - 1 : k;
      let a = 1 << b2;
      if (numSyms <= mk + 3 * a) {
        h.subexp_unif_bools = b.NS(numSyms - mk);
        return h.subexp_unif_bools + mk;
      } else {
        h.subexp_more_bools = b.L(1);
        if (h.subexp_more_bools) {
          i++;
          mk += a;
        } else {
          h.subexp_bools = b.L(b2);
          return h.subexp_bools + mk;
        }
      }
    }
  }

  // 7.10.3. Has overlappable candidates process
  has_overlappable_candidates({ b, h }: { b: BitReader, h: any }) {
    if (h.AvailU) {
      let w4 = Num_4x4_Blocks_Wide[h.MiSize];
      for (let x4 = h.MiCol; x4 < Math.min(h.MiCols, h.MiCol + w4); x4 += 2) {
        if (h[`RefFrames[${h.MiRow - 1}][${x4 | 1}][0]`] > INTRA_FRAME)
          return 1;
      }
    }
    if (h.AvailL) {
      let h4 = Num_4x4_Blocks_High[h.MiSize];
      for (let y4 = h.MiRow; y4 < Math.min(h.MiRows, h.MiRow + h4); y4 += 2) {
        if (h[`RefFrames[${y4 | 1}][${h.MiCol - 1}][0]`] > INTRA_FRAME)
          return 1;
      }
    }
    return 0;
  }

  decode_frame_wrapup({ b, h }: { b: BitReader, h: any }) {

  }

  init_symbol(sz: number, { b, h }: { b: BitReader, h: any }) {
    // let numBits = Math.min(sz * 8, 15);
    // let buf = b.f(numBits);
    // let paddedBuf = buf << (15 - numBits);
    // let SymbolValue = ((1 << 15) - 1) ^ paddedBuf;
    // let SymbolRange = 1 << 15;
    // let SymbolMaxBits = 8 * sz - 15;
    // while (SymbolMaxBits > 0) {

    // }

    let tileBuffers = [];
    let startBitPos = b.get_position();
    let tc = 0;
    for (let r = 0; r < h['TileRows']; r++) {
      for (let c = 0; c < h['TileCols']; c++) {
        if (tc != h.tg_end) {
          let size = b.le(h['TileSizeBytes']) + 1;
          let data = b.readBuffer(size);
          tileBuffers.push(data);
        } else {
          let endBitPos = b.get_position();
          let size = sz - (endBitPos - startBitPos) / 8;
          let data = b.readBuffer(size);
          tileBuffers.push(data);
        }
      }
    }
  }

  exit_symbol({ b, h }: { b: BitReader, h: any }) {
  }

  frame_end_update_cdf({ b, h }: { b: BitReader, h: any }) {
  }

  load_grain_params(idx: number, { b, h }: { b: BitReader, h: any },) {

  }

  set_frame_refs({ b, h }: { b: BitReader, h: any }) {

  }

  init_non_coeff_cdfs({ b, h }: { b: BitReader, h: any }) {
  }

  load_cdfs(ctx: number, { b, h }: { b: BitReader, h: any }) {

  }

  motion_field_estimation({ b, h }: { b: BitReader, h: any }) {

  }

  init_coeff_cdfs({ b, h }: { b: BitReader, h: any }) {

  }

  load_previous_segment_ids({ b, h }: { b: BitReader, h: any }) {

  }

  //-?
  setup_past_independence({ b, h }: { b: BitReader, h: any }) {
    for (let ref = LAST_FRAME;
      ref <= ALTREF_FRAME; ++ref) {
      for (let i = 0; i <= 5; ++i) {
        h[`PrevGmParams[${ref}][${i}]`] = (i % 3) == 2 ? 1 << 16 : 8;
      }
    }
  };

  //-?
  load_previous() {
  };

  //-?
  get_qindex({ h }: { h: any }, ignoreDeltaQ: number, segmentId: number) {
    let qindex = h.base_q_idx;
    if (h.segmentation_enabled && h[`FeatureEnabled[${segmentId}][0]`])
      qindex += h[`FeatureData[${segmentId}][0]`];
    return this.Clip3(0, 255, qindex);
  };

  Clip1(_1: number) {

  }

  Clip3(low: number, high: number, value: number) {
    return value < low ? low : (value > high ? high : value);
  }

  reset_grain_params({ b, h }: { b: BitReader, h: any }) {
  }

  update_frame_buffers({ h }: { h: any }) {
    if (h.tg_end == undefined || h['TileRows'] == undefined || h['TileCols'] == undefined) return;

    let frameDecodingFinished = h.tg_end == h['TileRows'] * h['TileCols'] - 1;
    if (!frameDecodingFinished) return;

    let refIndex = 0;
    for (let mask = h.refresh_frame_flags; mask; mask = mask >> 1) {
      if (mask & 1) {
        this.RefFrameType[refIndex] = h;
      }
      ++refIndex;
    }
  }

  is_valid_seq_level_idx(seq_level_idx: number) {
    const SEQ_LEVEL_MAX = 31;
    const SEQ_LEVELS = 28;
    const SEQ_LEVEL_2_2 = 2;
    const SEQ_LEVEL_2_3 = 3;
    const SEQ_LEVEL_3_2 = 6;
    const SEQ_LEVEL_3_3 = 7;
    const SEQ_LEVEL_4_2 = 10;
    const SEQ_LEVEL_4_3 = 11;
    let valid = (seq_level_idx == SEQ_LEVEL_MAX ||
      (seq_level_idx < SEQ_LEVELS &&
        // The following levels are currently undefined.
        seq_level_idx != SEQ_LEVEL_2_2 && seq_level_idx != SEQ_LEVEL_2_3 &&
        seq_level_idx != SEQ_LEVEL_3_2 && seq_level_idx != SEQ_LEVEL_3_3 &&
        seq_level_idx != SEQ_LEVEL_4_2 && seq_level_idx != SEQ_LEVEL_4_3));
    if (!valid)
      throw Error("The given bitstream is not supported");
  }

  find_mv_stack(isCompound: number) {

  }

  find_warp_samples() {

  }

  predict_intra(_1: number, _2: number, _3: number, _4: number, _5: number, _6: number, _7: number, _8: number, _9: number, _10: number) {

  }
  predict_inter(_1: number, _2: number, _3: number, _4: number, _5: number, _6: number, _7: number) {

  }
  predict_palette(_1: number, _2: number, _3: number, _4: number, _5: number, _6: number) {

  }
  predict_chroma_from_luma(_1: number, _2: number, _3: number, _4: number) {

  }
  reconstruct(_1: number, _2: number, _3: number, _4: number) {

  }
  sort(arr: number, i1: number, i2: number) {

  }
}